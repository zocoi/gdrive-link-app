import { homedir } from "node:os";
import { join } from "node:path";
import { existsSync, mkdirSync, readFileSync, writeFileSync, unlinkSync, } from "node:fs";
import jwt from "jsonwebtoken";
const CONFIG_DIR = join(homedir(), ".config", "linkapp");
const TOKEN_FILE = join(CONFIG_DIR, "auth-token.json");
const TOKEN_EXPIRY_THRESHOLD_SECONDS = 60; // Consider tokens as expired within the last 60s of actual expiry
/**
 * Validates that a JWT token has the correct structure and permissions
 * @throws Error if token is invalid or lacks permissions
 */
function validateTokenStructure(tokenString) {
    const payload = jwt.decode(tokenString, { json: true });
    if (!payload) {
        throw new Error("There was an error parsing the access token, please try logging in again");
    }
    const permissions = payload.permissions ?? [];
    if (permissions.length === 0) {
        throw new Error("Login request was successful, but the authenticated user does not have appropriate permissions to view or modify LinkApps");
    }
}
/**
 * Type guard to check if stored data is in legacy format
 */
function isLegacyFormat(data) {
    return (typeof data === "object" &&
        data !== null &&
        "accessToken" in data &&
        "audience" in data &&
        !("tokens" in data));
}
/**
 * Reads the token storage, migrating from legacy format if needed
 */
function readTokenStorage() {
    if (!existsSync(TOKEN_FILE)) {
        return { tokens: {} };
    }
    try {
        const rawData = JSON.parse(readFileSync(TOKEN_FILE, "utf-8"));
        // Check if it's legacy format and migrate
        if (isLegacyFormat(rawData)) {
            const migrated = {
                tokens: {
                    [rawData.audience]: {
                        accessToken: rawData.accessToken,
                        expiresAt: rawData.expiresAt,
                    },
                },
            };
            // Write migrated format back to disk
            writeFileSync(TOKEN_FILE, JSON.stringify(migrated, null, 2), "utf-8");
            return migrated;
        }
        // Already in new format
        return rawData;
    }
    catch (error) {
        console.error("Failed to read token storage:", error);
        return { tokens: {} };
    }
}
/**
 * Writes the token storage to disk
 */
function writeTokenStorage(storage) {
    // Ensure config directory exists
    if (!existsSync(CONFIG_DIR)) {
        mkdirSync(CONFIG_DIR, { recursive: true });
    }
    writeFileSync(TOKEN_FILE, JSON.stringify(storage, null, 2), "utf-8");
}
export function saveToken(token, audience, expiresAt) {
    // Validate token structure and permissions before saving
    validateTokenStructure(token);
    // Read existing storage (handles migration if needed)
    const storage = readTokenStorage();
    // Add or update token for this audience
    storage.tokens[audience] = {
        accessToken: token,
        expiresAt,
    };
    // Write updated storage
    writeTokenStorage(storage);
}
export function getToken(audience) {
    // Read storage (handles migration if needed)
    const storage = readTokenStorage();
    // Get token for this audience
    const tokenEntry = storage.tokens[audience];
    if (!tokenEntry) {
        return null;
    }
    // Check if token is expired (with threshold buffer)
    if (tokenEntry.expiresAt &&
        tokenEntry.expiresAt - TOKEN_EXPIRY_THRESHOLD_SECONDS <
            Math.floor(Date.now() / 1000)) {
        // Remove expired token
        removeToken(audience);
        return null;
    }
    return tokenEntry.accessToken;
}
export function removeToken(audience) {
    // Read storage (handles migration if needed)
    const storage = readTokenStorage();
    // If audience is specified, only remove that token
    if (audience) {
        if (storage.tokens[audience]) {
            delete storage.tokens[audience];
            // If there are remaining tokens, write updated storage
            // Otherwise, delete the file
            if (Object.keys(storage.tokens).length > 0) {
                writeTokenStorage(storage);
            }
            else if (existsSync(TOKEN_FILE)) {
                unlinkSync(TOKEN_FILE);
            }
        }
    }
    else {
        // No audience specified - remove all tokens
        if (existsSync(TOKEN_FILE)) {
            unlinkSync(TOKEN_FILE);
        }
    }
}
export function isTokenValid(audience) {
    return getToken(audience) !== null;
}
//# sourceMappingURL=token-storage.js.map