import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";
import { detectLayouts } from "../build/detect-layouts.js";
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
/**
 * Generates main.tsx content with detected layouts and parent-iframe communication
 */
function generateMainTsx(projectPath) {
    const detection = detectLayouts(projectPath);
    const layouts = detection.layouts;
    const hasLayout = detection.hasLayout;
    // Generate import statements for each layout
    const imports = layouts
        .map((layout) => `import ${layout.displayName} from '../app/${layout.fileName}'`)
        .join("\n");
    // Conditionally import Layout if it exists
    const layoutImport = hasLayout
        ? `import Layout from '../app/layout.tsx'`
        : "";
    // Generate layouts object
    const layoutsObj = layouts
        .map((layout) => {
        // Quote keys that contain hyphens
        const key = layout.name.includes("-") ? `'${layout.name}'` : layout.name;
        return `  ${key}: ${layout.displayName},`;
    })
        .join("\n");
    // Generate the wrapper logic - use Layout if it exists, otherwise render directly
    const renderLogic = hasLayout
        ? `      <Layout>
        <LayoutComponent {...data} />
      </Layout>`
        : `      <LayoutComponent {...data} />`;
    return `import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
${layoutImport}
${imports}
import '../app/globals.css'

// Map of available layouts
const layouts: Record<string, React.ComponentType<any>> = {
${layoutsObj}
}

// Type for extension data from parent iframe
type ExtensionData = {
  __linkUrl?: string
  __thumbnail?: string
  __linkParams?: any
  __environment?: any
  __layout?: string
  groupLayoutOption?: string
  __theme?: {
    cssVariables: Record<string, string>
    font?: {
      fontFamily: string
      fontStyle?: string
      cssUrl?: string
    }
  }
  displayType?: string
  [key: string]: any
}

// Declare global window properties for theme and font application
declare global {
  interface Window {
    __linkapp_applyTheme?: (variables: Record<string, string>) => void
    __linkapp_applyFont?: (fontData: {
      fontFamily: string
      fontStyle?: string
      cssUrl?: string
    }) => void
  }
}

const rootElement = document.getElementById('root')
if (!rootElement) {
  throw new Error('Root element not found')
}

// Detect if we're running inside an iframe (production on Linktree)
const isInIframe = window.parent !== window

// Mock context for development mode (minimal theme data)
const mockThemeVars = {
  '--button-style-text': '#000000',
  '--button-style-background': '#ffffff',
  '--button-style-inner-radius': '12px',
  '--button-style-border-color': '#e5e7eb',
  '--button-style-background-hover': '#f3f4f6',
  '--button-style-contrast-color': '#ffffff',
}

const mockContext: ExtensionData = {
  linkUrl: 'https://example.com/demo',
  showTitle: true,
  __theme: {
    cssVariables: mockThemeVars,
  },
  theme: {
    cssVariables: mockThemeVars,
    textColor: '#000000',
    backgroundColor: '#ffffff',
    borderRadius: '12px',
    borderColor: '#e5e7eb',
    backgroundHover: '#f3f4f6',
    contrastColor: '#ffffff',
    textHoverColor: '#111827',
  },
}

function App({ data }: { data: ExtensionData }) {
  // Get layout and groupLayoutOption from extension data (production), query parameters (dev), or defaults
  const params = new URLSearchParams(window.location.search)
  const baseLayout = data.__layout || params.get('layout') || 'classic'
  const groupLayoutOption = data.groupLayoutOption || params.get('groupLayoutOption')

  // Simple layout selection: sheet.tsx OR featured.tsx OR featured-carousel.tsx
  let layoutName: string

  if (baseLayout === 'classic') {
    layoutName = 'sheet'
  } else if (baseLayout === 'featured' && groupLayoutOption === 'carousel') {
    layoutName = 'featured-carousel'
  } else {
    layoutName = 'featured'
  }

  const LayoutComponent = layouts[layoutName] || layouts.sheet

  // Debug logging (only in development or when component is missing)
  if (!isInIframe || !LayoutComponent) {
    console.log('[LinkApp] Layout selection:', {
      __layout: data.__layout,
      groupLayoutOption: data.groupLayoutOption,
      selectedLayout: layoutName,
      availableLayouts: Object.keys(layouts),
    })
  }

  if (!LayoutComponent) {
    return (
      <div style={{ padding: '20px', fontFamily: 'system-ui' }}>
        <h1>Error: Layout not found</h1>
        <p>Layout "{layoutName}" does not exist.</p>
        <p>Available layouts: {Object.keys(layouts).join(', ')}</p>
      </div>
    )
  }

  return (
${renderLogic}
  )
}

const postExtensionReadyMessage = () => {
  const height = rootElement.clientHeight
  const message = {
    type: 'extension-ready',
    data: {
      ready: true,
      height: height,
    },
  }
  window.parent.postMessage(message, '*')
}

type RootInstance = ReturnType<typeof createRoot>

type LinkappWindow = Window & {
  __linkappRoot?: RootInstance | undefined
}

const linkappWindow = window as LinkappWindow

// Create root once and reuse it across reloads
const root =
  linkappWindow.__linkappRoot ?? createRoot(rootElement)

linkappWindow.__linkappRoot = root

const renderApp = (data: ExtensionData) => {
  // Apply theme CSS variables if provided
  if (data.__theme?.cssVariables && window.__linkapp_applyTheme) {
    window.__linkapp_applyTheme(data.__theme.cssVariables)
  }

  // Apply font if provided
  if (data.__theme?.font && window.__linkapp_applyFont) {
    window.__linkapp_applyFont(data.__theme.font)
  }

  root.render(
    <StrictMode>
      <App data={data} />
    </StrictMode>
  )
  postExtensionReadyMessage()
}

// Setup parent-iframe communication for production mode
if (isInIframe) {
  // Listen for extension-data from parent ExtensionEmbed component
  window.addEventListener('message', function handler(event) {
    // Security: validate origin (allow Linktree domains and localhost for testing)
    const allowedOrigins = /^https:\\/\\/(qa\\.)?linktr\\.ee$|^https:\\/\\/linktree\\.local$|^https?:\\/\\/localhost(:\\d+)?$/
    if (!allowedOrigins.test(event.origin)) {
      return
    }

    if (event.data?.type !== 'extension-data') {
      return
    }

    // Render app with data from parent
    renderApp(event.data.data ?? {})
    window.removeEventListener('message', handler)
  })

  // Send extension-loaded message to parent
  window.parent.postMessage({ type: 'extension-loaded' }, '*')

  // Forward interaction events to parent for analytics
  document.addEventListener('interaction-event', (event: Event) => {
    const customEvent = event as CustomEvent<Record<string, unknown>>
    window.parent.postMessage(
      { type: 'interaction-event', data: customEvent.detail },
      '*'
    )
  })
} else {
  // Development mode: render immediately with mock data
  renderApp(mockContext)
}
`;
}
/**
 * Sets up runtime files (.linkapp directory) in the user's project
 * These files are managed by the CLI and should not be edited by users
 */
export function setupRuntime(projectPath) {
    try {
        const linkappDir = join(projectPath, ".linkapp");
        const runtimeSourceDir = join(__dirname, "..", "..", "..", "runtime");
        // Create .linkapp directory if it doesn't exist
        if (!existsSync(linkappDir)) {
            mkdirSync(linkappDir, { recursive: true });
        }
        // Copy index.html
        const indexHtmlPath = join(runtimeSourceDir, "index.html");
        if (!existsSync(indexHtmlPath)) {
            throw new Error(`Runtime file not found: ${indexHtmlPath}`);
        }
        const indexHtml = readFileSync(indexHtmlPath, "utf-8");
        writeFileSync(join(linkappDir, "index.html"), indexHtml, "utf-8");
        // Generate and write main.tsx dynamically based on detected layouts
        const mainTsx = generateMainTsx(projectPath);
        writeFileSync(join(linkappDir, "main.tsx"), mainTsx, "utf-8");
    }
    catch (error) {
        console.error("Failed to setup runtime files:", error);
        throw error;
    }
}
//# sourceMappingURL=setup-runtime.js.map