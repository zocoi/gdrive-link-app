import axios from 'axios';
import FormData from 'form-data';
import { createReadStream, existsSync } from 'node:fs';
import { join } from 'node:path';
export async function uploadAssets(options) {
    const projectPath = options.projectPath || process.cwd();
    const linkappDir = join(projectPath, '.linkapp');
    const packagePath = join(projectPath, 'package.tgz');
    const manifestPath = join(linkappDir, 'manifest.json');
    const settingsPath = join(linkappDir, 'settings.json');
    const urlMatchRulesPath = join(linkappDir, 'url_match_rules.json');
    const iconPath = join(projectPath, 'icon.svg');
    // Required files
    if (!existsSync(packagePath)) {
        throw new Error('Package file not found. Run pack step first.');
    }
    if (!existsSync(manifestPath)) {
        throw new Error('Manifest file not found. Generate manifest.json from config.');
    }
    const form = new FormData();
    // Add required files with correct content types
    // Note: linkTypeId is read from linkapp.config.ts inside the package, not sent as a form field
    form.append('package', createReadStream(packagePath), {
        contentType: 'application/gzip',
        filename: 'package.tgz',
    });
    form.append('manifest', createReadStream(manifestPath), {
        contentType: 'application/json',
        filename: 'manifest.json',
    });
    // Add optional files
    if (existsSync(settingsPath)) {
        form.append('settings', createReadStream(settingsPath), {
            contentType: 'application/json',
            filename: 'settings.json',
        });
    }
    if (existsSync(urlMatchRulesPath)) {
        form.append('url_match_rules', createReadStream(urlMatchRulesPath), {
            contentType: 'application/json',
            filename: 'url_match_rules.json',
        });
    }
    if (existsSync(iconPath)) {
        form.append('icon', createReadStream(iconPath), {
            contentType: 'image/svg+xml',
            filename: 'icon.svg',
        });
    }
    const headers = {
        ...form.getHeaders(),
        Authorization: `Bearer ${options.accessToken}`,
    };
    if (options.isUpdate && options.forceUpdate) {
        headers['force-update'] = 'true';
    }
    const method = options.isUpdate ? 'put' : 'post';
    // Use the same URL for both POST and PUT - backend determines create vs update from linkTypeId in form data
    const url = options.apiUrl;
    try {
        const response = await axios[method](url, form, { headers });
        return response.data;
    }
    catch (error) {
        if (axios.isAxiosError(error) && error.response?.data) {
            const errorData = error.response.data;
            // Log verbose error details
            console.error('\n=== VERBOSE ERROR DETAILS ===');
            console.error('Status:', error.response.status);
            console.error('Response data:', JSON.stringify(errorData, null, 2));
            console.error('Request URL:', url);
            console.error('Request method:', method.toUpperCase());
            console.error('=============================\n');
            // Create a more detailed error message
            const detailedError = new Error('API request failed');
            detailedError.statusCode = error.response.status;
            detailedError.responseData = errorData;
            detailedError.messages = errorData.message || [];
            throw detailedError;
        }
        throw error;
    }
}
export async function checkLinkAppExists(apiUrl, linkAppId, accessToken) {
    try {
        const response = await axios.get(`${apiUrl}/${linkAppId}`, {
            headers: {
                Authorization: `Bearer ${accessToken}`,
            },
        });
        // Verify the response contains a matching linkTypeId
        // This ensures we actually got the LinkApp we're looking for
        return response.data?.linkTypeId === linkAppId;
    }
    catch (error) {
        // Check if 404 - linkApp with this specific ID doesn't exist
        if (axios.isAxiosError(error) && error.response?.status === 404) {
            return false;
        }
        // For other errors, assume it doesn't exist
        return false;
    }
}
//# sourceMappingURL=upload.js.map