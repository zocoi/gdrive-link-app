import { existsSync } from 'node:fs';
import { join } from 'node:path';
import pc from 'picocolors';
import * as p from '@clack/prompts';
import { getAppConfig } from '../auth/config.js';
import { getToken } from '../auth/token-storage.js';
import { buildCommand } from '../../commands/build.js';
import { validateProject, printValidationResults } from './validation.js';
import { generateManifestFiles } from './generate-manifest-files.js';
import { packProject } from './pack-project.js';
import { checkLinkAppExists, uploadAssets } from './upload.js';
import { resolveConfigPath, getLinkAppIdFromConfig, AuthenticationError, ValidationError, DeploymentCancelledError, writeLine, writeSection, formatElapsedTime, displayFileList, pluralize, } from './deploy-utils.js';
// ============================================================================
// PHASE 1: INITIALIZATION
// ============================================================================
export async function initializeDeployment(options) {
    const env = options.qa ? 'qa' : 'production';
    const config = await getAppConfig(env);
    const projectPath = options.path ?? process.cwd();
    const configPath = resolveConfigPath(projectPath);
    const linkAppId = await getLinkAppIdFromConfig(configPath);
    writeSection(`Deploying ${linkAppId} to ${env}`);
    const accessToken = getToken(config.auth.audience);
    if (!accessToken) {
        throw new AuthenticationError(env);
    }
    return {
        env,
        config,
        projectPath,
        linkAppId,
        accessToken,
        startTime: Date.now(),
        options,
    };
}
// ============================================================================
// PHASE 2: PREFLIGHT CHECKS
// ============================================================================
export async function runPreflightChecks(context) {
    // Ensure project is built
    if (!context.options.skipBuild) {
        const distPath = join(context.projectPath, 'dist');
        if (!existsSync(distPath)) {
            writeLine(pc.bold('Building project...'));
            const buildStart = Date.now();
            await buildCommand({ sourcemap: false });
            writeLine(pc.dim(`  Completed in ${formatElapsedTime(Date.now() - buildStart)}`));
            writeLine();
        }
    }
    // Run validation checks
    if (!context.options.skipChecks) {
        writeLine(pc.bold('Pre-deployment checks'));
        const validationResult = await validateProject();
        printValidationResults(validationResult);
        if (!validationResult.success) {
            writeLine();
            throw new ValidationError('Validation failed');
        }
        writeLine();
    }
}
// ============================================================================
// PHASE 3: PREPARE ARTIFACTS
// ============================================================================
export async function prepareDeploymentArtifacts(context) {
    const s = p.spinner();
    s.start('Generating manifest files');
    await generateManifestFiles(context.projectPath);
    s.stop('Manifest files generated');
    s.start('Checking LinkApp status');
    const apiUrl = context.options.endpoint ?? `${context.config.link_types_url}/link-types`;
    const exists = await checkLinkAppExists(apiUrl, context.linkAppId, context.accessToken);
    s.stop(exists ? 'Updating existing LinkApp' : 'Creating new LinkApp');
    s.start('Packing project files');
    const packedFiles = await packProject({ projectPath: context.projectPath });
    s.stop(`Packed ${pluralize(packedFiles.length, 'item')}`);
    return { packedFiles, exists, apiUrl };
}
// ============================================================================
// PHASE 4: CONFIRM DEPLOYMENT
// ============================================================================
export async function confirmDeployment(context, artifacts) {
    if (context.options.skipConfirm)
        return;
    displayFileList(artifacts.packedFiles, 'Files to upload:');
    writeLine();
    const shouldDeploy = await p.confirm({
        message: `Deploy to ${context.env}?`,
        initialValue: true,
    });
    if (p.isCancel(shouldDeploy) || !shouldDeploy) {
        throw new DeploymentCancelledError();
    }
}
// ============================================================================
// PHASE 5: EXECUTE DEPLOYMENT
// ============================================================================
export async function executeDeployment(context, artifacts) {
    writeLine();
    const uploadStart = Date.now();
    const s = p.spinner();
    s.start('Uploading assets');
    const result = await uploadAssets({
        projectPath: context.projectPath,
        apiUrl: artifacts.apiUrl,
        linkAppId: context.linkAppId,
        accessToken: context.accessToken,
        isUpdate: artifacts.exists,
        forceUpdate: context.options.force,
    });
    s.stop(`Assets uploaded (${formatElapsedTime(Date.now() - uploadStart)})`);
    return result;
}
//# sourceMappingURL=deploy-phases.js.map