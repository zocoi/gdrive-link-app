import { existsSync, statSync, readdirSync } from 'node:fs';
import { join } from 'node:path';
import { spawn } from 'node:child_process';
import pc from 'picocolors';
import { resolveConfigPath, writeLine } from './deploy-utils.js';
export async function validateProject(projectPath = process.cwd()) {
    const result = {
        success: true,
        errors: [],
        warnings: [],
    };
    // Check config file exists (use shared resolver)
    try {
        resolveConfigPath(projectPath);
    }
    catch {
        result.errors.push('Config file missing: linkapp.config.ts');
        result.success = false;
    }
    // Note: Config schema validation happens during manifest generation via generateManifestFiles()
    // Check dist directory exists (optional - CI/Buildkite will build)
    const distPath = join(projectPath, 'dist');
    if (!existsSync(distPath)) {
        result.warnings.push('Build output missing. This is OK if deploying to CI/Buildkite. Run "linkapp build" for local testing.');
    }
    else {
        // Check dist has files
        const distSize = getDirSize(distPath);
        if (distSize === 0) {
            result.warnings.push('Build output is empty. This is OK if deploying to CI/Buildkite.');
        }
        else if (distSize > 5 * 1024 * 1024) {
            // Warn if over 5MB
            const sizeMB = (distSize / (1024 * 1024)).toFixed(2);
            result.warnings.push(`Bundle size is large: ${sizeMB}MB. Consider optimizing.`);
        }
    }
    // Check package.json exists
    const packageJsonPath = join(projectPath, 'package.json');
    if (!existsSync(packageJsonPath)) {
        result.warnings.push('package.json not found');
    }
    // Run TypeScript type check
    const typeCheckResult = await runTypeCheck(projectPath);
    if (!typeCheckResult.success) {
        result.errors.push('TypeScript type check failed. Fix type errors before deploying.');
        result.success = false;
    }
    return result;
}
async function runTypeCheck(projectPath) {
    return new Promise((resolve) => {
        const child = spawn('npm', ['run', 'type-check'], {
            cwd: projectPath,
            stdio: 'pipe',
            shell: true,
        });
        child.on('close', (code) => {
            resolve({ success: code === 0 });
        });
        child.on('error', () => {
            // If type-check script doesn't exist, pass validation
            resolve({ success: true });
        });
    });
}
function getDirSize(dirPath) {
    let totalSize = 0;
    try {
        const files = readdirSync(dirPath);
        for (const file of files) {
            const filePath = join(dirPath, file);
            const stats = statSync(filePath);
            if (stats.isDirectory()) {
                totalSize += getDirSize(filePath);
            }
            else {
                totalSize += stats.size;
            }
        }
    }
    catch {
        // Ignore errors
    }
    return totalSize;
}
export function printValidationResults(result) {
    // Show errors first if any
    if (result.errors.length > 0) {
        writeLine(pc.red(pc.bold('\n  ✗ Errors:')));
        for (const error of result.errors) {
            writeLine(pc.red(`    • ${error}`));
        }
    }
    // Show warnings if any
    if (result.warnings.length > 0) {
        writeLine(pc.yellow(pc.bold('\n  ⚠ Warnings:')));
        for (const warning of result.warnings) {
            writeLine(pc.yellow(`    • ${warning}`));
        }
    }
    // Show success if no errors
    if (result.success && result.errors.length === 0) {
        writeLine(pc.green(pc.bold('\n  ✓ Validation passed')));
    }
}
//# sourceMappingURL=validation.js.map