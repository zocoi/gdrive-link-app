import { brotliCompressSync, constants } from 'node:zlib';
import { readFileSync, writeFileSync, readdirSync, statSync } from 'node:fs';
import { join, extname } from 'node:path';
import pc from 'picocolors';
export function brotliCompression(options = {}) {
    const { test = ['.js', '.css', '.html', '.svg', '.json'], threshold = 1024, quality = 11, } = options;
    return {
        name: 'brotli-compression',
        setup(api) {
            api.onAfterBuild(async () => {
                const config = api.getNormalizedConfig();
                const distPath = config.output.distPath.root;
                if (!distPath) {
                    return;
                }
                console.log(pc.cyan('\nðŸ—œï¸  Compressing assets with Brotli...'));
                const compressedFiles = [];
                function compressDirectory(dirPath) {
                    const files = readdirSync(dirPath);
                    for (const file of files) {
                        const filePath = join(dirPath, file);
                        const stat = statSync(filePath);
                        if (stat.isDirectory()) {
                            compressDirectory(filePath);
                        }
                        else {
                            const ext = extname(file);
                            if (test.includes(ext) && stat.size >= threshold) {
                                try {
                                    const content = readFileSync(filePath);
                                    const compressed = brotliCompressSync(content, {
                                        params: {
                                            [constants.BROTLI_PARAM_QUALITY]: quality,
                                            [constants.BROTLI_PARAM_MODE]: constants.BROTLI_MODE_TEXT,
                                        },
                                    });
                                    const outputPath = `${filePath}.br`;
                                    writeFileSync(outputPath, compressed);
                                    const compressionRatio = ((1 - compressed.length / content.length) * 100).toFixed(1);
                                    compressedFiles.push({
                                        name: file,
                                        original: content.length,
                                        compressed: compressed.length,
                                    });
                                    console.log(pc.dim(`  âœ“ ${file} ${(content.length / 1024).toFixed(1)} KB â†’ ${(compressed.length / 1024).toFixed(1)} KB (${compressionRatio}% smaller)`));
                                }
                                catch (error) {
                                    console.warn(pc.yellow(`  âš  Failed to compress ${file}:`), error);
                                }
                            }
                        }
                    }
                }
                compressDirectory(distPath);
                if (compressedFiles.length > 0) {
                    const totalOriginal = compressedFiles.reduce((sum, f) => sum + f.original, 0);
                    const totalCompressed = compressedFiles.reduce((sum, f) => sum + f.compressed, 0);
                    const totalSavings = ((1 - totalCompressed / totalOriginal) * 100).toFixed(1);
                    console.log(pc.green(`\nâœ“ Compressed ${compressedFiles.length} files: ${(totalOriginal / 1024).toFixed(1)} KB â†’ ${(totalCompressed / 1024).toFixed(1)} KB (${totalSavings}% smaller)`));
                }
                else {
                    console.log(pc.dim('  No files met compression criteria'));
                }
            });
        },
    };
}
//# sourceMappingURL=brotli-compression.js.map