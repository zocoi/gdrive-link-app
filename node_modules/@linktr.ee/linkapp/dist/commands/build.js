import pc from 'picocolors';
import { createRsbuild } from '@rsbuild/core';
import { createRsbuildConfig } from '../lib/rsbuild/config-factory.js';
import { existsSync, statSync, readdirSync, readFileSync, copyFileSync } from 'node:fs';
import { join } from 'node:path';
import { gzipSync, brotliCompressSync, constants } from 'node:zlib';
const writeLine = (message = '') => process.stdout.write(`${message}\n`);
function getDirSize(dirPath) {
    let totalSize = 0;
    for (const file of readdirSync(dirPath)) {
        const filePath = join(dirPath, file);
        const stats = statSync(filePath);
        totalSize += stats.isDirectory() ? getDirSize(filePath) : stats.size;
    }
    return totalSize;
}
function collectAssetDetails(stats) {
    if (!stats)
        return [];
    const collectFromStats = (single) => {
        const json = single.toJson({ assets: true, modules: false, chunks: false });
        const assets = Array.isArray(json.assets) ? json.assets : [];
        return assets
            .filter((asset) => asset.emitted && asset.name && asset.size !== undefined)
            .map((asset) => ({ name: asset.name, size: asset.size }))
            .sort((a, b) => a.name.localeCompare(b.name));
    };
    if ('stats' in stats && Array.isArray(stats.stats)) {
        return stats.stats.flatMap(collectFromStats).sort((a, b) => a.name.localeCompare(b.name));
    }
    return collectFromStats(stats);
}
function getCompressionSizes(assetPath) {
    try {
        const content = readFileSync(assetPath);
        const gzipped = gzipSync(content);
        const brotli = brotliCompressSync(content, {
            params: { [constants.BROTLI_PARAM_QUALITY]: 11 },
        });
        return {
            gzipKB: (gzipped.length / 1024).toFixed(1),
            brotliKB: (brotli.length / 1024).toFixed(1),
        };
    }
    catch {
        return null;
    }
}
export async function buildCommand(options) {
    writeLine(pc.cyan('ðŸ—ï¸  Building for production...'));
    writeLine();
    const startTime = Date.now();
    try {
        const enableProfiling = options.profile || options.analyze || false;
        const config = createRsbuildConfig({
            mode: 'production',
            sourcemap: options.sourcemap || false,
            profile: enableProfiling,
            compress: options.compress || false,
        });
        const rsbuild = await createRsbuild({ rsbuildConfig: config });
        const buildResult = await rsbuild.build();
        // Copy app/icon.svg to dist/icon.svg for deployment
        const iconSource = join(process.cwd(), 'app', 'icon.svg');
        const iconDest = join(process.cwd(), 'dist', 'icon.svg');
        if (existsSync(iconSource)) {
            copyFileSync(iconSource, iconDest);
        }
        const duration = ((Date.now() - startTime) / 1000).toFixed(2);
        writeLine();
        writeLine(pc.green(`âœ“ Build completed in ${duration}s`));
        writeLine();
        const assetDetails = collectAssetDetails(buildResult?.stats);
        if (assetDetails.length > 0) {
            const distPath = join(process.cwd(), 'dist');
            writeLine(pc.bold('Build output:'));
            for (const asset of assetDetails) {
                const sizeKB = (asset.size / 1024).toFixed(1);
                const isCompressible = asset.name.endsWith('.js') || asset.name.endsWith('.css');
                const assetPath = join(distPath, asset.name);
                if (isCompressible && existsSync(assetPath)) {
                    const sizes = getCompressionSizes(assetPath);
                    if (sizes) {
                        writeLine(pc.dim(`  ${asset.name}`));
                        writeLine(pc.dim(`    ${sizeKB} KB (raw) â†’ ${sizes.gzipKB} KB (gzip) â†’ ${sizes.brotliKB} KB (brotli)`));
                    }
                    else {
                        writeLine(pc.dim(`  ${asset.name} ${sizeKB} KB`));
                    }
                }
                else {
                    writeLine(pc.dim(`  ${asset.name} ${sizeKB} KB`));
                }
            }
            writeLine();
            const jsAssets = assetDetails.filter(a => a.name.endsWith('.js'));
            const cssAssets = assetDetails.filter(a => a.name.endsWith('.css'));
            const totalJS = jsAssets.reduce((sum, a) => sum + a.size, 0);
            const totalCSS = cssAssets.reduce((sum, a) => sum + a.size, 0);
            if (totalJS > 0 || totalCSS > 0) {
                writeLine(pc.bold('Bundle size summary:'));
                if (totalJS > 0)
                    writeLine(pc.dim(`  JavaScript: ${(totalJS / 1024).toFixed(1)} KB`));
                if (totalCSS > 0)
                    writeLine(pc.dim(`  CSS: ${(totalCSS / 1024).toFixed(1)} KB`));
                writeLine();
            }
            if (existsSync(distPath)) {
                const totalSize = getDirSize(distPath);
                writeLine(pc.dim(`Total dist size: ${(totalSize / 1024).toFixed(1)} KB`));
                writeLine();
            }
        }
        if (enableProfiling) {
            writeLine(pc.cyan('\nðŸ“Š Bundle analysis:'));
            writeLine(pc.cyan('   ðŸ’¡ Use --sourcemap flag and analyze with external tools'));
            writeLine();
        }
        await buildResult?.close();
    }
    catch (error) {
        console.error(pc.red('Build failed:'), error);
        process.exit(1);
    }
}
//# sourceMappingURL=build.js.map