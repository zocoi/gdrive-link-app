import pc from 'picocolors';
import { createRsbuild, logger } from '@rsbuild/core';
import { pluginReact } from '@rsbuild/plugin-react';
import { dirname, resolve, join, extname, relative, sep } from 'node:path';
import { fileURLToPath } from 'node:url';
import { validateLayouts, detectLayouts } from '../lib/build/detect-layouts.js';
import { loadConfig } from '../lib/config/load-config.js';
import { detect } from 'detect-port';
import { existsSync, readFileSync, statSync, writeFileSync, mkdirSync } from 'node:fs';
import chokidar from 'chokidar';
const writeLine = (message = '') => {
    process.stdout.write(`${message}\n`);
};
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
/**
 * Watches linkapp.config.ts for changes and triggers server restart.
 * Based on Rsbuild's watchFilesForRestart implementation.
 */
function createConfigWatcherPlugin(userProjectPath, onConfigChange) {
    return {
        name: 'linkapp:config-watcher',
        setup(api) {
            let watcher;
            api.onBeforeStartDevServer(async () => {
                const configPaths = [
                    resolve(userProjectPath, 'linkapp.config.ts'),
                    resolve(userProjectPath, '.config', 'linkapp.config.ts'),
                ].filter((path) => existsSync(path));
                if (configPaths.length === 0)
                    return;
                watcher = chokidar.watch(configPaths, {
                    ignoreInitial: true,
                    ignorePermissionErrors: true,
                });
                const onChange = async (filePath) => {
                    writeLine(pc.cyan(`\n  ○ ${relative(userProjectPath, filePath)} changed, restarting dev server...\n`));
                    await onConfigChange();
                };
                watcher.on('change', onChange);
                watcher.on('add', onChange);
                watcher.on('unlink', onChange);
            });
            api.onCloseDevServer(async () => {
                await watcher?.close();
            });
        },
    };
}
/**
 * Creates middleware to serve static assets from the user's public directory
 * while matching the legacy dev server behavior.
 */
function createPublicDirPlugin(userPublicDir) {
    const contentTypes = {
        css: 'text/css',
        gif: 'image/gif',
        html: 'text/html',
        ico: 'image/x-icon',
        jpeg: 'image/jpeg',
        jpg: 'image/jpeg',
        js: 'application/javascript',
        json: 'application/json',
        png: 'image/png',
        svg: 'image/svg+xml',
        txt: 'text/plain',
        webp: 'image/webp',
    };
    return {
        name: 'linkapp:public-dir',
        setup(api) {
            api.onBeforeStartDevServer(async ({ server }) => {
                if (!existsSync(userPublicDir)) {
                    return;
                }
                const publicDirRoot = resolve(userPublicDir);
                server.middlewares.use((req, res, next) => {
                    if (!req.url) {
                        next();
                        return;
                    }
                    const method = req.method ?? 'GET';
                    if (method !== 'GET' && method !== 'HEAD') {
                        next();
                        return;
                    }
                    const [rawPath] = req.url.split('?');
                    if (!rawPath || rawPath === '/' || rawPath === '') {
                        next();
                        return;
                    }
                    let decodedPath;
                    try {
                        decodedPath = decodeURIComponent(rawPath);
                    }
                    catch {
                        next();
                        return;
                    }
                    const normalizedPath = decodedPath.startsWith('/') ? decodedPath : `/${decodedPath}`;
                    const targetPath = resolve(publicDirRoot, `.${normalizedPath}`);
                    const relativePath = relative(publicDirRoot, targetPath);
                    if (relativePath.startsWith('..') ||
                        relativePath.includes(`..${sep}`) ||
                        targetPath === publicDirRoot) {
                        next();
                        return;
                    }
                    let stats;
                    try {
                        stats = statSync(targetPath);
                    }
                    catch {
                        next();
                        return;
                    }
                    if (!stats.isFile()) {
                        next();
                        return;
                    }
                    const extension = extname(targetPath).slice(1).toLowerCase();
                    const contentType = (extension && contentTypes[extension]) || 'application/octet-stream';
                    res.setHeader('Content-Type', contentType);
                    res.setHeader('Cache-Control', 'no-cache');
                    if (method === 'HEAD') {
                        res.end();
                        return;
                    }
                    try {
                        const content = readFileSync(targetPath);
                        res.end(content);
                    }
                    catch (error) {
                        next(error);
                    }
                });
            });
        },
    };
}
/**
 * Generates the sheet entry point dynamically
 */
function generateSheetEntryPoint(devServerPath) {
    // Use absolute paths to shared theme files in the dev-server directory
    const themePresetsPath = resolve(devServerPath, 'shared/theme-presets');
    const themeUtilsPath = resolve(devServerPath, 'shared/theme-utils');
    return `import Sheet from "@/app/sheet";
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "@/app/globals.css";
import { THEME_PRESETS } from "${themePresetsPath}";
import { getThemeFromUrl, mergeThemeProps } from "${themeUtilsPath}";

// Declare global window properties for theme and font application
declare global {
  interface Window {
    __linkapp_applyTheme?: (variables: Record<string, string>) => void
    __linkapp_applyFont?: (fontData: {
      fontFamily: string
      fontStyle?: string
      cssUrl?: string
    }) => void
  }
}

// Preview props injected by dev server via Rsbuild define
declare const __PREVIEW_PROPS__: Record<string, unknown>;

// Extract just the variables from THEME_PRESETS for theme lookups
const THEME_VARS = Object.fromEntries(
  Object.entries(THEME_PRESETS).map(([key, { variables }]) => [key, variables])
);

// Get theme variables from URL (defaults to 'default' theme)
const themeVariables = getThemeFromUrl(THEME_VARS) || THEME_PRESETS.default.variables;

// Get the selected theme key from URL or default to "default"
const urlParams = new URLSearchParams(window.location.search);
const themeKey = urlParams.get("theme") || "default";
const selectedTheme = THEME_PRESETS[themeKey as keyof typeof THEME_PRESETS] || THEME_PRESETS.default;

// Merge with preview props
const previewProps = __PREVIEW_PROPS__ || {};
const mergedProps = mergeThemeProps(themeVariables, previewProps);

// Apply theme CSS variables on mount (always apply, even if default)
if (window.__linkapp_applyTheme) {
  window.__linkapp_applyTheme(themeVariables);
}

// Apply font on mount
if (selectedTheme.font && window.__linkapp_applyFont) {
  window.__linkapp_applyFont(selectedTheme.font);
}

const rootElement = document.getElementById("root");
if (!rootElement) {
  throw new Error("Root element not found");
}

createRoot(rootElement).render(
  <StrictMode>
    <Sheet {...mergedProps} />
  </StrictMode>,
);
`;
}
/**
 * Generates the featured-carousel entry point (always uses FeaturedCarousel component)
 */
function generateFeaturedCarouselEntryPoint(devServerPath) {
    // Use absolute paths to shared theme files in the dev-server directory
    const themePresetsPath = resolve(devServerPath, 'shared/theme-presets');
    const themeUtilsPath = resolve(devServerPath, 'shared/theme-utils');
    return `import FeaturedCarousel from "@/app/featured-carousel";
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "@/app/globals.css";
import { THEME_PRESETS } from "${themePresetsPath}";
import { getThemeFromUrl, mergeThemeProps } from "${themeUtilsPath}";

// Declare global window property for theme application
declare global {
  interface Window {
    __linkapp_applyTheme?: (variables: Record<string, string>) => void
  }
}

// Preview props injected by dev server via Rsbuild define
declare const __PREVIEW_PROPS__: Record<string, unknown>;

// Extract just the variables from THEME_PRESETS for theme lookups
const THEME_VARS = Object.fromEntries(
  Object.entries(THEME_PRESETS).map(([key, { variables }]) => [key, variables])
);

// Get theme variables from URL
const themeVariables = getThemeFromUrl(THEME_VARS) || THEME_PRESETS.default.variables;

// Merge with preview props
const previewProps = __PREVIEW_PROPS__ || {};
const mergedProps = mergeThemeProps(themeVariables, previewProps);

// Apply theme CSS variables on mount (always apply, even if default)
if (window.__linkapp_applyTheme) {
  window.__linkapp_applyTheme(themeVariables);
}

const rootElement = document.getElementById("root");
if (!rootElement) {
  throw new Error("Root element not found");
}

createRoot(rootElement).render(
  <StrictMode>
    <FeaturedCarousel {...mergedProps} />
  </StrictMode>,
);
`;
}
/**
 * Generates the featured entry point dynamically based on available layouts
 */
function generateFeaturedEntryPoint(devServerPath, hasFeaturedCarousel) {
    // Use absolute paths to shared theme files in the dev-server directory
    const themePresetsPath = resolve(devServerPath, 'shared/theme-presets');
    const themeUtilsPath = resolve(devServerPath, 'shared/theme-utils');
    const featuredCarouselImport = hasFeaturedCarousel
        ? `import FeaturedCarousel from "@/app/featured-carousel";`
        : '';
    const componentSelection = hasFeaturedCarousel
        ? `// Select the appropriate component based on groupLayoutOption parameter
const LayoutComponent = (groupLayoutOptionParam === 'carousel' && FeaturedCarousel)
  ? FeaturedCarousel
  : Featured;`
        : `// Only Featured layout is available
const LayoutComponent = Featured;`;
    return `import Featured from "@/app/featured";
${featuredCarouselImport}
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import "@/app/globals.css";
import { THEME_PRESETS } from "${themePresetsPath}";
import { getThemeFromUrl, mergeThemeProps } from "${themeUtilsPath}";

// Declare global window properties for theme and font application
declare global {
  interface Window {
    __linkapp_applyTheme?: (variables: Record<string, string>) => void
    __linkapp_applyFont?: (fontData: {
      fontFamily: string
      fontStyle?: string
      cssUrl?: string
    }) => void
  }
}

// Preview props injected by dev server via Rsbuild define
declare const __PREVIEW_PROPS__: Record<string, unknown>;

// Extract just the variables from THEME_PRESETS for theme lookups
const THEME_VARS = Object.fromEntries(
  Object.entries(THEME_PRESETS).map(([key, { variables }]) => [key, variables])
);

// Get theme variables and groupLayoutOption from URL
const params = new URLSearchParams(window.location.search);
const groupLayoutOptionParam = params.get('groupLayoutOption');
const themeVariables = getThemeFromUrl(THEME_VARS) || THEME_PRESETS.default.variables;

// Get the selected theme for font application
const themeKey = params.get("theme") || "default";
const selectedTheme = THEME_PRESETS[themeKey as keyof typeof THEME_PRESETS] || THEME_PRESETS.default;

// Merge with preview props and add groupLayoutOption
const previewProps = __PREVIEW_PROPS__ || {};
const mergedProps = mergeThemeProps(themeVariables, previewProps, {
  groupLayoutOption: groupLayoutOptionParam || undefined,
});

// Apply theme CSS variables on mount (always apply, even if default)
if (window.__linkapp_applyTheme) {
  window.__linkapp_applyTheme(themeVariables);
}

// Apply font on mount
if (selectedTheme.font && window.__linkapp_applyFont) {
  window.__linkapp_applyFont(selectedTheme.font);
}

const rootElement = document.getElementById("root");
if (!rootElement) {
  throw new Error("Root element not found");
}

${componentSelection}

createRoot(rootElement).render(
  <StrictMode>
    <LayoutComponent {...mergedProps} />
  </StrictMode>,
);
`;
}
export async function devCommand(options) {
    const userProjectPath = process.env.TURBO_PACKAGE_DIR ?? process.cwd();
    process.env.LINKAPP_USER_PROJECT_PATH = userProjectPath;
    // Suppress Rsbuild's built-in logging messages
    logger.override({
        start: () => { }, // Suppress "start build started..." messages
        ready: () => { }, // Suppress "ready built in..." messages
    });
    try {
        const startTime = Date.now();
        // Validate layouts exist
        const validation = validateLayouts(userProjectPath);
        if (!validation.valid) {
            writeLine(pc.red('✗ Invalid project structure'));
            for (const error of validation.errors) {
                writeLine(pc.red(`  ${error}`));
            }
            process.exit(1);
        }
        // Get dev server path (needed for generating entry points and later for Rsbuild config)
        const devServerPath = resolve(__dirname, '../../dev-server');
        // Detect available layouts for dynamic entry generation
        const layoutDetection = detectLayouts(userProjectPath);
        const hasFeatured = layoutDetection.layouts.some(l => l.name === 'featured');
        const hasFeaturedCarousel = layoutDetection.layouts.some(l => l.name === 'featured-carousel');
        // Generate dynamic entry points in .linkapp directory
        const linkappDir = join(userProjectPath, ".linkapp");
        if (!existsSync(linkappDir)) {
            mkdirSync(linkappDir, { recursive: true });
        }
        const sheetEntryPath = join(linkappDir, "dev-sheet-main.tsx");
        const featuredEntryPath = join(linkappDir, "dev-featured-main.tsx");
        const featuredCarouselEntryPath = join(linkappDir, "dev-featured-carousel-main.tsx");
        writeFileSync(sheetEntryPath, generateSheetEntryPoint(devServerPath), "utf-8");
        // Only generate featured entry if the layout exists
        if (hasFeatured) {
            writeFileSync(featuredEntryPath, generateFeaturedEntryPoint(devServerPath, hasFeaturedCarousel), "utf-8");
        }
        // Only generate featured-carousel entry if the layout exists
        if (hasFeaturedCarousel) {
            writeFileSync(featuredCarouselEntryPath, generateFeaturedCarouselEntryPoint(devServerPath), "utf-8");
        }
        // Helper to load config (called on initial start and on config changes)
        const loadProjectConfig = () => {
            try {
                const config = loadConfig(userProjectPath);
                return {
                    previewProps: config.preview_props || {},
                    settingsConfig: config.settings || {},
                };
            }
            catch (error) {
                writeLine(pc.yellow('⚠ Warning: Could not load config, using default preview props'));
                writeLine(pc.dim(`  ${error instanceof Error ? error.message : error}`));
                return {
                    previewProps: {},
                    settingsConfig: {},
                };
            }
        };
        // Load config initially
        let { previewProps, settingsConfig } = loadProjectConfig();
        const requestedPort = options.port || 3000;
        const availablePort = await detect(requestedPort);
        // Show warning if the requested port was occupied
        if (requestedPort !== availablePort) {
            writeLine(pc.yellow(`  ⚠ Port ${requestedPort} is in use, using ${availablePort} instead`));
            writeLine();
        }
        const port = availablePort;
        const userPublicDir = join(userProjectPath, 'public');
        const printReadyMessage = (readyTime, urls) => {
            writeLine();
            writeLine(pc.bold(pc.cyan('  LinkApp')) + pc.dim(' ready'));
            writeLine();
            if (urls.length > 0) {
                writeLine(`  ${pc.green('➜')}  ${pc.bold('Local:')}   ${pc.cyan(urls[0])}`);
            }
            writeLine();
            writeLine(pc.green(`  ✓ Ready in ${readyTime}s`));
        };
        const setupKeyboardShortcuts = (handlers) => {
            if (!process.stdin.isTTY) {
                return () => { };
            }
            const handleData = (data) => {
                if (data === '\u0003') {
                    void handlers.exit();
                    return;
                }
                const key = data.trim().toLowerCase();
                if (key === '') {
                    return;
                }
                switch (key) {
                    case 'r':
                        void handlers.restart();
                        break;
                    case 'u':
                        handlers.showUrls();
                        break;
                    case 'c':
                        handlers.clear();
                        break;
                    case 'q':
                        void handlers.exit();
                        break;
                    default:
                        break;
                }
            };
            process.stdin.setRawMode(true);
            process.stdin.resume();
            process.stdin.setEncoding('utf8');
            process.stdin.on('data', handleData);
            return () => {
                process.stdin.off('data', handleData);
                if (process.stdin.isTTY) {
                    process.stdin.setRawMode(false);
                }
                process.stdin.pause();
            };
        };
        // Callback wrapper for config watcher (will be assigned after restartServer is defined)
        let restartCallback;
        // Helper to create Rsbuild instance with current config values
        const createRsbuildInstance = async () => {
            return await createRsbuild({
                rsbuildConfig: {
                    dev: {
                        progressBar: false,
                    },
                    plugins: [
                        pluginReact(),
                        createPublicDirPlugin(userPublicDir),
                        createConfigWatcherPlugin(userProjectPath, async () => {
                            await restartCallback?.();
                        }),
                    ],
                    source: {
                        entry: {
                            index: resolve(devServerPath, "preview/main.tsx"),
                            sheet: sheetEntryPath,
                            ...(hasFeatured ? { featured: featuredEntryPath } : {}),
                            ...(hasFeaturedCarousel
                                ? { "featured-carousel": featuredCarouselEntryPath }
                                : {}),
                        },
                        define: {
                            __PREVIEW_PROPS__: JSON.stringify(previewProps),
                            __SETTINGS_CONFIG__: JSON.stringify(settingsConfig),
                            __HAS_FEATURED__: JSON.stringify(hasFeatured),
                            __HAS_CAROUSEL__: JSON.stringify(hasFeaturedCarousel),
                        },
                    },
                    resolve: {
                        alias: {
                            '@': userProjectPath,
                        },
                        dedupe: ['react', 'react-dom'],
                    },
                    html: {
                        template({ entryName }) {
                            const templates = {
                                index: resolve(devServerPath, 'index.html'),
                                sheet: resolve(devServerPath, 'sheet.html'),
                                featured: resolve(devServerPath, 'featured.html'),
                                'featured-carousel': resolve(devServerPath, 'featured-carousel.html'),
                            };
                            return templates[entryName] || resolve(devServerPath, 'index.html');
                        },
                    },
                    server: {
                        port,
                        host: 'localhost',
                        open: false,
                        strictPort: false,
                        printUrls: false,
                        publicDir: {
                            name: userPublicDir,
                            watch: true,
                        },
                    },
                    tools: {
                        postcss: (opts) => {
                            // Load PostCSS config from dev-server directory
                            opts.postcssOptions = {
                                ...opts.postcssOptions,
                                config: resolve(devServerPath, 'postcss.config.mjs'),
                            };
                            return opts;
                        },
                        rspack: (config) => {
                            // Add linkapp package's node_modules to module resolution paths
                            // This allows dev-server files to import dependencies from @linktr.ee/linkapp
                            config.resolve = config.resolve || {};
                            config.resolve.modules = [
                                resolve(__dirname, '../../node_modules'),
                                'node_modules',
                            ];
                            return config;
                        },
                    },
                },
            });
        };
        // Create initial Rsbuild instance
        let rsbuild = await createRsbuildInstance();
        let currentServer;
        let cleanupShortcuts;
        let isRestarting = false;
        let isShuttingDown = false;
        let currentUrls = [];
        let lastReadyTime = '';
        const startServer = async (startedAt) => {
            const result = await rsbuild.startDevServer();
            currentServer = result;
            currentUrls = result.urls;
            lastReadyTime = ((Date.now() - startedAt) / 1000).toFixed(1);
            printReadyMessage(lastReadyTime, currentUrls);
        };
        const restartServer = async () => {
            if (isShuttingDown || isRestarting || !currentServer) {
                return;
            }
            isRestarting = true;
            writeLine(pc.cyan('  ↻ Restarting dev server...'));
            try {
                // Close current server
                await currentServer.server.close();
                // Reload config to get fresh preview props
                const freshConfig = loadProjectConfig();
                previewProps = freshConfig.previewProps;
                settingsConfig = freshConfig.settingsConfig;
                // Recreate Rsbuild instance with fresh config
                rsbuild = await createRsbuildInstance();
                // Start new server
                const restartStart = Date.now();
                await startServer(restartStart);
            }
            catch (error) {
                currentServer = undefined;
                writeLine(pc.red('✗ Failed to restart dev server'));
                writeLine(pc.dim(`  ${error instanceof Error ? error.message : error}`));
            }
            finally {
                isRestarting = false;
            }
        };
        const showUrls = () => {
            writeLine();
            if (currentUrls.length > 0) {
                writeLine(`  ${pc.green('➜')}  ${pc.bold('Local:')}   ${pc.cyan(currentUrls[0])}`);
            }
            writeLine();
        };
        const clearConsole = () => {
            console.clear();
            if (lastReadyTime) {
                printReadyMessage(lastReadyTime, currentUrls);
            }
        };
        const shutdown = async () => {
            if (isShuttingDown) {
                return;
            }
            isShuttingDown = true;
            cleanupShortcuts?.();
            try {
                if (currentServer) {
                    await currentServer.server.close();
                }
            }
            catch (closeError) {
                writeLine(pc.red('✗ Error while closing dev server'));
                writeLine(pc.dim(`  ${closeError instanceof Error ? closeError.message : closeError}`));
            }
            finally {
                process.exit(0);
            }
        };
        // Assign restart callback for config watcher
        restartCallback = restartServer;
        await startServer(startTime);
        cleanupShortcuts = setupKeyboardShortcuts({
            restart: restartServer,
            showUrls,
            clear: clearConsole,
            exit: shutdown,
        });
        process.on('SIGINT', () => {
            void shutdown();
        });
        // Keep alive
        await new Promise(() => { });
    }
    catch (error) {
        writeLine(pc.red('✗ Failed to start server'));
        console.error(pc.red('✗ Error:'), error);
        process.exit(1);
    }
}
//# sourceMappingURL=dev.js.map