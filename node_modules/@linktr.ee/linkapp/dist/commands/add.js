import { spawn } from "node:child_process";
import { existsSync } from "node:fs";
import { join } from "node:path";
import * as p from "@clack/prompts";
import pc from "picocolors";
// Constants
const DEFAULT_REGISTRY = process.env.LINKAPP_REGISTRY_URL ||
    "https://create-linkapp-registry.vercel.app/r";
const AVAILABLE_COMPONENTS = ["button", "container", "embed", "skeleton", "switch"];
// Utilities
const writeLine = (message = "") => {
    process.stdout.write(`${message}\n`);
};
const exitWithError = (message, hint) => {
    writeLine(pc.red(`âœ— ${message}`));
    if (hint) {
        writeLine(pc.dim(hint));
    }
    process.exit(1);
};
// Main command
export async function addCommand(component, options = {}) {
    writeLine(pc.cyan("ðŸ“¦ Adding components from LinkApp registry..."));
    writeLine();
    try {
        // Validate inputs first (fail fast)
        validateComponent(component);
        validateProjectStructure();
        // Resolve component URL
        const registryUrl = options.registry || DEFAULT_REGISTRY;
        const componentUrl = resolveComponentUrl(component, registryUrl);
        // Install component
        await installComponent(component, componentUrl, options);
        // Show success message
        showSuccessMessage(component);
    }
    catch (error) {
        writeLine();
        writeLine(pc.red("âœ— Failed to add component:"));
        writeLine(pc.dim(`  ${error instanceof Error ? error.message : error}`));
        process.exit(1);
    }
}
// Validation functions
function validateComponent(component) {
    if (!component) {
        writeLine(pc.red("âœ— Please specify a component name"));
        writeLine();
        writeLine(pc.dim("Available components:"));
        for (const comp of AVAILABLE_COMPONENTS) {
            writeLine(pc.dim(`  â€¢ ${comp}`));
        }
        writeLine();
        writeLine(pc.dim("Example: linkapp add button"));
        process.exit(1);
    }
}
function validateProjectStructure() {
    const componentsJsonPath = join(process.cwd(), "components.json");
    if (!existsSync(componentsJsonPath)) {
        exitWithError("components.json not found", "Please run this command from a LinkApp project root");
    }
}
// Helper functions
function resolveComponentUrl(component, registryUrl) {
    // Check if it's a full URL or just a component name
    if (component.startsWith("http://") || component.startsWith("https://")) {
        return component;
    }
    return `${registryUrl}/${component}.json`;
}
async function installComponent(component, componentUrl, options) {
    writeLine(pc.dim(`Installing from: ${componentUrl}`));
    writeLine();
    // Build shadcn CLI arguments
    const args = ["add", componentUrl];
    if (options.yes)
        args.push("--yes");
    if (options.overwrite)
        args.push("--overwrite");
    // Run installation
    const s = p.spinner();
    s.start(`Installing ${component}`);
    await runShadcnCommand(args);
    s.stop(pc.green(`âœ“ Successfully installed ${component}`));
}
function showSuccessMessage(component) {
    writeLine();
    writeLine(pc.dim("You can now import and use the component:"));
    writeLine(pc.dim(`  import { ${capitalize(component)} } from '@/components/ui/${component}'`));
    writeLine();
}
async function runShadcnCommand(args) {
    return new Promise((resolve, reject) => {
        const child = spawn("npx", ["shadcn@latest", ...args], {
            cwd: process.cwd(),
            stdio: "inherit",
            shell: true,
        });
        child.on("close", (code) => {
            if (code === 0) {
                resolve();
            }
            else {
                reject(new Error(`shadcn command failed with code ${code}`));
            }
        });
        child.on("error", (error) => {
            reject(error);
        });
    });
}
function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
//# sourceMappingURL=add.js.map