import pc from 'picocolors';
import * as p from '@clack/prompts';
import open from 'open';
import { getAppConfig } from '../lib/auth/config.js';
import { initiateDeviceFlow, pollAccessToken } from '../lib/auth/device-flow.js';
import { saveToken, isTokenValid } from '../lib/auth/token-storage.js';
const writeLine = (message = '') => {
    process.stdout.write(`${message}\n`);
};
export async function loginCommand(options) {
    const env = options.qa ? 'QA' : 'Production';
    writeLine(pc.cyan(`üîê Logging in to ${env}...`));
    writeLine();
    try {
        const config = await getAppConfig(options.qa ? 'qa' : 'production');
        // Check if already logged in
        if (isTokenValid(config.auth.audience)) {
            const shouldReauth = await p.confirm({
                message: 'Already logged in. Re-authenticate?',
                initialValue: false,
            });
            if (p.isCancel(shouldReauth) || !shouldReauth) {
                writeLine();
                writeLine(pc.dim('Login cancelled'));
                return;
            }
        }
        const s = p.spinner();
        // Initiate device flow
        s.start('Initiating device authorization');
        const handle = await initiateDeviceFlow(config.auth);
        s.stop('Device authorization initiated');
        const { expires_in, user_code, verification_uri_complete } = handle;
        const expiryMinutes = Math.floor(expires_in / 60);
        writeLine();
        writeLine(`${pc.green('‚úì Authorization code:')} ${pc.bold(user_code)}`);
        writeLine(pc.dim(`  ${verification_uri_complete}`));
        writeLine(pc.dim(`  Expires in ${expiryMinutes} minutes`));
        writeLine();
        // Open browser
        await open(verification_uri_complete);
        writeLine(pc.cyan('üåê Browser opened for authentication'));
        writeLine(pc.dim('  If browser did not open, visit the link above'));
        writeLine();
        // Poll for token
        s.start('Waiting for authorization');
        const token = await pollAccessToken(handle);
        s.stop('Authorization successful');
        // Calculate expiry time
        const expiresAt = token.expires_at ?? (token.expires_in ? Math.floor(Date.now() / 1000) + token.expires_in : undefined);
        // Save token (this will validate token structure and permissions)
        try {
            if (!token.access_token) {
                throw new Error('No access token received');
            }
            saveToken(token.access_token, config.auth.audience, expiresAt);
        }
        catch (validationError) {
            // Token validation failed - provide specific error message
            s.stop('Authorization completed but validation failed');
            if (validationError instanceof Error) {
                console.error(pc.red('\n‚úó Token validation failed:'), validationError.message);
            }
            else {
                console.error(pc.red('\n‚úó Token validation failed:'), validationError);
            }
            process.exit(1);
        }
        writeLine();
        writeLine(pc.green('‚úì Login successful!'));
        if (expiresAt) {
            const expiryDate = new Date(expiresAt * 1000).toLocaleString();
            writeLine(pc.dim(`  Token expires: ${expiryDate}`));
            writeLine();
        }
    }
    catch (error) {
        if (error instanceof Error) {
            console.error(pc.red('\n‚úó Login failed:'), error.message);
        }
        else {
            console.error(pc.red('\n‚úó Login failed:'), error);
        }
        process.exit(1);
    }
}
//# sourceMappingURL=login.js.map