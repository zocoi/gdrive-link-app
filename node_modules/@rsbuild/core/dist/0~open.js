let isDockerCached, cachedResult, mountPoint, defaultMountPoint;
import { __webpack_require__ } from "./rslib-runtime.js";
import { Buffer } from "node:buffer";
import node_child_process, { execFile } from "node:child_process";
import promises, { constants } from "node:fs/promises";
import { node_fs, node_process, node_os, external_node_util_promisify } from "./58.js";
function hasDockerEnv() {
    try {
        return node_fs.statSync('/.dockerenv'), !0;
    } catch  {
        return !1;
    }
}
function hasDockerCGroup() {
    try {
        return node_fs.readFileSync('/proc/self/cgroup', 'utf8').includes('docker');
    } catch  {
        return !1;
    }
}
function isDocker() {
    return void 0 === isDockerCached && (isDockerCached = hasDockerEnv() || hasDockerCGroup()), isDockerCached;
}
function isInsideContainer() {
    return void 0 === cachedResult && (cachedResult = (()=>{
        try {
            return node_fs.statSync('/run/.containerenv'), !0;
        } catch  {
            return !1;
        }
    })() || isDocker()), cachedResult;
}
let isWsl = ()=>{
    if ('linux' !== node_process.platform) return !1;
    if (node_os.release().toLowerCase().includes('microsoft')) return !isInsideContainer();
    try {
        return !!node_fs.readFileSync('/proc/version', 'utf8').toLowerCase().includes('microsoft') && !isInsideContainer();
    } catch  {
        return !1;
    }
}, is_wsl = node_process.env.__IS_WSL_TEST__ ? isWsl : isWsl(), wslDrivesMountPoint = (defaultMountPoint = '/mnt/', async function() {
    if (mountPoint) return mountPoint;
    let configFilePath = '/etc/wsl.conf', isConfigFileExists = !1;
    try {
        await promises.access(configFilePath, constants.F_OK), isConfigFileExists = !0;
    } catch  {}
    if (!isConfigFileExists) return defaultMountPoint;
    let configContent = await promises.readFile(configFilePath, {
        encoding: 'utf8'
    }), configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
    return configMountPoint ? mountPoint = (mountPoint = configMountPoint.groups.mountPoint.trim()).endsWith('/') ? mountPoint : `${mountPoint}/` : defaultMountPoint;
}), powerShellPathFromWsl = async ()=>{
    let mountPoint = await wslDrivesMountPoint();
    return `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe`;
}, powerShellPath = async ()=>is_wsl ? powerShellPathFromWsl() : `${node_process.env.SYSTEMROOT || node_process.env.windir || String.raw`C:\Windows`}\\System32\\WindowsPowerShell\\v1.0\\powershell.exe`;
function defineLazyProperty(object, propertyName, valueGetter) {
    let define = (value)=>Object.defineProperty(object, propertyName, {
            value,
            enumerable: !0,
            writable: !0
        });
    return Object.defineProperty(object, propertyName, {
        configurable: !0,
        enumerable: !0,
        get () {
            let result = valueGetter();
            return define(result), result;
        },
        set (value) {
            define(value);
        }
    }), object;
}
let execFileAsync = external_node_util_promisify(execFile);
async function defaultBrowserId() {
    if ('darwin' !== node_process.platform) throw Error('macOS only');
    let { stdout } = await execFileAsync('defaults', [
        'read',
        'com.apple.LaunchServices/com.apple.launchservices.secure',
        'LSHandlers'
    ]), match = /LSHandlerRoleAll = "(?!-)(?<id>[^"]+?)";\s+?LSHandlerURLScheme = (?:http|https);/.exec(stdout);
    return match?.groups.id ?? 'com.apple.Safari';
}
let run_applescript_execFileAsync = external_node_util_promisify(execFile);
async function runAppleScript(script, { humanReadableOutput = !0, signal } = {}) {
    if ('darwin' !== node_process.platform) throw Error('macOS only');
    let execOptions = {};
    signal && (execOptions.signal = signal);
    let { stdout } = await run_applescript_execFileAsync("osascript", [
        '-e',
        script,
        humanReadableOutput ? [] : [
            '-ss'
        ]
    ], execOptions);
    return stdout.trim();
}
async function bundleName(bundleId) {
    return runAppleScript(`tell application "Finder" to set app_path to application file id "${bundleId}" as string\ntell application "System Events" to get value of property list item "CFBundleName" of property list file (app_path & ":Contents:Info.plist")`);
}
let windows_execFileAsync = external_node_util_promisify(execFile), windowsBrowserProgIds = {
    AppXq0fevzme2pys62n3e0fbqa7peapykr8v: {
        name: 'Edge',
        id: 'com.microsoft.edge.old'
    },
    MSEdgeDHTML: {
        name: 'Edge',
        id: 'com.microsoft.edge'
    },
    MSEdgeHTM: {
        name: 'Edge',
        id: 'com.microsoft.edge'
    },
    'IE.HTTP': {
        name: 'Internet Explorer',
        id: 'com.microsoft.ie'
    },
    FirefoxURL: {
        name: 'Firefox',
        id: 'org.mozilla.firefox'
    },
    ChromeHTML: {
        name: 'Chrome',
        id: 'com.google.chrome'
    },
    BraveHTML: {
        name: 'Brave',
        id: 'com.brave.Browser'
    },
    BraveBHTML: {
        name: 'Brave Beta',
        id: 'com.brave.Browser.beta'
    },
    BraveSSHTM: {
        name: 'Brave Nightly',
        id: 'com.brave.Browser.nightly'
    }
};
class UnknownBrowserError extends Error {
}
async function defaultBrowser(_execFileAsync = windows_execFileAsync) {
    let { stdout } = await _execFileAsync('reg', [
        'QUERY',
        ' HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice',
        '/v',
        'ProgId'
    ]), match = /ProgId\s*REG_SZ\s*(?<id>\S+)/.exec(stdout);
    if (!match) throw new UnknownBrowserError(`Cannot find Windows browser in stdout: ${JSON.stringify(stdout)}`);
    let { id } = match.groups, browser = windowsBrowserProgIds[id];
    if (!browser) throw new UnknownBrowserError(`Unknown browser ID: ${id}`);
    return browser;
}
let default_browser_execFileAsync = external_node_util_promisify(execFile);
async function default_browser_defaultBrowser() {
    if ('darwin' === node_process.platform) {
        let id = await defaultBrowserId();
        return {
            name: await bundleName(id),
            id
        };
    }
    if ('linux' === node_process.platform) {
        let { stdout } = await default_browser_execFileAsync('xdg-mime', [
            'query',
            'default',
            'x-scheme-handler/http'
        ]), id = stdout.trim();
        return {
            name: id.replace(/.desktop$/, '').replace('-', ' ').toLowerCase().replaceAll(/(?:^|\s|-)\S/g, (x)=>x.toUpperCase()),
            id
        };
    }
    if ('win32' === node_process.platform) return defaultBrowser();
    throw Error('Only macOS, Linux, and Windows are supported');
}
let external_node_path_ = __webpack_require__("node:path"), external_node_url_ = __webpack_require__("node:url"), open_execFile = external_node_util_promisify(node_child_process.execFile), open_dirname = external_node_path_.default.dirname((0, external_node_url_.fileURLToPath)(import.meta.url)), localXdgOpenPath = external_node_path_.default.join(open_dirname, 'xdg-open'), { platform: platform, arch: arch } = node_process;
async function getWindowsDefaultBrowserFromWsl() {
    let powershellPath = await powerShellPath(), rawCommand = String.raw`(Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice").ProgId`, encodedCommand = Buffer.from(rawCommand, 'utf16le').toString('base64'), { stdout } = await open_execFile(powershellPath, [
        '-NoProfile',
        '-NonInteractive',
        '-ExecutionPolicy',
        'Bypass',
        '-EncodedCommand',
        encodedCommand
    ], {
        encoding: 'utf8'
    }), progId = stdout.trim(), browserMap = {
        ChromeHTML: 'com.google.chrome',
        BraveHTML: 'com.brave.Browser',
        MSEdgeHTM: 'com.microsoft.edge',
        FirefoxURL: 'org.mozilla.firefox'
    };
    return browserMap[progId] ? {
        id: browserMap[progId]
    } : {};
}
let pTryEach = async (array, mapper)=>{
    let latestError;
    for (let item of array)try {
        return await mapper(item);
    } catch (error) {
        latestError = error;
    }
    throw latestError;
}, baseOpen = async (options)=>{
    let command;
    if (Array.isArray((options = {
        wait: !1,
        background: !1,
        newInstance: !1,
        allowNonzeroExitCode: !1,
        ...options
    }).app)) return pTryEach(options.app, (singleApp)=>baseOpen({
            ...options,
            app: singleApp
        }));
    let { name: app, arguments: appArguments = [] } = options.app ?? {};
    if (appArguments = [
        ...appArguments
    ], Array.isArray(app)) return pTryEach(app, (appName)=>baseOpen({
            ...options,
            app: {
                name: appName,
                arguments: appArguments
            }
        }));
    if ('browser' === app || 'browserPrivate' === app) {
        let ids = {
            'com.google.chrome': 'chrome',
            'google-chrome.desktop': 'chrome',
            'com.brave.Browser': 'brave',
            'org.mozilla.firefox': 'firefox',
            'firefox.desktop': 'firefox',
            'com.microsoft.msedge': 'edge',
            'com.microsoft.edge': 'edge',
            'com.microsoft.edgemac': 'edge',
            'microsoft-edge.desktop': 'edge'
        }, browser = is_wsl ? await getWindowsDefaultBrowserFromWsl() : await default_browser_defaultBrowser();
        if (browser.id in ids) {
            let browserName = ids[browser.id];
            return 'browserPrivate' === app && appArguments.push({
                chrome: '--incognito',
                brave: '--incognito',
                firefox: '--private-window',
                edge: '--inPrivate'
            }[browserName]), baseOpen({
                ...options,
                app: {
                    name: apps[browserName],
                    arguments: appArguments
                }
            });
        }
        throw Error(`${browser.name} is not supported as a default browser`);
    }
    let cliArguments = [], childProcessOptions = {};
    if ('darwin' === platform) command = 'open', options.wait && cliArguments.push('--wait-apps'), options.background && cliArguments.push('--background'), options.newInstance && cliArguments.push('--new'), app && cliArguments.push('-a', app);
    else if ('win32' !== platform && (!is_wsl || isInsideContainer() || app)) {
        if (app) command = app;
        else {
            let exeLocalXdgOpen = !1;
            try {
                await promises.access(localXdgOpenPath, constants.X_OK), exeLocalXdgOpen = !0;
            } catch  {}
            command = node_process.versions.electron ?? ('android' === platform || !open_dirname || '/' === open_dirname || !exeLocalXdgOpen) ? 'xdg-open' : localXdgOpenPath;
        }
        appArguments.length > 0 && cliArguments.push(...appArguments), options.wait || (childProcessOptions.stdio = 'ignore', childProcessOptions.detached = !0);
    } else {
        command = await powerShellPath(), cliArguments.push('-NoProfile', '-NonInteractive', '-ExecutionPolicy', 'Bypass', '-EncodedCommand'), is_wsl || (childProcessOptions.windowsVerbatimArguments = !0);
        let encodedArguments = [
            'Start'
        ];
        options.wait && encodedArguments.push('-Wait'), app ? (encodedArguments.push(`"\`"${app}\`""`), options.target && appArguments.push(options.target)) : options.target && encodedArguments.push(`"${options.target}"`), appArguments.length > 0 && encodedArguments.push('-ArgumentList', (appArguments = appArguments.map((argument)=>`"\`"${argument}\`""`)).join(',')), options.target = Buffer.from(encodedArguments.join(' '), 'utf16le').toString('base64');
    }
    'darwin' === platform && appArguments.length > 0 && cliArguments.push('--args', ...appArguments), options.target && cliArguments.push(options.target);
    let subprocess = node_child_process.spawn(command, cliArguments, childProcessOptions);
    return options.wait ? new Promise((resolve, reject)=>{
        subprocess.once('error', reject), subprocess.once('close', (exitCode)=>{
            !options.allowNonzeroExitCode && exitCode > 0 ? reject(Error(`Exited with code ${exitCode}`)) : resolve(subprocess);
        });
    }) : (subprocess.unref(), subprocess);
};
function detectArchBinary(binary) {
    if ('string' == typeof binary || Array.isArray(binary)) return binary;
    let { [arch]: archBinary } = binary;
    if (!archBinary) throw Error(`${arch} is not supported`);
    return archBinary;
}
function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
    if (wsl && is_wsl) return detectArchBinary(wsl);
    if (!platformBinary) throw Error(`${platform} is not supported`);
    return detectArchBinary(platformBinary);
}
let apps = {};
defineLazyProperty(apps, 'chrome', ()=>detectPlatformBinary({
        darwin: 'google chrome',
        win32: 'chrome',
        linux: [
            'google-chrome',
            'google-chrome-stable',
            'chromium'
        ]
    }, {
        wsl: {
            ia32: '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe',
            x64: [
                '/mnt/c/Program Files/Google/Chrome/Application/chrome.exe',
                '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe'
            ]
        }
    })), defineLazyProperty(apps, 'brave', ()=>detectPlatformBinary({
        darwin: 'brave browser',
        win32: 'brave',
        linux: [
            'brave-browser',
            'brave'
        ]
    }, {
        wsl: {
            ia32: '/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe',
            x64: [
                '/mnt/c/Program Files/BraveSoftware/Brave-Browser/Application/brave.exe',
                '/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe'
            ]
        }
    })), defineLazyProperty(apps, 'firefox', ()=>detectPlatformBinary({
        darwin: 'firefox',
        win32: String.raw`C:\Program Files\Mozilla Firefox\firefox.exe`,
        linux: 'firefox'
    }, {
        wsl: '/mnt/c/Program Files/Mozilla Firefox/firefox.exe'
    })), defineLazyProperty(apps, 'edge', ()=>detectPlatformBinary({
        darwin: 'microsoft edge',
        win32: 'msedge',
        linux: [
            'microsoft-edge',
            'microsoft-edge-dev'
        ]
    }, {
        wsl: '/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe'
    })), defineLazyProperty(apps, 'browser', ()=>'browser'), defineLazyProperty(apps, 'browserPrivate', ()=>'browserPrivate');
let node_modules_open = (target, options)=>{
    if ('string' != typeof target) throw TypeError('Expected a `target`');
    return baseOpen({
        ...options,
        target
    });
};
export { apps, node_modules_open };
