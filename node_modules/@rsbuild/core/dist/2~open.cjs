"use strict";
const __rslib_import_meta_url__ = 'undefined' == typeof document ? new (require('url'.replace('', ''))).URL('file:' + __filename).href : document.currentScript && document.currentScript.src || new URL('main.js', document.baseURI).href;
exports.ids = [
    "664"
], exports.modules = {
    "../../node_modules/.pnpm/open@10.2.0/node_modules/open/index.js": function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
        let isDockerCached, cachedResult, mountPoint, defaultMountPoint;
        __webpack_require__.d(__webpack_exports__, {
            default: ()=>node_modules_open,
            apps: ()=>apps
        });
        var external_node_process_ = __webpack_require__("node:process"), external_node_buffer_ = __webpack_require__("node:buffer"), external_node_path_ = __webpack_require__("node:path"), external_node_url_ = __webpack_require__("node:url"), external_node_util_ = __webpack_require__("node:util"), external_node_child_process_ = __webpack_require__("node:child_process"), promises_ = __webpack_require__("node:fs/promises"), external_node_os_ = __webpack_require__("node:os"), external_node_fs_ = __webpack_require__("node:fs");
        function hasDockerEnv() {
            try {
                return external_node_fs_.statSync('/.dockerenv'), !0;
            } catch  {
                return !1;
            }
        }
        function hasDockerCGroup() {
            try {
                return external_node_fs_.readFileSync('/proc/self/cgroup', 'utf8').includes('docker');
            } catch  {
                return !1;
            }
        }
        function isDocker() {
            return void 0 === isDockerCached && (isDockerCached = hasDockerEnv() || hasDockerCGroup()), isDockerCached;
        }
        function isInsideContainer() {
            return void 0 === cachedResult && (cachedResult = (()=>{
                try {
                    return external_node_fs_.statSync('/run/.containerenv'), !0;
                } catch  {
                    return !1;
                }
            })() || isDocker()), cachedResult;
        }
        let isWsl = ()=>{
            if ('linux' !== external_node_process_.platform) return !1;
            if (external_node_os_.release().toLowerCase().includes('microsoft')) return !isInsideContainer();
            try {
                return !!external_node_fs_.readFileSync('/proc/version', 'utf8').toLowerCase().includes('microsoft') && !isInsideContainer();
            } catch  {
                return !1;
            }
        }, is_wsl = external_node_process_.env.__IS_WSL_TEST__ ? isWsl : isWsl(), wslDrivesMountPoint = (defaultMountPoint = '/mnt/', async function() {
            if (mountPoint) return mountPoint;
            let configFilePath = '/etc/wsl.conf', isConfigFileExists = !1;
            try {
                await promises_.access(configFilePath, promises_.constants.F_OK), isConfigFileExists = !0;
            } catch  {}
            if (!isConfigFileExists) return defaultMountPoint;
            let configContent = await promises_.readFile(configFilePath, {
                encoding: 'utf8'
            }), configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
            return configMountPoint ? mountPoint = (mountPoint = configMountPoint.groups.mountPoint.trim()).endsWith('/') ? mountPoint : `${mountPoint}/` : defaultMountPoint;
        }), powerShellPathFromWsl = async ()=>{
            let mountPoint = await wslDrivesMountPoint();
            return `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe`;
        }, powerShellPath = async ()=>is_wsl ? powerShellPathFromWsl() : `${external_node_process_.env.SYSTEMROOT || external_node_process_.env.windir || String.raw`C:\Windows`}\\System32\\WindowsPowerShell\\v1.0\\powershell.exe`;
        function defineLazyProperty(object, propertyName, valueGetter) {
            let define = (value)=>Object.defineProperty(object, propertyName, {
                    value,
                    enumerable: !0,
                    writable: !0
                });
            return Object.defineProperty(object, propertyName, {
                configurable: !0,
                enumerable: !0,
                get () {
                    let result = valueGetter();
                    return define(result), result;
                },
                set (value) {
                    define(value);
                }
            }), object;
        }
        let execFileAsync = (0, external_node_util_.promisify)(external_node_child_process_.execFile);
        async function defaultBrowserId() {
            if ('darwin' !== external_node_process_.platform) throw Error('macOS only');
            let { stdout } = await execFileAsync('defaults', [
                'read',
                'com.apple.LaunchServices/com.apple.launchservices.secure',
                'LSHandlers'
            ]), match = /LSHandlerRoleAll = "(?!-)(?<id>[^"]+?)";\s+?LSHandlerURLScheme = (?:http|https);/.exec(stdout);
            return match?.groups.id ?? 'com.apple.Safari';
        }
        let run_applescript_execFileAsync = (0, external_node_util_.promisify)(external_node_child_process_.execFile);
        async function runAppleScript(script, { humanReadableOutput = !0, signal } = {}) {
            if ('darwin' !== external_node_process_.platform) throw Error('macOS only');
            let execOptions = {};
            signal && (execOptions.signal = signal);
            let { stdout } = await run_applescript_execFileAsync("osascript", [
                '-e',
                script,
                humanReadableOutput ? [] : [
                    '-ss'
                ]
            ], execOptions);
            return stdout.trim();
        }
        async function bundleName(bundleId) {
            return runAppleScript(`tell application "Finder" to set app_path to application file id "${bundleId}" as string\ntell application "System Events" to get value of property list item "CFBundleName" of property list file (app_path & ":Contents:Info.plist")`);
        }
        let windows_execFileAsync = (0, external_node_util_.promisify)(external_node_child_process_.execFile), windowsBrowserProgIds = {
            AppXq0fevzme2pys62n3e0fbqa7peapykr8v: {
                name: 'Edge',
                id: 'com.microsoft.edge.old'
            },
            MSEdgeDHTML: {
                name: 'Edge',
                id: 'com.microsoft.edge'
            },
            MSEdgeHTM: {
                name: 'Edge',
                id: 'com.microsoft.edge'
            },
            'IE.HTTP': {
                name: 'Internet Explorer',
                id: 'com.microsoft.ie'
            },
            FirefoxURL: {
                name: 'Firefox',
                id: 'org.mozilla.firefox'
            },
            ChromeHTML: {
                name: 'Chrome',
                id: 'com.google.chrome'
            },
            BraveHTML: {
                name: 'Brave',
                id: 'com.brave.Browser'
            },
            BraveBHTML: {
                name: 'Brave Beta',
                id: 'com.brave.Browser.beta'
            },
            BraveSSHTM: {
                name: 'Brave Nightly',
                id: 'com.brave.Browser.nightly'
            }
        };
        class UnknownBrowserError extends Error {
        }
        async function defaultBrowser(_execFileAsync = windows_execFileAsync) {
            let { stdout } = await _execFileAsync('reg', [
                'QUERY',
                ' HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations\\http\\UserChoice',
                '/v',
                'ProgId'
            ]), match = /ProgId\s*REG_SZ\s*(?<id>\S+)/.exec(stdout);
            if (!match) throw new UnknownBrowserError(`Cannot find Windows browser in stdout: ${JSON.stringify(stdout)}`);
            let { id } = match.groups, browser = windowsBrowserProgIds[id];
            if (!browser) throw new UnknownBrowserError(`Unknown browser ID: ${id}`);
            return browser;
        }
        let default_browser_execFileAsync = (0, external_node_util_.promisify)(external_node_child_process_.execFile);
        async function default_browser_defaultBrowser() {
            if ('darwin' === external_node_process_.platform) {
                let id = await defaultBrowserId();
                return {
                    name: await bundleName(id),
                    id
                };
            }
            if ('linux' === external_node_process_.platform) {
                let { stdout } = await default_browser_execFileAsync('xdg-mime', [
                    'query',
                    'default',
                    'x-scheme-handler/http'
                ]), id = stdout.trim();
                return {
                    name: id.replace(/.desktop$/, '').replace('-', ' ').toLowerCase().replaceAll(/(?:^|\s|-)\S/g, (x)=>x.toUpperCase()),
                    id
                };
            }
            if ('win32' === external_node_process_.platform) return defaultBrowser();
            throw Error('Only macOS, Linux, and Windows are supported');
        }
        let execFile = (0, external_node_util_.promisify)(external_node_child_process_.execFile), open_dirname = external_node_path_.dirname((0, external_node_url_.fileURLToPath)(__rslib_import_meta_url__)), localXdgOpenPath = external_node_path_.join(open_dirname, 'xdg-open'), { platform, arch } = external_node_process_;
        async function getWindowsDefaultBrowserFromWsl() {
            let powershellPath = await powerShellPath(), rawCommand = String.raw`(Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\Shell\Associations\UrlAssociations\http\UserChoice").ProgId`, encodedCommand = external_node_buffer_.Buffer.from(rawCommand, 'utf16le').toString('base64'), { stdout } = await execFile(powershellPath, [
                '-NoProfile',
                '-NonInteractive',
                '-ExecutionPolicy',
                'Bypass',
                '-EncodedCommand',
                encodedCommand
            ], {
                encoding: 'utf8'
            }), progId = stdout.trim(), browserMap = {
                ChromeHTML: 'com.google.chrome',
                BraveHTML: 'com.brave.Browser',
                MSEdgeHTM: 'com.microsoft.edge',
                FirefoxURL: 'org.mozilla.firefox'
            };
            return browserMap[progId] ? {
                id: browserMap[progId]
            } : {};
        }
        let pTryEach = async (array, mapper)=>{
            let latestError;
            for (let item of array)try {
                return await mapper(item);
            } catch (error) {
                latestError = error;
            }
            throw latestError;
        }, baseOpen = async (options)=>{
            let command;
            if (Array.isArray((options = {
                wait: !1,
                background: !1,
                newInstance: !1,
                allowNonzeroExitCode: !1,
                ...options
            }).app)) return pTryEach(options.app, (singleApp)=>baseOpen({
                    ...options,
                    app: singleApp
                }));
            let { name: app, arguments: appArguments = [] } = options.app ?? {};
            if (appArguments = [
                ...appArguments
            ], Array.isArray(app)) return pTryEach(app, (appName)=>baseOpen({
                    ...options,
                    app: {
                        name: appName,
                        arguments: appArguments
                    }
                }));
            if ('browser' === app || 'browserPrivate' === app) {
                let ids = {
                    'com.google.chrome': 'chrome',
                    'google-chrome.desktop': 'chrome',
                    'com.brave.Browser': 'brave',
                    'org.mozilla.firefox': 'firefox',
                    'firefox.desktop': 'firefox',
                    'com.microsoft.msedge': 'edge',
                    'com.microsoft.edge': 'edge',
                    'com.microsoft.edgemac': 'edge',
                    'microsoft-edge.desktop': 'edge'
                }, browser = is_wsl ? await getWindowsDefaultBrowserFromWsl() : await default_browser_defaultBrowser();
                if (browser.id in ids) {
                    let browserName = ids[browser.id];
                    return 'browserPrivate' === app && appArguments.push({
                        chrome: '--incognito',
                        brave: '--incognito',
                        firefox: '--private-window',
                        edge: '--inPrivate'
                    }[browserName]), baseOpen({
                        ...options,
                        app: {
                            name: apps[browserName],
                            arguments: appArguments
                        }
                    });
                }
                throw Error(`${browser.name} is not supported as a default browser`);
            }
            let cliArguments = [], childProcessOptions = {};
            if ('darwin' === platform) command = 'open', options.wait && cliArguments.push('--wait-apps'), options.background && cliArguments.push('--background'), options.newInstance && cliArguments.push('--new'), app && cliArguments.push('-a', app);
            else if ('win32' !== platform && (!is_wsl || isInsideContainer() || app)) {
                if (app) command = app;
                else {
                    let exeLocalXdgOpen = !1;
                    try {
                        await promises_.access(localXdgOpenPath, promises_.constants.X_OK), exeLocalXdgOpen = !0;
                    } catch  {}
                    command = external_node_process_.versions.electron ?? ('android' === platform || !open_dirname || '/' === open_dirname || !exeLocalXdgOpen) ? 'xdg-open' : localXdgOpenPath;
                }
                appArguments.length > 0 && cliArguments.push(...appArguments), options.wait || (childProcessOptions.stdio = 'ignore', childProcessOptions.detached = !0);
            } else {
                command = await powerShellPath(), cliArguments.push('-NoProfile', '-NonInteractive', '-ExecutionPolicy', 'Bypass', '-EncodedCommand'), is_wsl || (childProcessOptions.windowsVerbatimArguments = !0);
                let encodedArguments = [
                    'Start'
                ];
                options.wait && encodedArguments.push('-Wait'), app ? (encodedArguments.push(`"\`"${app}\`""`), options.target && appArguments.push(options.target)) : options.target && encodedArguments.push(`"${options.target}"`), appArguments.length > 0 && encodedArguments.push('-ArgumentList', (appArguments = appArguments.map((argument)=>`"\`"${argument}\`""`)).join(',')), options.target = external_node_buffer_.Buffer.from(encodedArguments.join(' '), 'utf16le').toString('base64');
            }
            'darwin' === platform && appArguments.length > 0 && cliArguments.push('--args', ...appArguments), options.target && cliArguments.push(options.target);
            let subprocess = external_node_child_process_.spawn(command, cliArguments, childProcessOptions);
            return options.wait ? new Promise((resolve, reject)=>{
                subprocess.once('error', reject), subprocess.once('close', (exitCode)=>{
                    !options.allowNonzeroExitCode && exitCode > 0 ? reject(Error(`Exited with code ${exitCode}`)) : resolve(subprocess);
                });
            }) : (subprocess.unref(), subprocess);
        };
        function detectArchBinary(binary) {
            if ('string' == typeof binary || Array.isArray(binary)) return binary;
            let { [arch]: archBinary } = binary;
            if (!archBinary) throw Error(`${arch} is not supported`);
            return archBinary;
        }
        function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
            if (wsl && is_wsl) return detectArchBinary(wsl);
            if (!platformBinary) throw Error(`${platform} is not supported`);
            return detectArchBinary(platformBinary);
        }
        let apps = {};
        defineLazyProperty(apps, 'chrome', ()=>detectPlatformBinary({
                darwin: 'google chrome',
                win32: 'chrome',
                linux: [
                    'google-chrome',
                    'google-chrome-stable',
                    'chromium'
                ]
            }, {
                wsl: {
                    ia32: '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe',
                    x64: [
                        '/mnt/c/Program Files/Google/Chrome/Application/chrome.exe',
                        '/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe'
                    ]
                }
            })), defineLazyProperty(apps, 'brave', ()=>detectPlatformBinary({
                darwin: 'brave browser',
                win32: 'brave',
                linux: [
                    'brave-browser',
                    'brave'
                ]
            }, {
                wsl: {
                    ia32: '/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe',
                    x64: [
                        '/mnt/c/Program Files/BraveSoftware/Brave-Browser/Application/brave.exe',
                        '/mnt/c/Program Files (x86)/BraveSoftware/Brave-Browser/Application/brave.exe'
                    ]
                }
            })), defineLazyProperty(apps, 'firefox', ()=>detectPlatformBinary({
                darwin: 'firefox',
                win32: String.raw`C:\Program Files\Mozilla Firefox\firefox.exe`,
                linux: 'firefox'
            }, {
                wsl: '/mnt/c/Program Files/Mozilla Firefox/firefox.exe'
            })), defineLazyProperty(apps, 'edge', ()=>detectPlatformBinary({
                darwin: 'microsoft edge',
                win32: 'msedge',
                linux: [
                    'microsoft-edge',
                    'microsoft-edge-dev'
                ]
            }, {
                wsl: '/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe'
            })), defineLazyProperty(apps, 'browser', ()=>'browser'), defineLazyProperty(apps, 'browserPrivate', ()=>'browserPrivate');
        let node_modules_open = (target, options)=>{
            if ('string' != typeof target) throw TypeError('Expected a `target`');
            return baseOpen({
                ...options,
                target
            });
        };
    }
};
