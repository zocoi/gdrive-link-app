/*! For license information please see index.cjs.LICENSE.txt */
const __rslib_import_meta_url__ = 'undefined' == typeof document ? new (require('url'.replace('', ''))).URL('file:' + __filename).href : document.currentScript && document.currentScript.src || new URL('main.js', document.baseURI).href;
var __webpack_modules__ = {
    "../../node_modules/.pnpm/clone-deep@4.0.1/node_modules/clone-deep/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        let clone = __webpack_require__("../../node_modules/.pnpm/shallow-clone@3.0.1/node_modules/shallow-clone/index.js"), typeOf = __webpack_require__("../../node_modules/.pnpm/kind-of@6.0.3/node_modules/kind-of/index.js"), isPlainObject = __webpack_require__("../../node_modules/.pnpm/is-plain-object@2.0.4/node_modules/is-plain-object/index.js");
        function cloneDeep(val, instanceClone) {
            switch(typeOf(val)){
                case 'object':
                    return cloneObjectDeep(val, instanceClone);
                case 'array':
                    return cloneArrayDeep(val, instanceClone);
                default:
                    return clone(val);
            }
        }
        function cloneObjectDeep(val, instanceClone) {
            if ('function' == typeof instanceClone) return instanceClone(val);
            if (instanceClone || isPlainObject(val)) {
                let res = new val.constructor();
                for(let key in val)res[key] = cloneDeep(val[key], instanceClone);
                return res;
            }
            return val;
        }
        function cloneArrayDeep(val, instanceClone) {
            let res = new val.constructor(val.length);
            for(let i = 0; i < val.length; i++)res[i] = cloneDeep(val[i], instanceClone);
            return res;
        }
        module.exports = cloneDeep;
    },
    "../../node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js": function(module) {
        "use strict";
        var isMergeableObject = function isMergeableObject(value) {
            return isNonNullObject(value) && !isSpecial(value);
        };
        function isNonNullObject(value) {
            return !!value && 'object' == typeof value;
        }
        function isSpecial(value) {
            var stringValue = Object.prototype.toString.call(value);
            return '[object RegExp]' === stringValue || '[object Date]' === stringValue || isReactElement(value);
        }
        var REACT_ELEMENT_TYPE = 'function' == typeof Symbol && Symbol.for ? Symbol.for('react.element') : 0xeac7;
        function isReactElement(value) {
            return value.$$typeof === REACT_ELEMENT_TYPE;
        }
        function emptyTarget(val) {
            return Array.isArray(val) ? [] : {};
        }
        function cloneUnlessOtherwiseSpecified(value, options) {
            return !1 !== options.clone && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
        }
        function defaultArrayMerge(target, source, options) {
            return target.concat(source).map(function(element) {
                return cloneUnlessOtherwiseSpecified(element, options);
            });
        }
        function getMergeFunction(key, options) {
            if (!options.customMerge) return deepmerge;
            var customMerge = options.customMerge(key);
            return 'function' == typeof customMerge ? customMerge : deepmerge;
        }
        function getEnumerableOwnPropertySymbols(target) {
            return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function(symbol) {
                return Object.propertyIsEnumerable.call(target, symbol);
            }) : [];
        }
        function getKeys(target) {
            return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
        }
        function propertyIsOnObject(object, property) {
            try {
                return property in object;
            } catch (_) {
                return !1;
            }
        }
        function propertyIsUnsafe(target, key) {
            return propertyIsOnObject(target, key) && !(Object.hasOwnProperty.call(target, key) && Object.propertyIsEnumerable.call(target, key));
        }
        function mergeObject(target, source, options) {
            var destination = {};
            return options.isMergeableObject(target) && getKeys(target).forEach(function(key) {
                destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
            }), getKeys(source).forEach(function(key) {
                propertyIsUnsafe(target, key) || (propertyIsOnObject(target, key) && options.isMergeableObject(source[key]) ? destination[key] = getMergeFunction(key, options)(target[key], source[key], options) : destination[key] = cloneUnlessOtherwiseSpecified(source[key], options));
            }), destination;
        }
        function deepmerge(target, source, options) {
            (options = options || {}).arrayMerge = options.arrayMerge || defaultArrayMerge, options.isMergeableObject = options.isMergeableObject || isMergeableObject, options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
            var sourceIsArray = Array.isArray(source);
            return sourceIsArray !== Array.isArray(target) ? cloneUnlessOtherwiseSpecified(source, options) : sourceIsArray ? options.arrayMerge(target, source, options) : mergeObject(target, source, options);
        }
        deepmerge.all = function deepmergeAll(array, options) {
            if (!Array.isArray(array)) throw Error('first argument should be an array');
            return array.reduce(function(prev, next) {
                return deepmerge(prev, next, options);
            }, {});
        }, module.exports = deepmerge;
    },
    "../../node_modules/.pnpm/dotenv-expand@12.0.3/node_modules/dotenv-expand/lib/main.js": function(module) {
        "use strict";
        function _resolveEscapeSequences(value) {
            return value.replace(/\\\$/g, '$');
        }
        function expandValue(value, processEnv, runningParsed) {
            let match, env = {
                ...runningParsed,
                ...processEnv
            }, regex = /(?<!\\)\${([^{}]+)}|(?<!\\)\$([A-Za-z_][A-Za-z0-9_]*)/g, result = value, seen = new Set();
            for(; null !== (match = regex.exec(result));){
                let defaultValue, value;
                seen.add(result);
                let [template, bracedExpression, unbracedExpression] = match, expression = bracedExpression || unbracedExpression, opRegex = /(:\+|\+|:-|-)/, opMatch = expression.match(opRegex), splitter = opMatch ? opMatch[0] : null, r = expression.split(splitter), key = r.shift();
                if ([
                    ':+',
                    '+'
                ].includes(splitter) ? (defaultValue = env[key] ? r.join(splitter) : '', value = null) : (defaultValue = r.join(splitter), value = env[key]), (result = value ? seen.has(value) ? result.replace(template, defaultValue) : result.replace(template, value) : result.replace(template, defaultValue)) === runningParsed[key]) break;
                regex.lastIndex = 0;
            }
            return result;
        }
        function expand(options) {
            let runningParsed = {}, processEnv = process.env;
            for(let key in options && null != options.processEnv && (processEnv = options.processEnv), options.parsed){
                let value = options.parsed[key];
                value = processEnv[key] && processEnv[key] !== value ? processEnv[key] : expandValue(value, processEnv, runningParsed), options.parsed[key] = _resolveEscapeSequences(value), runningParsed[key] = _resolveEscapeSequences(value);
            }
            for(let processKey in options.parsed)processEnv[processKey] = options.parsed[processKey];
            return options;
        }
        module.exports.expand = expand;
    },
    "../../node_modules/.pnpm/ee-first@1.1.1/node_modules/ee-first/index.js": function(module) {
        "use strict";
        function listener(event, done) {
            return function onevent(arg1) {
                for(var args = Array(arguments.length), i = 0; i < args.length; i++)args[i] = arguments[i];
                done('error' === event ? arg1 : null, this, event, args);
            };
        }
        module.exports = function first(stuff, done) {
            if (!Array.isArray(stuff)) throw TypeError('arg must be an array of [ee, events...] arrays');
            for(var cleanups = [], i = 0; i < stuff.length; i++){
                var arr = stuff[i];
                if (!Array.isArray(arr) || arr.length < 2) throw TypeError('each array member must be [ee, events...]');
                for(var ee = arr[0], j = 1; j < arr.length; j++){
                    var event = arr[j], fn = listener(event, callback);
                    ee.on(event, fn), cleanups.push({
                        ee: ee,
                        event: event,
                        fn: fn
                    });
                }
            }
            function callback() {
                cleanup(), done.apply(null, arguments);
            }
            function cleanup() {
                for(var x, i = 0; i < cleanups.length; i++)(x = cleanups[i]).ee.removeListener(x.event, x.fn);
            }
            function thunk(fn) {
                done = fn;
            }
            return thunk.cancel = cleanup, thunk;
        };
    },
    "../../node_modules/.pnpm/flat@5.0.2/node_modules/flat/index.js": function(module) {
        function isBuffer(obj) {
            return obj && obj.constructor && 'function' == typeof obj.constructor.isBuffer && obj.constructor.isBuffer(obj);
        }
        function keyIdentity(key) {
            return key;
        }
        function flatten(target, opts) {
            let delimiter = (opts = opts || {}).delimiter || '.', maxDepth = opts.maxDepth, transformKey = opts.transformKey || keyIdentity, output = {};
            function step(object, prev, currentDepth) {
                currentDepth = currentDepth || 1, Object.keys(object).forEach(function(key) {
                    let value = object[key], isarray = opts.safe && Array.isArray(value), type = Object.prototype.toString.call(value), isbuffer = isBuffer(value), newKey = prev ? prev + delimiter + transformKey(key) : transformKey(key);
                    if (!isarray && !isbuffer && ('[object Object]' === type || '[object Array]' === type) && Object.keys(value).length && (!opts.maxDepth || currentDepth < maxDepth)) return step(value, newKey, currentDepth + 1);
                    output[newKey] = value;
                });
            }
            return step(target), output;
        }
        function unflatten(target, opts) {
            let delimiter = (opts = opts || {}).delimiter || '.', overwrite = opts.overwrite || !1, transformKey = opts.transformKey || keyIdentity, result = {};
            if (isBuffer(target) || '[object Object]' !== Object.prototype.toString.call(target)) return target;
            function getkey(key) {
                let parsedKey = Number(key);
                return isNaN(parsedKey) || -1 !== key.indexOf('.') || opts.object ? key : parsedKey;
            }
            function addKeys(keyPrefix, recipient, target) {
                return Object.keys(target).reduce(function(result, key) {
                    return result[keyPrefix + delimiter + key] = target[key], result;
                }, recipient);
            }
            function isEmpty(val) {
                let type = Object.prototype.toString.call(val);
                return !val || ('[object Array]' === type ? !val.length : '[object Object]' === type ? !Object.keys(val).length : void 0);
            }
            return Object.keys(target = Object.keys(target).reduce(function(result, key) {
                let type = Object.prototype.toString.call(target[key]);
                return '[object Object]' !== type && '[object Array]' !== type || isEmpty(target[key]) ? (result[key] = target[key], result) : addKeys(key, result, flatten(target[key], opts));
            }, {})).forEach(function(key) {
                let split = key.split(delimiter).map(transformKey), key1 = getkey(split.shift()), key2 = getkey(split[0]), recipient = result;
                for(; void 0 !== key2;){
                    if ('__proto__' === key1) return;
                    let type = Object.prototype.toString.call(recipient[key1]), isobject = '[object Object]' === type || '[object Array]' === type;
                    if (!overwrite && !isobject && void 0 !== recipient[key1]) return;
                    (!overwrite || isobject) && (overwrite || null != recipient[key1]) || (recipient[key1] = 'number' != typeof key2 || opts.object ? {} : []), recipient = recipient[key1], split.length > 0 && (key1 = getkey(split.shift()), key2 = getkey(split[0]));
                }
                recipient[key1] = unflatten(target[key], opts);
            }), result;
        }
        module.exports = flatten, flatten.flatten = flatten, flatten.unflatten = unflatten;
    },
    "../../node_modules/.pnpm/is-plain-object@2.0.4/node_modules/is-plain-object/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        var isObject = __webpack_require__("../../node_modules/.pnpm/isobject@3.0.1/node_modules/isobject/index.js");
        function isObjectObject(o) {
            return !0 === isObject(o) && '[object Object]' === Object.prototype.toString.call(o);
        }
        module.exports = function isPlainObject(o) {
            var ctor, prot;
            return !1 !== isObjectObject(o) && 'function' == typeof (ctor = o.constructor) && !1 !== isObjectObject(prot = ctor.prototype) && !1 !== prot.hasOwnProperty('isPrototypeOf');
        };
    },
    "../../node_modules/.pnpm/isobject@3.0.1/node_modules/isobject/index.js": function(module) {
        "use strict";
        module.exports = function isObject(val) {
            return null != val && 'object' == typeof val && !1 === Array.isArray(val);
        };
    },
    "../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/array.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: !0
        }), exports1.arrayToString = void 0, exports1.arrayToString = (array, space, next)=>{
            let values = array.map(function(value, index) {
                let result = next(value, index);
                return void 0 === result ? String(result) : space + result.split("\n").join(`\n${space}`);
            }).join(space ? ",\n" : ","), eol = space && values ? "\n" : "";
            return `[${eol}${values}${eol}]`;
        };
    },
    "../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/function.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: !0
        }), exports1.FunctionParser = exports1.dedentFunction = exports1.functionToString = exports1.USED_METHOD_KEY = void 0;
        let quote_1 = __webpack_require__("../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/quote.js"), METHOD_NAMES_ARE_QUOTED = '"' === ({
            " " () {}
        })[" "].toString().charAt(0), FUNCTION_PREFIXES = {
            Function: "function ",
            GeneratorFunction: "function* ",
            AsyncFunction: "async function ",
            AsyncGeneratorFunction: "async function* "
        }, METHOD_PREFIXES = {
            Function: "",
            GeneratorFunction: "*",
            AsyncFunction: "async ",
            AsyncGeneratorFunction: "async *"
        }, TOKENS_PRECEDING_REGEXPS = new Set("case delete else in instanceof new return throw typeof void , ; : + - ! ~ & | ^ * / % < > ? =".split(" "));
        function dedentFunction(fnString) {
            let found;
            for (let line of fnString.split("\n").slice(1)){
                let m = /^[\s\t]+/.exec(line);
                if (!m) return fnString;
                let [str] = m;
                void 0 === found ? found = str : str.length < found.length && (found = str);
            }
            return found ? fnString.split(`\n${found}`).join("\n") : fnString;
        }
        exports1.USED_METHOD_KEY = new WeakSet(), exports1.functionToString = (fn, space, next, key)=>{
            let name = "string" == typeof key ? key : void 0;
            return void 0 !== name && exports1.USED_METHOD_KEY.add(fn), new FunctionParser(fn, space, next, name).stringify();
        }, exports1.dedentFunction = dedentFunction;
        class FunctionParser {
            constructor(fn, indent, next, key){
                this.fn = fn, this.indent = indent, this.next = next, this.key = key, this.pos = 0, this.hadKeyword = !1, this.fnString = Function.prototype.toString.call(fn), this.fnType = fn.constructor.name, this.keyQuote = void 0 === key ? "" : quote_1.quoteKey(key, next), this.keyPrefix = void 0 === key ? "" : `${this.keyQuote}:${indent ? " " : ""}`, this.isMethodCandidate = void 0 !== key && ("" === this.fn.name || this.fn.name === key);
            }
            stringify() {
                let value = this.tryParse();
                return value ? dedentFunction(value) : `${this.keyPrefix}void ${this.next(this.fnString)}`;
            }
            getPrefix() {
                return this.isMethodCandidate && !this.hadKeyword ? METHOD_PREFIXES[this.fnType] + this.keyQuote : this.keyPrefix + FUNCTION_PREFIXES[this.fnType];
            }
            tryParse() {
                if ("}" !== this.fnString[this.fnString.length - 1]) return this.keyPrefix + this.fnString;
                if (this.fn.name) {
                    let result = this.tryStrippingName();
                    if (result) return result;
                }
                let prevPos = this.pos;
                if ("class" === this.consumeSyntax()) return this.fnString;
                if (this.pos = prevPos, this.tryParsePrefixTokens()) {
                    let result = this.tryStrippingName();
                    if (result) return result;
                    let offset = this.pos;
                    switch(this.consumeSyntax("WORD_LIKE")){
                        case "WORD_LIKE":
                            this.isMethodCandidate && !this.hadKeyword && (offset = this.pos);
                        case "()":
                            if ("=>" === this.fnString.substr(this.pos, 2)) return this.keyPrefix + this.fnString;
                            this.pos = offset;
                        case '"':
                        case "'":
                        case "[]":
                            return this.getPrefix() + this.fnString.substr(this.pos);
                    }
                }
            }
            tryStrippingName() {
                if (METHOD_NAMES_ARE_QUOTED) return;
                let start = this.pos, prefix = this.fnString.substr(this.pos, this.fn.name.length);
                if (prefix === this.fn.name && (this.pos += prefix.length, "()" === this.consumeSyntax() && "{}" === this.consumeSyntax() && this.pos === this.fnString.length)) return (this.isMethodCandidate || !quote_1.isValidVariableName(prefix)) && (start += prefix.length), this.getPrefix() + this.fnString.substr(start);
                this.pos = start;
            }
            tryParsePrefixTokens() {
                let posPrev = this.pos;
                switch(this.hadKeyword = !1, this.fnType){
                    case "AsyncFunction":
                        if ("async" !== this.consumeSyntax()) return !1;
                        posPrev = this.pos;
                    case "Function":
                        return "function" === this.consumeSyntax() ? this.hadKeyword = !0 : this.pos = posPrev, !0;
                    case "AsyncGeneratorFunction":
                        if ("async" !== this.consumeSyntax()) return !1;
                    case "GeneratorFunction":
                        let token = this.consumeSyntax();
                        return "function" === token && (token = this.consumeSyntax(), this.hadKeyword = !0), "*" === token;
                }
            }
            consumeSyntax(wordLikeToken) {
                let m = this.consumeMatch(/^(?:([A-Za-z_0-9$\xA0-\uFFFF]+)|=>|\+\+|\-\-|.)/);
                if (!m) return;
                let [token, match] = m;
                if (this.consumeWhitespace(), match) return wordLikeToken || match;
                switch(token){
                    case "(":
                        return this.consumeSyntaxUntil("(", ")");
                    case "[":
                        return this.consumeSyntaxUntil("[", "]");
                    case "{":
                        return this.consumeSyntaxUntil("{", "}");
                    case "`":
                        return this.consumeTemplate();
                    case '"':
                        return this.consumeRegExp(/^(?:[^\\"]|\\.)*"/, '"');
                    case "'":
                        return this.consumeRegExp(/^(?:[^\\']|\\.)*'/, "'");
                }
                return token;
            }
            consumeSyntaxUntil(startToken, endToken) {
                let isRegExpAllowed = !0;
                for(;;){
                    let token = this.consumeSyntax();
                    if (token === endToken) return startToken + endToken;
                    if (!token || ")" === token || "]" === token || "}" === token) return;
                    "/" === token && isRegExpAllowed && this.consumeMatch(/^(?:\\.|[^\\\/\n[]|\[(?:\\.|[^\]])*\])+\/[a-z]*/) ? (isRegExpAllowed = !1, this.consumeWhitespace()) : isRegExpAllowed = TOKENS_PRECEDING_REGEXPS.has(token);
                }
            }
            consumeMatch(re) {
                let m = re.exec(this.fnString.substr(this.pos));
                return m && (this.pos += m[0].length), m;
            }
            consumeRegExp(re, token) {
                let m = re.exec(this.fnString.substr(this.pos));
                if (m) return this.pos += m[0].length, this.consumeWhitespace(), token;
            }
            consumeTemplate() {
                for(;;){
                    if (this.consumeMatch(/^(?:[^`$\\]|\\.|\$(?!{))*/), "`" === this.fnString[this.pos]) return this.pos++, this.consumeWhitespace(), "`";
                    if (!("${" === this.fnString.substr(this.pos, 2) && (this.pos += 2, this.consumeWhitespace(), this.consumeSyntaxUntil("{", "}")))) return;
                }
            }
            consumeWhitespace() {
                this.consumeMatch(/^(?:\s|\/\/.*|\/\*[^]*?\*\/)*/);
            }
        }
        exports1.FunctionParser = FunctionParser;
    },
    "../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        exports1.stringify = void 0;
        let stringify_1 = __webpack_require__("../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/stringify.js"), quote_1 = __webpack_require__("../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/quote.js"), ROOT_SENTINEL = Symbol("root");
        function replacerToString(replacer) {
            return replacer ? (value, space, next, key)=>replacer(value, space, (value)=>stringify_1.toString(value, space, next, key), key) : stringify_1.toString;
        }
        exports1.stringify = function stringify(value, replacer, indent, options = {}) {
            let space = "string" == typeof indent ? indent : " ".repeat(indent || 0), path = [], stack = new Set(), tracking = new Map(), unpack = new Map(), valueCount = 0, { maxDepth = 100, references = !1, skipUndefinedProperties = !1, maxValues = 100000 } = options, valueToString = replacerToString(replacer), onNext = (value, key)=>{
                if (++valueCount > maxValues || skipUndefinedProperties && void 0 === value || path.length > maxDepth) return;
                if (void 0 === key) return valueToString(value, space, onNext, key);
                path.push(key);
                let result = builder(value, key === ROOT_SENTINEL ? void 0 : key);
                return path.pop(), result;
            }, builder = references ? (value, key)=>{
                if (null !== value && ("object" == typeof value || "function" == typeof value || "symbol" == typeof value)) {
                    if (tracking.has(value)) return unpack.set(path.slice(1), tracking.get(value)), valueToString(void 0, space, onNext, key);
                    tracking.set(value, path.slice(1));
                }
                return valueToString(value, space, onNext, key);
            } : (value, key)=>{
                if (stack.has(value)) return;
                stack.add(value);
                let result = valueToString(value, space, onNext, key);
                return stack.delete(value), result;
            }, result = onNext(value, ROOT_SENTINEL);
            if (unpack.size) {
                let sp = space ? " " : "", eol = space ? "\n" : "", wrapper = `var x${sp}=${sp}${result};${eol}`;
                for (let [key, value] of unpack.entries()){
                    let keyPath = quote_1.stringifyPath(key, onNext), valuePath = quote_1.stringifyPath(value, onNext);
                    wrapper += `x${keyPath}${sp}=${sp}x${valuePath};${eol}`;
                }
                return `(function${sp}()${sp}{${eol}${wrapper}return x;${eol}}())`;
            }
            return result;
        };
    },
    "../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/object.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: !0
        }), exports1.objectToString = void 0;
        let quote_1 = __webpack_require__("../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/quote.js"), function_1 = __webpack_require__("../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/function.js"), array_1 = __webpack_require__("../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/array.js");
        exports1.objectToString = (value, space, next, key)=>{
            if ("function" == typeof Buffer && Buffer.isBuffer(value)) return `Buffer.from(${next(value.toString("base64"))}, 'base64')`;
            if ("object" == typeof global && value === global) return globalToString(value, space, next, key);
            let toString = OBJECT_TYPES[Object.prototype.toString.call(value)];
            return toString ? toString(value, space, next, key) : void 0;
        };
        let globalToString = (value, space, next)=>`Function(${next("return this")})()`, OBJECT_TYPES = {
            "[object Array]": array_1.arrayToString,
            "[object Object]": (obj, indent, next, key)=>{
                let eol = indent ? "\n" : "", space = indent ? " " : "", values = Object.keys(obj).reduce(function(values, key) {
                    let fn = obj[key], result = next(fn, key);
                    if (void 0 === result) return values;
                    let value = result.split("\n").join(`\n${indent}`);
                    return function_1.USED_METHOD_KEY.has(fn) ? values.push(`${indent}${value}`) : values.push(`${indent}${quote_1.quoteKey(key, next)}:${space}${value}`), values;
                }, []).join(`,${eol}`);
                return "" === values ? "{}" : `{${eol}${values}${eol}}`;
            },
            "[object Error]": (error, space, next)=>`new Error(${next(error.message)})`,
            "[object Date]": (date)=>`new Date(${date.getTime()})`,
            "[object String]": (str, space, next)=>`new String(${next(str.toString())})`,
            "[object Number]": (num)=>`new Number(${num})`,
            "[object Boolean]": (bool)=>`new Boolean(${bool})`,
            "[object Set]": (set, space, next)=>`new Set(${next(Array.from(set))})`,
            "[object Map]": (map, space, next)=>`new Map(${next(Array.from(map))})`,
            "[object RegExp]": String,
            "[object global]": globalToString,
            "[object Window]": globalToString
        };
    },
    "../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/quote.js": function(__unused_webpack_module, exports1) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: !0
        }), exports1.stringifyPath = exports1.quoteKey = exports1.isValidVariableName = exports1.IS_VALID_IDENTIFIER = exports1.quoteString = void 0;
        let ESCAPABLE = /[\\\'\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, META_CHARS = new Map([
            [
                "\b",
                "\\b"
            ],
            [
                "\t",
                "\\t"
            ],
            [
                "\n",
                "\\n"
            ],
            [
                "\f",
                "\\f"
            ],
            [
                "\r",
                "\\r"
            ],
            [
                "'",
                "\\'"
            ],
            [
                '"',
                '\\"'
            ],
            [
                "\\",
                "\\\\"
            ]
        ]);
        function escapeChar(char) {
            return META_CHARS.get(char) || `\\u${`0000${char.charCodeAt(0).toString(16)}`.slice(-4)}`;
        }
        exports1.quoteString = function quoteString(str) {
            return `'${str.replace(ESCAPABLE, escapeChar)}'`;
        };
        let RESERVED_WORDS = new Set("break else new var case finally return void catch for switch while continue function this with default if throw delete in try do instanceof typeof abstract enum int short boolean export interface static byte extends long super char final native synchronized class float package throws const goto private transient debugger implements protected volatile double import public let yield".split(" "));
        function isValidVariableName(name) {
            return "string" == typeof name && !RESERVED_WORDS.has(name) && exports1.IS_VALID_IDENTIFIER.test(name);
        }
        exports1.IS_VALID_IDENTIFIER = /^[A-Za-z_$][A-Za-z0-9_$]*$/, exports1.isValidVariableName = isValidVariableName, exports1.quoteKey = function quoteKey(key, next) {
            return isValidVariableName(key) ? key : next(key);
        }, exports1.stringifyPath = function stringifyPath(path, next) {
            let result = "";
            for (let key of path)isValidVariableName(key) ? result += `.${key}` : result += `[${next(key)}]`;
            return result;
        };
    },
    "../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/stringify.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        Object.defineProperty(exports1, "__esModule", {
            value: !0
        }), exports1.toString = void 0;
        let quote_1 = __webpack_require__("../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/quote.js"), object_1 = __webpack_require__("../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/object.js"), function_1 = __webpack_require__("../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/function.js"), PRIMITIVE_TYPES = {
            string: quote_1.quoteString,
            number: (value)=>Object.is(value, -0) ? "-0" : String(value),
            boolean: String,
            symbol: (value, space, next)=>{
                let key = Symbol.keyFor(value);
                return void 0 !== key ? `Symbol.for(${next(key)})` : `Symbol(${next(value.description)})`;
            },
            bigint: (value, space, next)=>`BigInt(${next(String(value))})`,
            undefined: String,
            object: object_1.objectToString,
            function: function_1.functionToString
        };
        exports1.toString = (value, space, next, key)=>null === value ? "null" : PRIMITIVE_TYPES[typeof value](value, space, next, key);
    },
    "../../node_modules/.pnpm/kind-of@6.0.3/node_modules/kind-of/index.js": function(module) {
        var toString = Object.prototype.toString;
        function ctorName(val) {
            return 'function' == typeof val.constructor ? val.constructor.name : null;
        }
        function isArray(val) {
            return Array.isArray ? Array.isArray(val) : val instanceof Array;
        }
        function isError(val) {
            return val instanceof Error || 'string' == typeof val.message && val.constructor && 'number' == typeof val.constructor.stackTraceLimit;
        }
        function isDate(val) {
            return val instanceof Date || 'function' == typeof val.toDateString && 'function' == typeof val.getDate && 'function' == typeof val.setDate;
        }
        function isRegexp(val) {
            return val instanceof RegExp || 'string' == typeof val.flags && 'boolean' == typeof val.ignoreCase && 'boolean' == typeof val.multiline && 'boolean' == typeof val.global;
        }
        function isGeneratorFn(name, val) {
            return 'GeneratorFunction' === ctorName(name);
        }
        function isGeneratorObj(val) {
            return 'function' == typeof val.throw && 'function' == typeof val.return && 'function' == typeof val.next;
        }
        function isArguments(val) {
            try {
                if ('number' == typeof val.length && 'function' == typeof val.callee) return !0;
            } catch (err) {
                if (-1 !== err.message.indexOf('callee')) return !0;
            }
            return !1;
        }
        function isBuffer(val) {
            return !!val.constructor && 'function' == typeof val.constructor.isBuffer && val.constructor.isBuffer(val);
        }
        module.exports = function kindOf(val) {
            if (void 0 === val) return 'undefined';
            if (null === val) return 'null';
            var type = typeof val;
            if ('boolean' === type) return 'boolean';
            if ('string' === type) return 'string';
            if ('number' === type) return 'number';
            if ('symbol' === type) return 'symbol';
            if ('function' === type) return isGeneratorFn(val) ? 'generatorfunction' : 'function';
            if (isArray(val)) return 'array';
            if (isBuffer(val)) return 'buffer';
            if (isArguments(val)) return 'arguments';
            if (isDate(val)) return 'date';
            if (isError(val)) return 'error';
            if (isRegexp(val)) return 'regexp';
            switch(ctorName(val)){
                case 'Symbol':
                    return 'symbol';
                case 'Promise':
                    return 'promise';
                case 'WeakMap':
                    return 'weakmap';
                case 'WeakSet':
                    return 'weakset';
                case 'Map':
                    return 'map';
                case 'Set':
                    return 'set';
                case 'Int8Array':
                    return 'int8array';
                case 'Uint8Array':
                    return 'uint8array';
                case 'Uint8ClampedArray':
                    return 'uint8clampedarray';
                case 'Int16Array':
                    return 'int16array';
                case 'Uint16Array':
                    return 'uint16array';
                case 'Int32Array':
                    return 'int32array';
                case 'Uint32Array':
                    return 'uint32array';
                case 'Float32Array':
                    return 'float32array';
                case 'Float64Array':
                    return 'float64array';
            }
            if (isGeneratorObj(val)) return 'generator';
            switch(type = toString.call(val)){
                case '[object Object]':
                    return 'object';
                case '[object Map Iterator]':
                    return 'mapiterator';
                case '[object Set Iterator]':
                    return 'setiterator';
                case '[object String Iterator]':
                    return 'stringiterator';
                case '[object Array Iterator]':
                    return 'arrayiterator';
            }
            return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
        };
    },
    "../../node_modules/.pnpm/lilconfig@3.1.3/node_modules/lilconfig/src/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        let path = __webpack_require__("path"), fs = __webpack_require__("fs"), os = __webpack_require__("os"), url = __webpack_require__("url"), fsReadFileAsync = fs.promises.readFile;
        function getDefaultSearchPlaces(name, sync) {
            return [
                'package.json',
                `.${name}rc.json`,
                `.${name}rc.js`,
                `.${name}rc.cjs`,
                ...sync ? [] : [
                    `.${name}rc.mjs`
                ],
                `.config/${name}rc`,
                `.config/${name}rc.json`,
                `.config/${name}rc.js`,
                `.config/${name}rc.cjs`,
                ...sync ? [] : [
                    `.config/${name}rc.mjs`
                ],
                `${name}.config.js`,
                `${name}.config.cjs`,
                ...sync ? [] : [
                    `${name}.config.mjs`
                ]
            ];
        }
        function parentDir(p) {
            return path.dirname(p) || path.sep;
        }
        let jsonLoader = (_, content)=>JSON.parse(content), requireFunc = require, defaultLoadersSync = Object.freeze({
            '.js': requireFunc,
            '.json': requireFunc,
            '.cjs': requireFunc,
            noExt: jsonLoader
        });
        module.exports.defaultLoadersSync = defaultLoadersSync;
        let dynamicImport = async (id)=>{
            try {
                let fileUrl = url.pathToFileURL(id).href;
                return (await import(fileUrl)).default;
            } catch (e) {
                try {
                    return requireFunc(id);
                } catch (requireE) {
                    if ('ERR_REQUIRE_ESM' === requireE.code || requireE instanceof SyntaxError && requireE.toString().includes('Cannot use import statement outside a module')) throw e;
                    throw requireE;
                }
            }
        }, defaultLoaders = Object.freeze({
            '.js': dynamicImport,
            '.mjs': dynamicImport,
            '.cjs': dynamicImport,
            '.json': jsonLoader,
            noExt: jsonLoader
        });
        function getOptions(name, options, sync) {
            let conf = {
                stopDir: os.homedir(),
                searchPlaces: getDefaultSearchPlaces(name, sync),
                ignoreEmptySearchPlaces: !0,
                cache: !0,
                transform: (x)=>x,
                packageProp: [
                    name
                ],
                ...options,
                loaders: {
                    ...sync ? defaultLoadersSync : defaultLoaders,
                    ...options.loaders
                }
            };
            return conf.searchPlaces.forEach((place)=>{
                let key = path.extname(place) || 'noExt', loader = conf.loaders[key];
                if (!loader) throw Error(`Missing loader for extension "${place}"`);
                if ('function' != typeof loader) throw Error(`Loader for extension "${place}" is not a function: Received ${typeof loader}.`);
            }), conf;
        }
        function getPackageProp(props, obj) {
            return 'string' == typeof props && props in obj ? obj[props] : (Array.isArray(props) ? props : props.split('.')).reduce((acc, prop)=>void 0 === acc ? acc : acc[prop], obj) || null;
        }
        function validateFilePath(filepath) {
            if (!filepath) throw Error('load must pass a non-empty string');
        }
        function validateLoader(loader, ext) {
            if (!loader) throw Error(`No loader specified for extension "${ext}"`);
            if ('function' != typeof loader) throw Error('loader is not a function');
        }
        module.exports.defaultLoaders = defaultLoaders;
        let makeEmplace = (enableCache)=>(c, filepath, res)=>(enableCache && c.set(filepath, res), res);
        module.exports.lilconfig = function lilconfig(name, options) {
            let { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform, cache } = getOptions(name, options ?? {}, !1), searchCache = new Map(), loadCache = new Map(), emplace = makeEmplace(cache);
            return {
                async search (searchFrom = process.cwd()) {
                    let result = {
                        config: null,
                        filepath: ''
                    }, visited = new Set(), dir = searchFrom;
                    dirLoop: for(;;){
                        if (cache) {
                            let r = searchCache.get(dir);
                            if (void 0 !== r) {
                                for (let p of visited)searchCache.set(p, r);
                                return r;
                            }
                            visited.add(dir);
                        }
                        for (let searchPlace of searchPlaces){
                            let filepath = path.join(dir, searchPlace);
                            try {
                                await fs.promises.access(filepath);
                            } catch  {
                                continue;
                            }
                            let content = String(await fsReadFileAsync(filepath)), loaderKey = path.extname(searchPlace) || 'noExt', loader = loaders[loaderKey];
                            if ('package.json' === searchPlace) {
                                let maybeConfig = getPackageProp(packageProp, await loader(filepath, content));
                                if (null != maybeConfig) {
                                    result.config = maybeConfig, result.filepath = filepath;
                                    break dirLoop;
                                }
                                continue;
                            }
                            let isEmpty = '' === content.trim();
                            if (!isEmpty || !ignoreEmptySearchPlaces) {
                                isEmpty ? (result.isEmpty = !0, result.config = void 0) : (validateLoader(loader, loaderKey), result.config = await loader(filepath, content)), result.filepath = filepath;
                                break dirLoop;
                            }
                        }
                        if (dir === stopDir || dir === parentDir(dir)) break;
                        dir = parentDir(dir);
                    }
                    let transformed = '' === result.filepath && null === result.config ? transform(null) : transform(result);
                    if (cache) for (let p of visited)searchCache.set(p, transformed);
                    return transformed;
                },
                async load (filepath) {
                    validateFilePath(filepath);
                    let absPath = path.resolve(process.cwd(), filepath);
                    if (cache && loadCache.has(absPath)) return loadCache.get(absPath);
                    let { base, ext } = path.parse(absPath), loaderKey = ext || 'noExt', loader = loaders[loaderKey];
                    validateLoader(loader, loaderKey);
                    let content = String(await fsReadFileAsync(absPath));
                    if ('package.json' === base) {
                        let pkg = await loader(absPath, content);
                        return emplace(loadCache, absPath, transform({
                            config: getPackageProp(packageProp, pkg),
                            filepath: absPath
                        }));
                    }
                    let result = {
                        config: null,
                        filepath: absPath
                    }, isEmpty = '' === content.trim();
                    return isEmpty && ignoreEmptySearchPlaces ? emplace(loadCache, absPath, transform({
                        config: void 0,
                        filepath: absPath,
                        isEmpty: !0
                    })) : (result.config = isEmpty ? void 0 : await loader(absPath, content), emplace(loadCache, absPath, transform(isEmpty ? {
                        ...result,
                        isEmpty,
                        config: void 0
                    } : result)));
                },
                clearLoadCache () {
                    cache && loadCache.clear();
                },
                clearSearchCache () {
                    cache && searchCache.clear();
                },
                clearCaches () {
                    cache && (loadCache.clear(), searchCache.clear());
                }
            };
        }, module.exports.lilconfigSync = function lilconfigSync(name, options) {
            let { ignoreEmptySearchPlaces, loaders, packageProp, searchPlaces, stopDir, transform, cache } = getOptions(name, options ?? {}, !0), searchCache = new Map(), loadCache = new Map(), emplace = makeEmplace(cache);
            return {
                search (searchFrom = process.cwd()) {
                    let result = {
                        config: null,
                        filepath: ''
                    }, visited = new Set(), dir = searchFrom;
                    dirLoop: for(;;){
                        if (cache) {
                            let r = searchCache.get(dir);
                            if (void 0 !== r) {
                                for (let p of visited)searchCache.set(p, r);
                                return r;
                            }
                            visited.add(dir);
                        }
                        for (let searchPlace of searchPlaces){
                            let filepath = path.join(dir, searchPlace);
                            try {
                                fs.accessSync(filepath);
                            } catch  {
                                continue;
                            }
                            let loaderKey = path.extname(searchPlace) || 'noExt', loader = loaders[loaderKey], content = String(fs.readFileSync(filepath));
                            if ('package.json' === searchPlace) {
                                let maybeConfig = getPackageProp(packageProp, loader(filepath, content));
                                if (null != maybeConfig) {
                                    result.config = maybeConfig, result.filepath = filepath;
                                    break dirLoop;
                                }
                                continue;
                            }
                            let isEmpty = '' === content.trim();
                            if (!isEmpty || !ignoreEmptySearchPlaces) {
                                isEmpty ? (result.isEmpty = !0, result.config = void 0) : (validateLoader(loader, loaderKey), result.config = loader(filepath, content)), result.filepath = filepath;
                                break dirLoop;
                            }
                        }
                        if (dir === stopDir || dir === parentDir(dir)) break;
                        dir = parentDir(dir);
                    }
                    let transformed = '' === result.filepath && null === result.config ? transform(null) : transform(result);
                    if (cache) for (let p of visited)searchCache.set(p, transformed);
                    return transformed;
                },
                load (filepath) {
                    validateFilePath(filepath);
                    let absPath = path.resolve(process.cwd(), filepath);
                    if (cache && loadCache.has(absPath)) return loadCache.get(absPath);
                    let { base, ext } = path.parse(absPath), loaderKey = ext || 'noExt', loader = loaders[loaderKey];
                    validateLoader(loader, loaderKey);
                    let content = String(fs.readFileSync(absPath));
                    if ('package.json' === base) return transform({
                        config: getPackageProp(packageProp, loader(absPath, content)),
                        filepath: absPath
                    });
                    let result = {
                        config: null,
                        filepath: absPath
                    }, isEmpty = '' === content.trim();
                    return isEmpty && ignoreEmptySearchPlaces ? emplace(loadCache, absPath, transform({
                        filepath: absPath,
                        config: void 0,
                        isEmpty: !0
                    })) : (result.config = isEmpty ? void 0 : loader(absPath, content), emplace(loadCache, absPath, transform(isEmpty ? {
                        ...result,
                        isEmpty,
                        config: void 0
                    } : result)));
                },
                clearLoadCache () {
                    cache && loadCache.clear();
                },
                clearSearchCache () {
                    cache && searchCache.clear();
                },
                clearCaches () {
                    cache && (loadCache.clear(), searchCache.clear());
                }
            };
        };
    },
    "../../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        module.exports = onFinished, module.exports.isFinished = isFinished;
        var asyncHooks = tryRequireAsyncHooks(), first = __webpack_require__("../../node_modules/.pnpm/ee-first@1.1.1/node_modules/ee-first/index.js"), defer = 'function' == typeof setImmediate ? setImmediate : function(fn) {
            process.nextTick(fn.bind.apply(fn, arguments));
        };
        function onFinished(msg, listener) {
            return !1 !== isFinished(msg) ? defer(listener, null, msg) : attachListener(msg, wrap(listener)), msg;
        }
        function isFinished(msg) {
            var socket = msg.socket;
            return 'boolean' == typeof msg.finished ? !!(msg.finished || socket && !socket.writable) : 'boolean' == typeof msg.complete ? !!(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable) : void 0;
        }
        function attachFinishedListener(msg, callback) {
            var eeMsg, eeSocket, finished = !1;
            function onFinish(error) {
                eeMsg.cancel(), eeSocket.cancel(), finished = !0, callback(error);
            }
            function onSocket(socket) {
                msg.removeListener('socket', onSocket), finished || eeMsg === eeSocket && (eeSocket = first([
                    [
                        socket,
                        'error',
                        'close'
                    ]
                ], onFinish));
            }
            (eeMsg = eeSocket = first([
                [
                    msg,
                    'end',
                    'finish'
                ]
            ], onFinish), msg.socket) ? onSocket(msg.socket) : (msg.on('socket', onSocket), void 0 === msg.socket && patchAssignSocket(msg, onSocket));
        }
        function attachListener(msg, listener) {
            var attached = msg.__onFinished;
            attached && attached.queue || (attached = msg.__onFinished = createListener(msg), attachFinishedListener(msg, attached)), attached.queue.push(listener);
        }
        function createListener(msg) {
            function listener(err) {
                if (msg.__onFinished === listener && (msg.__onFinished = null), listener.queue) {
                    var queue = listener.queue;
                    listener.queue = null;
                    for(var i = 0; i < queue.length; i++)queue[i](err, msg);
                }
            }
            return listener.queue = [], listener;
        }
        function patchAssignSocket(res, callback) {
            var assignSocket = res.assignSocket;
            'function' == typeof assignSocket && (res.assignSocket = function _assignSocket(socket) {
                assignSocket.call(this, socket), callback(socket);
            });
        }
        function tryRequireAsyncHooks() {
            try {
                return __webpack_require__("async_hooks");
            } catch (e) {
                return {};
            }
        }
        function wrap(fn) {
            var res;
            return (asyncHooks.AsyncResource && (res = new asyncHooks.AsyncResource(fn.name || 'bound-anonymous-fn')), res && res.runInAsyncScope) ? res.runInAsyncScope.bind(res, fn, null) : fn;
        }
    },
    "../../node_modules/.pnpm/postcss-load-config@6.0.1_jiti@2.6.1_postcss@8.5.6_yaml@2.8.1/node_modules/postcss-load-config/src/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        let yaml, { resolve } = __webpack_require__("node:path"), config = __webpack_require__("../../node_modules/.pnpm/lilconfig@3.1.3/node_modules/lilconfig/src/index.js"), loadOptions = __webpack_require__("../../node_modules/.pnpm/postcss-load-config@6.0.1_jiti@2.6.1_postcss@8.5.6_yaml@2.8.1/node_modules/postcss-load-config/src/options.js"), loadPlugins = __webpack_require__("../../node_modules/.pnpm/postcss-load-config@6.0.1_jiti@2.6.1_postcss@8.5.6_yaml@2.8.1/node_modules/postcss-load-config/src/plugins.js"), req = __webpack_require__("../../node_modules/.pnpm/postcss-load-config@6.0.1_jiti@2.6.1_postcss@8.5.6_yaml@2.8.1/node_modules/postcss-load-config/src/req.js");
        async function processResult(ctx, result) {
            let obj, file = result.filepath || '', projectConfig = ((obj = result.config) && obj.__esModule ? obj : {
                default: obj
            }).default || {};
            (projectConfig = 'function' == typeof projectConfig ? projectConfig(ctx) : Object.assign({}, projectConfig, ctx)).plugins || (projectConfig.plugins = []);
            let res = {
                file,
                options: await loadOptions(projectConfig, file),
                plugins: await loadPlugins(projectConfig, file)
            };
            return delete projectConfig.plugins, res;
        }
        function createContext(ctx) {
            return (ctx = Object.assign({
                cwd: process.cwd(),
                env: process.env.NODE_ENV
            }, ctx)).env || (process.env.NODE_ENV = 'development'), ctx;
        }
        async function loader(filepath) {
            return req(filepath);
        }
        async function yamlLoader(_, content) {
            if (!yaml) try {
                yaml = await import("yaml");
            } catch (e) {
                throw Error(`'yaml' is required for the YAML configuration files. Make sure it is installed\nError: ${e.message}`);
            }
            return yaml.parse(content);
        }
        module.exports = function rc(ctx, path, options) {
            return ctx = createContext(ctx), path = path ? resolve(path) : process.cwd(), config.lilconfig('postcss', ((options = {})=>{
                let moduleName = 'postcss';
                return {
                    ...options,
                    loaders: {
                        ...options.loaders,
                        '.cjs': loader,
                        '.cts': loader,
                        '.js': loader,
                        '.mjs': loader,
                        '.mts': loader,
                        '.ts': loader,
                        '.yaml': yamlLoader,
                        '.yml': yamlLoader
                    },
                    searchPlaces: [
                        ...options.searchPlaces || [],
                        'package.json',
                        `.${moduleName}rc`,
                        `.${moduleName}rc.json`,
                        `.${moduleName}rc.yaml`,
                        `.${moduleName}rc.yml`,
                        `.${moduleName}rc.ts`,
                        `.${moduleName}rc.cts`,
                        `.${moduleName}rc.mts`,
                        `.${moduleName}rc.js`,
                        `.${moduleName}rc.cjs`,
                        `.${moduleName}rc.mjs`,
                        `${moduleName}.config.ts`,
                        `${moduleName}.config.cts`,
                        `${moduleName}.config.mts`,
                        `${moduleName}.config.js`,
                        `${moduleName}.config.cjs`,
                        `${moduleName}.config.mjs`
                    ]
                };
            })(options)).search(path).then((result)=>{
                if (!result) throw Error(`No PostCSS Config found in: ${path}`);
                return processResult(ctx, result);
            });
        };
    },
    "../../node_modules/.pnpm/postcss-load-config@6.0.1_jiti@2.6.1_postcss@8.5.6_yaml@2.8.1/node_modules/postcss-load-config/src/options.js": function(module, __unused_webpack_exports, __webpack_require__) {
        let req = __webpack_require__("../../node_modules/.pnpm/postcss-load-config@6.0.1_jiti@2.6.1_postcss@8.5.6_yaml@2.8.1/node_modules/postcss-load-config/src/req.js");
        module.exports = async function options(config, file) {
            if (config.parser && 'string' == typeof config.parser) try {
                config.parser = await req(config.parser, file);
            } catch (err) {
                throw Error(`Loading PostCSS Parser failed: ${err.message}\n\n(@${file})`);
            }
            if (config.syntax && 'string' == typeof config.syntax) try {
                config.syntax = await req(config.syntax, file);
            } catch (err) {
                throw Error(`Loading PostCSS Syntax failed: ${err.message}\n\n(@${file})`);
            }
            if (config.stringifier && 'string' == typeof config.stringifier) try {
                config.stringifier = await req(config.stringifier, file);
            } catch (err) {
                throw Error(`Loading PostCSS Stringifier failed: ${err.message}\n\n(@${file})`);
            }
            return config;
        };
    },
    "../../node_modules/.pnpm/postcss-load-config@6.0.1_jiti@2.6.1_postcss@8.5.6_yaml@2.8.1/node_modules/postcss-load-config/src/plugins.js": function(module, __unused_webpack_exports, __webpack_require__) {
        let req = __webpack_require__("../../node_modules/.pnpm/postcss-load-config@6.0.1_jiti@2.6.1_postcss@8.5.6_yaml@2.8.1/node_modules/postcss-load-config/src/req.js");
        async function load(plugin, options, file) {
            try {
                if (null == options || 0 === Object.keys(options).length) return await req(plugin, file);
                return (await req(plugin, file))(options);
            } catch (err) {
                throw Error(`Loading PostCSS Plugin failed: ${err.message}\n\n(@${file})`);
            }
        }
        module.exports = async function plugins(config, file) {
            let list = [];
            return Array.isArray(config.plugins) ? list = config.plugins.filter(Boolean) : (list = Object.entries(config.plugins).filter(([, options])=>!1 !== options).map(([plugin, options])=>load(plugin, options, file)), list = await Promise.all(list)), list.length && list.length > 0 && list.forEach((plugin, i)=>{
                if (plugin.default && (plugin = plugin.default), !0 === plugin.postcss ? plugin = plugin() : plugin.postcss && (plugin = plugin.postcss), !('object' == typeof plugin && Array.isArray(plugin.plugins) || 'object' == typeof plugin && plugin.postcssPlugin || 'function' == typeof plugin)) throw TypeError(`Invalid PostCSS Plugin found at: plugins[${i}]\n\n(@${file})`);
            }), list;
        };
    },
    "../../node_modules/.pnpm/postcss-load-config@6.0.1_jiti@2.6.1_postcss@8.5.6_yaml@2.8.1/node_modules/postcss-load-config/src/req.js": function(module, __unused_webpack_exports, __webpack_require__) {
        let tsx, jiti, { createRequire } = __webpack_require__("node:module"), { pathToFileURL } = __webpack_require__("node:url"), TS_EXT_RE = /\.[mc]?ts$/, importError = [];
        module.exports = async function req(name, rootFile = __filename) {
            let url = createRequire(rootFile).resolve(name);
            try {
                return (await import(`${pathToFileURL(url)}?t=${Date.now()}`)).default;
            } catch (err) {
                if (!TS_EXT_RE.test(url)) throw err;
            }
            if (void 0 === tsx) try {
                tsx = await import("tsx/cjs/api");
            } catch (error) {
                importError.push(error);
            }
            if (tsx) {
                let loaded = tsx.require(name, rootFile);
                return loaded && '__esModule' in loaded ? loaded.default : loaded;
            }
            if (void 0 === jiti) try {
                jiti = (await import("jiti")).default;
            } catch (error) {
                importError.push(error);
            }
            if (jiti) return jiti(rootFile, {
                interopDefault: !0
            })(name);
            throw Error(`'tsx' or 'jiti' is required for the TypeScript configuration files. Make sure it is installed\nError: ${importError.map((error)=>error.message).join('\n')}`);
        };
    },
    "../../node_modules/.pnpm/shallow-clone@3.0.1/node_modules/shallow-clone/index.js": function(module, __unused_webpack_exports, __webpack_require__) {
        "use strict";
        let valueOf = Symbol.prototype.valueOf, typeOf = __webpack_require__("../../node_modules/.pnpm/kind-of@6.0.3/node_modules/kind-of/index.js");
        function cloneRegExp(val) {
            let flags = void 0 !== val.flags ? val.flags : /\w+$/.exec(val) || void 0, re = new val.constructor(val.source, flags);
            return re.lastIndex = val.lastIndex, re;
        }
        function cloneArrayBuffer(val) {
            let res = new val.constructor(val.byteLength);
            return new Uint8Array(res).set(new Uint8Array(val)), res;
        }
        function cloneTypedArray(val, deep) {
            return new val.constructor(val.buffer, val.byteOffset, val.length);
        }
        function cloneBuffer(val) {
            let len = val.length, buf = Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : Buffer.from(len);
            return val.copy(buf), buf;
        }
        function cloneSymbol(val) {
            return valueOf ? Object(valueOf.call(val)) : {};
        }
        module.exports = function clone(val, deep) {
            switch(typeOf(val)){
                case 'array':
                    return val.slice();
                case 'object':
                    return Object.assign({}, val);
                case 'date':
                    return new val.constructor(Number(val));
                case 'map':
                    return new Map(val);
                case 'set':
                    return new Set(val);
                case 'buffer':
                    return cloneBuffer(val);
                case 'symbol':
                    return cloneSymbol(val);
                case 'arraybuffer':
                    return cloneArrayBuffer(val);
                case 'float32array':
                case 'float64array':
                case 'int16array':
                case 'int32array':
                case 'int8array':
                case 'uint16array':
                case 'uint32array':
                case 'uint8clampedarray':
                case 'uint8array':
                    return cloneTypedArray(val);
                case 'regexp':
                    return cloneRegExp(val);
                case 'error':
                    return Object.create(val);
                default:
                    return val;
            }
        };
    },
    "../../node_modules/.pnpm/webpack-merge@6.0.1/node_modules/webpack-merge/dist/index.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var __read = this && this.__read || function(o, n) {
            var m = "function" == typeof Symbol && o[Symbol.iterator];
            if (!m) return o;
            var r, e, i = m.call(o), ar = [];
            try {
                for(; (void 0 === n || n-- > 0) && !(r = i.next()).done;)ar.push(r.value);
            } catch (error) {
                e = {
                    error: error
                };
            } finally{
                try {
                    r && !r.done && (m = i.return) && m.call(i);
                } finally{
                    if (e) throw e.error;
                }
            }
            return ar;
        }, __spreadArray = this && this.__spreadArray || function(to, from, pack) {
            if (pack || 2 == arguments.length) for(var ar, i = 0, l = from.length; i < l; i++)!ar && i in from || (ar || (ar = Array.prototype.slice.call(from, 0, i)), ar[i] = from[i]);
            return to.concat(ar || Array.prototype.slice.call(from));
        }, __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
                default: mod
            };
        };
        Object.defineProperty(exports1, "__esModule", {
            value: !0
        }), exports1.unique = exports1.mergeWithRules = exports1.mergeWithCustomize = exports1.default = exports1.merge = exports1.CustomizeRule = exports1.customizeObject = exports1.customizeArray = void 0;
        var wildcard_1 = __importDefault(__webpack_require__("../../node_modules/.pnpm/wildcard@2.0.1/node_modules/wildcard/index.js")), merge_with_1 = __importDefault(__webpack_require__("../../node_modules/.pnpm/webpack-merge@6.0.1/node_modules/webpack-merge/dist/merge-with.js")), join_arrays_1 = __importDefault(__webpack_require__("../../node_modules/.pnpm/webpack-merge@6.0.1/node_modules/webpack-merge/dist/join-arrays.js"));
        exports1.unique = __importDefault(__webpack_require__("../../node_modules/.pnpm/webpack-merge@6.0.1/node_modules/webpack-merge/dist/unique.js")).default;
        var types_1 = __webpack_require__("../../node_modules/.pnpm/webpack-merge@6.0.1/node_modules/webpack-merge/dist/types.js");
        Object.defineProperty(exports1, "CustomizeRule", {
            enumerable: !0,
            get: function() {
                return types_1.CustomizeRule;
            }
        });
        var utils_1 = __webpack_require__("../../node_modules/.pnpm/webpack-merge@6.0.1/node_modules/webpack-merge/dist/utils.js");
        function merge(firstConfiguration) {
            for(var configurations = [], _i = 1; _i < arguments.length; _i++)configurations[_i - 1] = arguments[_i];
            return mergeWithCustomize({}).apply(void 0, __spreadArray([
                firstConfiguration
            ], __read(configurations), !1));
        }
        function mergeWithCustomize(options) {
            return function mergeWithOptions(firstConfiguration) {
                for(var configurations = [], _i = 1; _i < arguments.length; _i++)configurations[_i - 1] = arguments[_i];
                if ((0, utils_1.isUndefined)(firstConfiguration) || configurations.some(utils_1.isUndefined)) throw TypeError("Merging undefined is not supported");
                if (firstConfiguration.then) throw TypeError("Promises are not supported");
                if (!firstConfiguration) return {};
                if (0 === configurations.length) {
                    if (Array.isArray(firstConfiguration)) {
                        if (0 === firstConfiguration.length) return {};
                        if (firstConfiguration.some(utils_1.isUndefined)) throw TypeError("Merging undefined is not supported");
                        if (firstConfiguration[0].then) throw TypeError("Promises are not supported");
                        return (0, merge_with_1.default)(firstConfiguration, (0, join_arrays_1.default)(options));
                    }
                    return firstConfiguration;
                }
                return (0, merge_with_1.default)([
                    firstConfiguration
                ].concat(configurations), (0, join_arrays_1.default)(options));
            };
        }
        exports1.merge = merge, exports1.default = merge, exports1.mergeWithCustomize = mergeWithCustomize, exports1.customizeArray = function customizeArray(rules) {
            return function(a, b, key) {
                var matchedRule = Object.keys(rules).find(function(rule) {
                    return (0, wildcard_1.default)(rule, key);
                }) || "";
                if (matchedRule) switch(rules[matchedRule]){
                    case types_1.CustomizeRule.Prepend:
                        return __spreadArray(__spreadArray([], __read(b), !1), __read(a), !1);
                    case types_1.CustomizeRule.Replace:
                        return b;
                    case types_1.CustomizeRule.Append:
                    default:
                        return __spreadArray(__spreadArray([], __read(a), !1), __read(b), !1);
                }
            };
        }, exports1.mergeWithRules = function mergeWithRules(rules) {
            return mergeWithCustomize({
                customizeArray: function(a, b, key) {
                    var currentRule = rules;
                    return (key.split(".").forEach(function(k) {
                        currentRule && (currentRule = currentRule[k]);
                    }), (0, utils_1.isPlainObject)(currentRule)) ? mergeWithRule({
                        currentRule: currentRule,
                        a: a,
                        b: b
                    }) : "string" == typeof currentRule ? mergeIndividualRule({
                        currentRule: currentRule,
                        a: a,
                        b: b
                    }) : void 0;
                }
            });
        };
        var isArray = Array.isArray;
        function mergeWithRule(_a) {
            var currentRule = _a.currentRule, a = _a.a, b = _a.b;
            if (!isArray(a)) return a;
            var bAllMatches = [];
            return a.map(function(ao) {
                if (!(0, utils_1.isPlainObject)(currentRule)) return ao;
                var ret = {}, rulesToMatch = [], operations = {};
                Object.entries(currentRule).forEach(function(_a) {
                    var _b = __read(_a, 2), k = _b[0], v = _b[1];
                    v === types_1.CustomizeRule.Match ? rulesToMatch.push(k) : operations[k] = v;
                });
                var bMatches = b.filter(function(o) {
                    var matches = rulesToMatch.every(function(rule) {
                        return (0, utils_1.isSameCondition)(ao[rule], o[rule]);
                    });
                    return matches && bAllMatches.push(o), matches;
                });
                return (0, utils_1.isPlainObject)(ao) ? (Object.entries(ao).forEach(function(_a) {
                    var _b = __read(_a, 2), k = _b[0], v = _b[1];
                    switch(currentRule[k]){
                        case types_1.CustomizeRule.Match:
                            ret[k] = v, Object.entries(currentRule).forEach(function(_a) {
                                var _b = __read(_a, 2), k = _b[0];
                                if (_b[1] === types_1.CustomizeRule.Replace && bMatches.length > 0) {
                                    var val = last(bMatches)[k];
                                    void 0 !== val && (ret[k] = val);
                                }
                            });
                            break;
                        case types_1.CustomizeRule.Append:
                            if (!bMatches.length) {
                                ret[k] = v;
                                break;
                            }
                            var appendValue = last(bMatches)[k];
                            if (!isArray(v) || !isArray(appendValue)) throw TypeError("Trying to append non-arrays");
                            ret[k] = v.concat(appendValue);
                            break;
                        case types_1.CustomizeRule.Merge:
                            if (!bMatches.length) {
                                ret[k] = v;
                                break;
                            }
                            var lastValue = last(bMatches)[k];
                            if (!(0, utils_1.isPlainObject)(v) || !(0, utils_1.isPlainObject)(lastValue)) throw TypeError("Trying to merge non-objects");
                            ret[k] = merge(v, lastValue);
                            break;
                        case types_1.CustomizeRule.Prepend:
                            if (!bMatches.length) {
                                ret[k] = v;
                                break;
                            }
                            var prependValue = last(bMatches)[k];
                            if (!isArray(v) || !isArray(prependValue)) throw TypeError("Trying to prepend non-arrays");
                            ret[k] = prependValue.concat(v);
                            break;
                        case types_1.CustomizeRule.Replace:
                            ret[k] = bMatches.length > 0 ? last(bMatches)[k] : v;
                            break;
                        default:
                            var currentRule_1 = operations[k], b_1 = bMatches.map(function(o) {
                                return o[k];
                            }).reduce(function(acc, val) {
                                return isArray(acc) && isArray(val) ? __spreadArray(__spreadArray([], __read(acc), !1), __read(val), !1) : acc;
                            }, []);
                            ret[k] = mergeWithRule({
                                currentRule: currentRule_1,
                                a: v,
                                b: b_1
                            });
                    }
                }), ret) : ao;
            }).concat(b.filter(function(o) {
                return !bAllMatches.includes(o);
            }));
        }
        function mergeIndividualRule(_a) {
            var currentRule = _a.currentRule, a = _a.a, b = _a.b;
            switch(currentRule){
                case types_1.CustomizeRule.Append:
                    return a.concat(b);
                case types_1.CustomizeRule.Prepend:
                    return b.concat(a);
                case types_1.CustomizeRule.Replace:
                    return b;
            }
            return a;
        }
        function last(arr) {
            return arr[arr.length - 1];
        }
        exports1.customizeObject = function customizeObject(rules) {
            return function(a, b, key) {
                switch(rules[key]){
                    case types_1.CustomizeRule.Prepend:
                        return (0, merge_with_1.default)([
                            b,
                            a
                        ], (0, join_arrays_1.default)());
                    case types_1.CustomizeRule.Replace:
                        return b;
                    case types_1.CustomizeRule.Append:
                        return (0, merge_with_1.default)([
                            a,
                            b
                        ], (0, join_arrays_1.default)());
                }
            };
        };
    },
    "../../node_modules/.pnpm/webpack-merge@6.0.1/node_modules/webpack-merge/dist/join-arrays.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var __read = this && this.__read || function(o, n) {
            var m = "function" == typeof Symbol && o[Symbol.iterator];
            if (!m) return o;
            var r, e, i = m.call(o), ar = [];
            try {
                for(; (void 0 === n || n-- > 0) && !(r = i.next()).done;)ar.push(r.value);
            } catch (error) {
                e = {
                    error: error
                };
            } finally{
                try {
                    r && !r.done && (m = i.return) && m.call(i);
                } finally{
                    if (e) throw e.error;
                }
            }
            return ar;
        }, __spreadArray = this && this.__spreadArray || function(to, from, pack) {
            if (pack || 2 == arguments.length) for(var ar, i = 0, l = from.length; i < l; i++)!ar && i in from || (ar || (ar = Array.prototype.slice.call(from, 0, i)), ar[i] = from[i]);
            return to.concat(ar || Array.prototype.slice.call(from));
        }, __importDefault = this && this.__importDefault || function(mod) {
            return mod && mod.__esModule ? mod : {
                default: mod
            };
        };
        Object.defineProperty(exports1, "__esModule", {
            value: !0
        });
        var clone_deep_1 = __importDefault(__webpack_require__("../../node_modules/.pnpm/clone-deep@4.0.1/node_modules/clone-deep/index.js")), merge_with_1 = __importDefault(__webpack_require__("../../node_modules/.pnpm/webpack-merge@6.0.1/node_modules/webpack-merge/dist/merge-with.js")), utils_1 = __webpack_require__("../../node_modules/.pnpm/webpack-merge@6.0.1/node_modules/webpack-merge/dist/utils.js"), isArray = Array.isArray;
        function joinArrays(_a) {
            var _b = void 0 === _a ? {} : _a, customizeArray = _b.customizeArray, customizeObject = _b.customizeObject, key = _b.key;
            return function _joinArrays(a, b, k) {
                var newKey = key ? "".concat(key, ".").concat(k) : k;
                if ((0, utils_1.isFunction)(a) && (0, utils_1.isFunction)(b)) return function() {
                    for(var args = [], _i = 0; _i < arguments.length; _i++)args[_i] = arguments[_i];
                    return _joinArrays(a.apply(void 0, __spreadArray([], __read(args), !1)), b.apply(void 0, __spreadArray([], __read(args), !1)), k);
                };
                if (isArray(a) && isArray(b)) {
                    var customResult = customizeArray && customizeArray(a, b, newKey);
                    return customResult || __spreadArray(__spreadArray([], __read(a), !1), __read(b), !1);
                }
                if ((0, utils_1.isRegex)(b)) return b;
                if ((0, utils_1.isPlainObject)(a) && (0, utils_1.isPlainObject)(b)) {
                    var customResult = customizeObject && customizeObject(a, b, newKey);
                    return customResult || (0, merge_with_1.default)([
                        a,
                        b
                    ], joinArrays({
                        customizeArray: customizeArray,
                        customizeObject: customizeObject,
                        key: newKey
                    }));
                }
                return (0, utils_1.isPlainObject)(b) ? (0, clone_deep_1.default)(b) : isArray(b) ? __spreadArray([], __read(b), !1) : b;
            };
        }
        exports1.default = joinArrays;
    },
    "../../node_modules/.pnpm/webpack-merge@6.0.1/node_modules/webpack-merge/dist/merge-with.js": function(__unused_webpack_module, exports1) {
        "use strict";
        var __read = this && this.__read || function(o, n) {
            var m = "function" == typeof Symbol && o[Symbol.iterator];
            if (!m) return o;
            var r, e, i = m.call(o), ar = [];
            try {
                for(; (void 0 === n || n-- > 0) && !(r = i.next()).done;)ar.push(r.value);
            } catch (error) {
                e = {
                    error: error
                };
            } finally{
                try {
                    r && !r.done && (m = i.return) && m.call(i);
                } finally{
                    if (e) throw e.error;
                }
            }
            return ar;
        };
        function mergeTo(a, b, customizer) {
            var ret = {};
            return Object.keys(a).concat(Object.keys(b)).forEach(function(k) {
                var v = customizer(a[k], b[k], k);
                ret[k] = void 0 === v ? a[k] : v;
            }), ret;
        }
        Object.defineProperty(exports1, "__esModule", {
            value: !0
        }), exports1.default = function mergeWith(objects, customizer) {
            var _a = __read(objects), first = _a[0], rest = _a.slice(1), ret = first;
            return rest.forEach(function(a) {
                ret = mergeTo(ret, a, customizer);
            }), ret;
        };
    },
    "../../node_modules/.pnpm/webpack-merge@6.0.1/node_modules/webpack-merge/dist/types.js": function(__unused_webpack_module, exports1) {
        "use strict";
        var CustomizeRule, CustomizeRule1;
        Object.defineProperty(exports1, "__esModule", {
            value: !0
        }), exports1.CustomizeRule = void 0, (CustomizeRule1 = CustomizeRule || (exports1.CustomizeRule = CustomizeRule = {})).Match = "match", CustomizeRule1.Merge = "merge", CustomizeRule1.Append = "append", CustomizeRule1.Prepend = "prepend", CustomizeRule1.Replace = "replace";
    },
    "../../node_modules/.pnpm/webpack-merge@6.0.1/node_modules/webpack-merge/dist/unique.js": function(__unused_webpack_module, exports1) {
        "use strict";
        var __read = this && this.__read || function(o, n) {
            var m = "function" == typeof Symbol && o[Symbol.iterator];
            if (!m) return o;
            var r, e, i = m.call(o), ar = [];
            try {
                for(; (void 0 === n || n-- > 0) && !(r = i.next()).done;)ar.push(r.value);
            } catch (error) {
                e = {
                    error: error
                };
            } finally{
                try {
                    r && !r.done && (m = i.return) && m.call(i);
                } finally{
                    if (e) throw e.error;
                }
            }
            return ar;
        }, __spreadArray = this && this.__spreadArray || function(to, from, pack) {
            if (pack || 2 == arguments.length) for(var ar, i = 0, l = from.length; i < l; i++)!ar && i in from || (ar || (ar = Array.prototype.slice.call(from, 0, i)), ar[i] = from[i]);
            return to.concat(ar || Array.prototype.slice.call(from));
        };
        Object.defineProperty(exports1, "__esModule", {
            value: !0
        }), exports1.default = function mergeUnique(key, uniques, getter) {
            var uniquesSet = new Set(uniques);
            return function(a, b, k) {
                return k === key && Array.from(__spreadArray(__spreadArray([], __read(a), !1), __read(b), !1).map(function(it) {
                    return {
                        key: getter(it),
                        value: it
                    };
                }).map(function(_a) {
                    var key = _a.key, value = _a.value;
                    return {
                        key: uniquesSet.has(key) ? key : value,
                        value: value
                    };
                }).reduce(function(m, _a) {
                    var key = _a.key, value = _a.value;
                    return m.delete(key), m.set(key, value);
                }, new Map()).values());
            };
        };
    },
    "../../node_modules/.pnpm/webpack-merge@6.0.1/node_modules/webpack-merge/dist/utils.js": function(__unused_webpack_module, exports1, __webpack_require__) {
        "use strict";
        var __read = this && this.__read || function(o, n) {
            var m = "function" == typeof Symbol && o[Symbol.iterator];
            if (!m) return o;
            var r, e, i = m.call(o), ar = [];
            try {
                for(; (void 0 === n || n-- > 0) && !(r = i.next()).done;)ar.push(r.value);
            } catch (error) {
                e = {
                    error: error
                };
            } finally{
                try {
                    r && !r.done && (m = i.return) && m.call(i);
                } finally{
                    if (e) throw e.error;
                }
            }
            return ar;
        };
        Object.defineProperty(exports1, "__esModule", {
            value: !0
        }), exports1.isSameCondition = exports1.isUndefined = exports1.isPlainObject = exports1.isFunction = exports1.isRegex = void 0;
        var flat_1 = __webpack_require__("../../node_modules/.pnpm/flat@5.0.2/node_modules/flat/index.js");
        function isRegex(o) {
            return o instanceof RegExp;
        }
        function isFunction(functionToCheck) {
            return functionToCheck && "[object Function]" === ({}).toString.call(functionToCheck);
        }
        exports1.isRegex = isRegex, exports1.isFunction = isFunction, exports1.isPlainObject = function isPlainObject(a) {
            return !(null === a || Array.isArray(a)) && "object" == typeof a;
        }, exports1.isUndefined = function isUndefined(a) {
            return void 0 === a;
        }, exports1.isSameCondition = function isSameCondition(a, b) {
            if (!a || !b) return a === b;
            if ("string" == typeof a || "string" == typeof b || isRegex(a) || isRegex(b) || isFunction(a) || isFunction(b)) return a.toString() === b.toString();
            var _a, _b, entriesA = Object.entries((0, flat_1.flatten)(a)), entriesB = Object.entries((0, flat_1.flatten)(b));
            if (entriesA.length !== entriesB.length) return !1;
            for(var i = 0; i < entriesA.length; i++)entriesA[i][0] = entriesA[i][0].replace(/\b\d+\b/g, "[]"), entriesB[i][0] = entriesB[i][0].replace(/\b\d+\b/g, "[]");
            function cmp(_a, _b) {
                var _c = __read(_a, 2), k1 = _c[0], v1 = _c[1], _d = __read(_b, 2), k2 = _d[0], v2 = _d[1];
                return k1 < k2 ? -1 : k1 > k2 ? 1 : v1 < v2 ? -1 : +(v1 > v2);
            }
            if (entriesA.sort(cmp), entriesB.sort(cmp), entriesA.length !== entriesB.length) return !1;
            for(var i = 0; i < entriesA.length; i++)if (entriesA[i][0] !== entriesB[i][0] || (null == (_a = entriesA[i][1]) ? void 0 : _a.toString()) !== (null == (_b = entriesB[i][1]) ? void 0 : _b.toString())) return !1;
            return !0;
        };
    },
    "../../node_modules/.pnpm/wildcard@2.0.1/node_modules/wildcard/index.js": function(module) {
        "use strict";
        var REGEXP_PARTS = /(\*|\?)/g;
        function WildcardMatcher(text, separator) {
            this.text = text = text || '', this.hasWild = text.indexOf('*') >= 0, this.separator = separator, this.parts = text.split(separator).map(this.classifyPart.bind(this));
        }
        WildcardMatcher.prototype.match = function(input) {
            var ii, testParts, matches = !0, parts = this.parts, partsCount = parts.length;
            if ('string' == typeof input || input instanceof String) if (this.hasWild || this.text == input) {
                for(ii = 0, testParts = (input || '').split(this.separator); matches && ii < partsCount; ii++)if ('*' === parts[ii]) continue;
                else matches = ii < testParts.length && (parts[ii] instanceof RegExp ? parts[ii].test(testParts[ii]) : parts[ii] === testParts[ii]);
                matches = matches && testParts;
            } else matches = !1;
            else if ('function' == typeof input.splice) for(matches = [], ii = input.length; ii--;)this.match(input[ii]) && (matches[matches.length] = input[ii]);
            else if ('object' == typeof input) for(var key in matches = {}, input)this.match(key) && (matches[key] = input[key]);
            return matches;
        }, WildcardMatcher.prototype.classifyPart = function(part) {
            if ('*' === part) ;
            else if (part.indexOf('*') >= 0 || part.indexOf('?') >= 0) return new RegExp(part.replace(REGEXP_PARTS, '\.$1'));
            return part;
        }, module.exports = function(text, test, separator) {
            var matcher = new WildcardMatcher(text, separator || /[\/\.]/);
            return void 0 !== test ? matcher.match(test) : matcher;
        };
    },
    async_hooks: function(module) {
        "use strict";
        module.exports = require("async_hooks");
    },
    fs: function(module) {
        "use strict";
        module.exports = require("fs");
    },
    "node:buffer": function(module) {
        "use strict";
        module.exports = require("node:buffer");
    },
    "node:child_process": function(module) {
        "use strict";
        module.exports = require("node:child_process");
    },
    "node:fs": function(module) {
        "use strict";
        module.exports = require("node:fs");
    },
    "node:fs/promises": function(module) {
        "use strict";
        module.exports = require("node:fs/promises");
    },
    "node:module": function(module) {
        "use strict";
        module.exports = require("node:module");
    },
    "node:os": function(module) {
        "use strict";
        module.exports = require("node:os");
    },
    "node:path": function(module) {
        "use strict";
        module.exports = require("node:path");
    },
    "node:process": function(module) {
        "use strict";
        module.exports = require("node:process");
    },
    "node:url": function(module) {
        "use strict";
        module.exports = require("node:url");
    },
    "node:util": function(module) {
        "use strict";
        module.exports = require("node:util");
    },
    os: function(module) {
        "use strict";
        module.exports = require("os");
    },
    path: function(module) {
        "use strict";
        module.exports = require("path");
    },
    url: function(module) {
        "use strict";
        module.exports = require("url");
    }
}, __webpack_module_cache__ = {};
function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    var module = __webpack_module_cache__[moduleId] = {
        exports: {}
    };
    return __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.exports;
}
__webpack_require__.m = __webpack_modules__, __webpack_require__.n = (module)=>{
    var getter = module && module.__esModule ? ()=>module.default : ()=>module;
    return __webpack_require__.d(getter, {
        a: getter
    }), getter;
}, (()=>{
    var leafPrototypes, getProto = Object.getPrototypeOf ? (obj)=>Object.getPrototypeOf(obj) : (obj)=>obj.__proto__;
    __webpack_require__.t = function(value, mode) {
        if (1 & mode && (value = this(value)), 8 & mode || 'object' == typeof value && value && (4 & mode && value.__esModule || 16 & mode && 'function' == typeof value.then)) return value;
        var ns = Object.create(null);
        __webpack_require__.r(ns);
        var def = {};
        leafPrototypes = leafPrototypes || [
            null,
            getProto({}),
            getProto([]),
            getProto(getProto)
        ];
        for(var current = 2 & mode && value; ('object' == typeof current || 'function' == typeof current) && !~leafPrototypes.indexOf(current); current = getProto(current))Object.getOwnPropertyNames(current).forEach((key)=>{
            def[key] = ()=>value[key];
        });
        return def.default = ()=>value, __webpack_require__.d(ns, def), ns;
    };
})(), __webpack_require__.d = (exports1, definition)=>{
    for(var key in definition)__webpack_require__.o(definition, key) && !__webpack_require__.o(exports1, key) && Object.defineProperty(exports1, key, {
        enumerable: !0,
        get: definition[key]
    });
}, __webpack_require__.f = {}, __webpack_require__.e = (chunkId)=>Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key)=>(__webpack_require__.f[key](chunkId, promises), promises), [])), __webpack_require__.u = (chunkId)=>"2~" + ({
        603: "range-parser",
        664: "open"
    })[chunkId] + ".cjs", __webpack_require__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop), __webpack_require__.r = (exports1)=>{
    'undefined' != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports1, Symbol.toStringTag, {
        value: 'Module'
    }), Object.defineProperty(exports1, '__esModule', {
        value: !0
    });
}, (()=>{
    var installedChunks = {
        410: 1
    };
    __webpack_require__.f.require = (chunkId, promises)=>{
        installedChunks[chunkId] || ((chunk)=>{
            var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
            for(var moduleId in moreModules)__webpack_require__.o(moreModules, moduleId) && (__webpack_require__.m[moduleId] = moreModules[moduleId]);
            runtime && runtime(__webpack_require__);
            for(var i = 0; i < chunkIds.length; i++)installedChunks[chunkIds[i]] = 1;
        })(require("./" + __webpack_require__.u(chunkId)));
    };
})();
var __webpack_exports__ = {};
for(var __webpack_i__ in (()=>{
    "use strict";
    let swcHelpersPath, pluginHelper_htmlPlugin, cssExtractPlugin, hmrClientPath, overlayClientPath;
    __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, {
        PLUGIN_SWC_NAME: ()=>PLUGIN_SWC_NAME,
        ensureAssetPrefix: ()=>ensureAssetPrefix,
        loadConfig: ()=>loadConfig_loadConfig,
        createRsbuild: ()=>createRsbuild,
        logger: ()=>logger,
        version: ()=>src_version,
        loadEnv: ()=>loadEnv,
        PLUGIN_CSS_NAME: ()=>PLUGIN_CSS_NAME,
        runCLI: ()=>runCLI,
        rspack: ()=>rspack_rspack,
        defineConfig: ()=>defineConfig,
        mergeRsbuildConfig: ()=>mergeRsbuildConfig,
        defaultAllowedOrigins: ()=>defaultAllowedOrigins
    });
    var superClass, superClass1, provider_helpers_namespaceObject = {};
    __webpack_require__.r(provider_helpers_namespaceObject), __webpack_require__.d(provider_helpers_namespaceObject, {
        createDevServer: ()=>devServer_createDevServer,
        formatStats: ()=>formatStats,
        getChainUtils: ()=>getChainUtils,
        getConfigUtils: ()=>getConfigUtils,
        getHTMLPlugin: ()=>pluginHelper_getHTMLPlugin,
        getRsbuildStats: ()=>getRsbuildStats,
        initRsbuildConfig: ()=>initRsbuildConfig,
        inspectConfig: ()=>inspectConfig_inspectConfig,
        modifyBundlerChain: ()=>modifyBundlerChain,
        prettyTime: ()=>prettyTime,
        registerBuildHook: ()=>registerBuildHook,
        registerDevHook: ()=>registerDevHook,
        setCssExtractPlugin: ()=>setCssExtractPlugin,
        setHTMLPlugin: ()=>setHTMLPlugin
    });
    var external_node_module_ = __webpack_require__("node:module");
    let rspack_rspack = (0, external_node_module_.createRequire)(__rslib_import_meta_url__)('@rspack/core');
    var external_node_path_ = __webpack_require__("node:path"), external_node_path_default = __webpack_require__.n(external_node_path_), external_node_url_ = __webpack_require__("node:url");
    let constants_filename = (0, external_node_url_.fileURLToPath)(__rslib_import_meta_url__), constants_dirname = (0, external_node_path_.dirname)(constants_filename), isDeno = 'undefined' != typeof Deno, isWindows = 'win32' === process.platform, ROOT_DIST_DIR = 'dist', LOADER_PATH = (0, external_node_path_.join)(constants_dirname), STATIC_PATH = (0, external_node_path_.join)(constants_dirname, '../static'), COMPILED_PATH = (0, external_node_path_.join)(constants_dirname, '../compiled'), RSBUILD_OUTPUTS_PATH = '.rsbuild', DEFAULT_DEV_HOST = '0.0.0.0', DEFAULT_ASSET_PREFIX = '/', DEFAULT_WEB_BROWSERSLIST = [
        'chrome >= 87',
        'edge >= 88',
        'firefox >= 78',
        'safari >= 14'
    ], DEFAULT_BROWSERSLIST = {
        web: DEFAULT_WEB_BROWSERSLIST,
        'web-worker': DEFAULT_WEB_BROWSERSLIST,
        node: [
            'node >= 16'
        ]
    }, JS_REGEX = /\.(?:js|mjs|cjs|jsx)$/, SCRIPT_REGEX = /\.(?:js|jsx|mjs|cjs|ts|tsx|mts|cts)$/, CSS_REGEX = /\.css$/, RAW_QUERY_REGEX = /[?&]raw(?:&|=|$)/, INLINE_QUERY_REGEX = /[?&]inline(?:&|=|$)/, NODE_MODULES_REGEX = /[\\/]node_modules[\\/]/, PLUGIN_SWC_NAME = 'rsbuild:swc', PLUGIN_CSS_NAME = 'rsbuild:css', FONT_EXTENSIONS = [
        'woff',
        'woff2',
        'eot',
        'ttf',
        'otf',
        'ttc'
    ], IMAGE_EXTENSIONS = [
        'png',
        'jpg',
        'jpeg',
        'pjpeg',
        'pjp',
        'gif',
        'bmp',
        'webp',
        'ico',
        'apng',
        'avif',
        'tif',
        'tiff',
        'jfif',
        'cur'
    ], VIDEO_EXTENSIONS = [
        'mp4',
        'webm',
        'ogg',
        'mov'
    ], AUDIO_EXTENSIONS = [
        'mp3',
        'wav',
        'flac',
        'aac',
        'm4a',
        'opus'
    ], vendors_require = (0, external_node_module_.createRequire)(__rslib_import_meta_url__), requireCompiledPackage = (name)=>vendors_require(`${COMPILED_PATH}/${name}/index.js`), color = requireCompiledPackage('picocolors'), logger = requireCompiledPackage('rslog').logger, isDebug = ()=>{
        if (!process.env.DEBUG) return !1;
        let values = process.env.DEBUG.toLocaleLowerCase().split(',');
        return [
            'rsbuild',
            'builder',
            '*'
        ].some((key)=>values.includes(key));
    };
    function getTime() {
        let now = new Date(), hours = String(now.getHours()).padStart(2, '0'), minutes = String(now.getMinutes()).padStart(2, '0'), seconds = String(now.getSeconds()).padStart(2, '0');
        return `${hours}:${minutes}:${seconds}`;
    }
    isDebug() && (logger.level = 'verbose'), logger.override({
        debug: (message, ...args)=>{
            if ('verbose' !== logger.level) return;
            let time = color.gray(getTime());
            console.log(`  ${color.magenta('rsbuild')} ${time} ${message}`, ...args);
        }
    });
    let external_events_namespaceObject = require("events");
    function toArr(any) {
        return null == any ? [] : Array.isArray(any) ? any : [
            any
        ];
    }
    function toVal(out, key, val, opts) {
        var x, old = out[key], nxt = ~opts.string.indexOf(key) ? null == val || !0 === val ? '' : String(val) : 'boolean' == typeof val ? val : ~opts.boolean.indexOf(key) ? 'false' !== val && ('true' === val || (out._.push(0 * (x = +val) == 0 ? x : val), !!val)) : 0 * (x = +val) == 0 ? x : val;
        out[key] = null == old ? nxt : Array.isArray(old) ? old.concat(nxt) : [
            old,
            nxt
        ];
    }
    function mri2(args, opts) {
        opts = opts || {};
        var k, arr, arg, name, val, out = {
            _: []
        }, i = 0, j = 0, idx = 0, len = (args = args || []).length;
        let alibi = void 0 !== opts.alias, strict = void 0 !== opts.unknown, defaults = void 0 !== opts.default;
        if (opts.alias = opts.alias || {}, opts.string = toArr(opts.string), opts.boolean = toArr(opts.boolean), alibi) for(k in opts.alias)for(i = 0, arr = opts.alias[k] = toArr(opts.alias[k]); i < arr.length; i++)(opts.alias[arr[i]] = arr.concat(k)).splice(i, 1);
        for(i = opts.boolean.length; i-- > 0;)for(j = (arr = opts.alias[opts.boolean[i]] || []).length; j-- > 0;)opts.boolean.push(arr[j]);
        for(i = opts.string.length; i-- > 0;)for(j = (arr = opts.alias[opts.string[i]] || []).length; j-- > 0;)opts.string.push(arr[j]);
        if (defaults) {
            for(k in opts.default)if (name = typeof opts.default[k], arr = opts.alias[k] = opts.alias[k] || [], void 0 !== opts[name]) for(opts[name].push(k), i = 0; i < arr.length; i++)opts[name].push(arr[i]);
        }
        let keys = strict ? Object.keys(opts.alias) : [];
        for(i = 0; i < len; i++){
            if ('--' === (arg = args[i])) {
                out._ = out._.concat(args.slice(++i));
                break;
            }
            for(j = 0; j < arg.length && 45 === arg.charCodeAt(j); j++);
            if (0 === j) out._.push(arg);
            else if ('no-' === arg.substring(j, j + 3)) {
                if (name = arg.substring(j + 3), strict && !~keys.indexOf(name)) return opts.unknown(arg);
                out[name] = !1;
            } else {
                for(idx = j + 1; idx < arg.length && 61 !== arg.charCodeAt(idx); idx++);
                for(name = arg.substring(j, idx), val = arg.substring(++idx) || i + 1 === len || 45 === ('' + args[i + 1]).charCodeAt(0) || args[++i], arr = 2 === j ? [
                    name
                ] : name, idx = 0; idx < arr.length; idx++){
                    if (name = arr[idx], strict && !~keys.indexOf(name)) return opts.unknown('-'.repeat(j) + name);
                    toVal(out, name, idx + 1 < arr.length || val, opts);
                }
            }
        }
        if (defaults) for(k in opts.default)void 0 === out[k] && (out[k] = opts.default[k]);
        if (alibi) for(k in out)for(arr = opts.alias[k] || []; arr.length > 0;)out[arr.shift()] = out[k];
        return out;
    }
    let removeBrackets = (v)=>v.replace(/[<[].+/, "").trim(), findLongest = (arr)=>arr.sort((a, b)=>a.length > b.length ? -1 : 1)[0], padRight = (str, length)=>str.length >= length ? str : `${str}${" ".repeat(length - str.length)}`, setDotProp = (obj, keys, val)=>{
        let x, i = 0, length = keys.length, t = obj;
        for(; i < length; ++i)x = t[keys[i]], t = t[keys[i]] = i === length - 1 ? val : null != x ? x : ~keys[i + 1].indexOf(".") || !(+keys[i + 1] > -1) ? {} : [];
    }, setByType = (obj, transforms)=>{
        for (let key of Object.keys(transforms)){
            let transform = transforms[key];
            transform.shouldTransform && (obj[key] = Array.prototype.concat.call([], obj[key]), "function" == typeof transform.transformFunction && (obj[key] = obj[key].map(transform.transformFunction)));
        }
    }, camelcaseOptionName = (name)=>name.split(".").map((v, i)=>0 === i ? v.replace(/([a-z])-([a-z])/g, (_, p1, p2)=>p1 + p2.toUpperCase()) : v).join(".");
    class CACError extends Error {
        constructor(message){
            super(message), this.name = this.constructor.name, "function" == typeof Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = Error(message).stack;
        }
    }
    class Option {
        constructor(rawName, description, config){
            this.rawName = rawName, this.description = description, this.config = Object.assign({}, config), rawName = rawName.replace(/\.\*/g, ""), this.negated = !1, this.names = removeBrackets(rawName).split(",").map((v)=>{
                let name = v.trim().replace(/^-{1,2}/, "");
                return name.startsWith("no-") && (this.negated = !0, name = name.replace(/^no-/, "")), camelcaseOptionName(name);
            }).sort((a, b)=>a.length > b.length ? 1 : -1), this.name = this.names[this.names.length - 1], this.negated && null == this.config.default && (this.config.default = !0), rawName.includes("<") ? this.required = !0 : rawName.includes("[") ? this.required = !1 : this.isBoolean = !0;
        }
    }
    let processArgs = process.argv, platformInfo = `${process.platform}-${process.arch} node-${process.version}`;
    class Command {
        constructor(rawName, description, config = {}, cli){
            this.rawName = rawName, this.description = description, this.config = config, this.cli = cli, this.options = [], this.aliasNames = [], this.name = removeBrackets(rawName), this.args = ((v)=>{
                let angledMatch, squareMatch, ANGLED_BRACKET_RE_GLOBAL = /<([^>]+)>/g, SQUARE_BRACKET_RE_GLOBAL = /\[([^\]]+)\]/g, res = [], parse = (match)=>{
                    let variadic = !1, value = match[1];
                    return value.startsWith("...") && (value = value.slice(3), variadic = !0), {
                        required: match[0].startsWith("<"),
                        value,
                        variadic
                    };
                };
                for(; angledMatch = ANGLED_BRACKET_RE_GLOBAL.exec(v);)res.push(parse(angledMatch));
                for(; squareMatch = SQUARE_BRACKET_RE_GLOBAL.exec(v);)res.push(parse(squareMatch));
                return res;
            })(rawName), this.examples = [];
        }
        usage(text) {
            return this.usageText = text, this;
        }
        allowUnknownOptions() {
            return this.config.allowUnknownOptions = !0, this;
        }
        ignoreOptionDefaultValue() {
            return this.config.ignoreOptionDefaultValue = !0, this;
        }
        version(version, customFlags = "-v, --version") {
            return this.versionNumber = version, this.option(customFlags, "Display version number"), this;
        }
        example(example) {
            return this.examples.push(example), this;
        }
        option(rawName, description, config) {
            let option = new Option(rawName, description, config);
            return this.options.push(option), this;
        }
        alias(name) {
            return this.aliasNames.push(name), this;
        }
        action(callback) {
            return this.commandAction = callback, this;
        }
        isMatched(name) {
            return this.name === name || this.aliasNames.includes(name);
        }
        get isDefaultCommand() {
            return "" === this.name || this.aliasNames.includes("!");
        }
        get isGlobalCommand() {
            return this instanceof GlobalCommand;
        }
        hasOption(name) {
            return name = name.split(".")[0], this.options.find((option)=>option.names.includes(name));
        }
        outputHelp() {
            let { name, commands } = this.cli, { versionNumber, options: globalOptions, helpCallback } = this.cli.globalCommand, sections = [
                {
                    body: `${name}${versionNumber ? `/${versionNumber}` : ""}`
                }
            ];
            if (sections.push({
                title: "Usage",
                body: `  $ ${name} ${this.usageText || this.rawName}`
            }), (this.isGlobalCommand || this.isDefaultCommand) && commands.length > 0) {
                let longestCommandName = findLongest(commands.map((command)=>command.rawName));
                sections.push({
                    title: "Commands",
                    body: commands.map((command)=>`  ${padRight(command.rawName, longestCommandName.length)}  ${command.description}`).join("\n")
                }), sections.push({
                    title: "For more info, run any command with the `--help` flag",
                    body: commands.map((command)=>`  $ ${name}${"" === command.name ? "" : ` ${command.name}`} --help`).join("\n")
                });
            }
            let options = this.isGlobalCommand ? globalOptions : [
                ...this.options,
                ...globalOptions || []
            ];
            if (this.isGlobalCommand || this.isDefaultCommand || (options = options.filter((option)=>"version" !== option.name)), options.length > 0) {
                let longestOptionName = findLongest(options.map((option)=>option.rawName));
                sections.push({
                    title: "Options",
                    body: options.map((option)=>`  ${padRight(option.rawName, longestOptionName.length)}  ${option.description} ${void 0 === option.config.default ? "" : `(default: ${option.config.default})`}`).join("\n")
                });
            }
            this.examples.length > 0 && sections.push({
                title: "Examples",
                body: this.examples.map((example)=>"function" == typeof example ? example(name) : example).join("\n")
            }), helpCallback && (sections = helpCallback(sections) || sections), console.log(sections.map((section)=>section.title ? `${section.title}:
${section.body}` : section.body).join("\n\n"));
        }
        outputVersion() {
            let { name } = this.cli, { versionNumber } = this.cli.globalCommand;
            versionNumber && console.log(`${name}/${versionNumber} ${platformInfo}`);
        }
        checkRequiredArgs() {
            let minimalArgsCount = this.args.filter((arg)=>arg.required).length;
            if (this.cli.args.length < minimalArgsCount) throw new CACError(`missing required args for command \`${this.rawName}\``);
        }
        checkUnknownOptions() {
            let { options, globalCommand } = this.cli;
            if (!this.config.allowUnknownOptions) {
                for (let name of Object.keys(options))if ("--" !== name && !this.hasOption(name) && !globalCommand.hasOption(name)) throw new CACError(`Unknown option \`${name.length > 1 ? `--${name}` : `-${name}`}\``);
            }
        }
        checkOptionValue() {
            let { options: parsedOptions, globalCommand } = this.cli, options = [
                ...globalCommand.options,
                ...this.options
            ];
            for (let option of options){
                let value = parsedOptions[option.name.split(".")[0]];
                if (option.required) {
                    let hasNegated = options.some((o)=>o.negated && o.names.includes(option.name));
                    if (!0 === value || !1 === value && !hasNegated) throw new CACError(`option \`${option.rawName}\` value is missing`);
                }
            }
        }
    }
    class GlobalCommand extends Command {
        constructor(cli){
            super("@@global@@", "", {}, cli);
        }
    }
    var __assign = Object.assign;
    class CAC extends external_events_namespaceObject.EventEmitter {
        constructor(name = ""){
            super(), this.name = name, this.commands = [], this.rawArgs = [], this.args = [], this.options = {}, this.globalCommand = new GlobalCommand(this), this.globalCommand.usage("<command> [options]");
        }
        usage(text) {
            return this.globalCommand.usage(text), this;
        }
        command(rawName, description, config) {
            let command = new Command(rawName, description || "", config, this);
            return command.globalCommand = this.globalCommand, this.commands.push(command), command;
        }
        option(rawName, description, config) {
            return this.globalCommand.option(rawName, description, config), this;
        }
        help(callback) {
            return this.globalCommand.option("-h, --help", "Display this message"), this.globalCommand.helpCallback = callback, this.showHelpOnExit = !0, this;
        }
        version(version, customFlags = "-v, --version") {
            return this.globalCommand.version(version, customFlags), this.showVersionOnExit = !0, this;
        }
        example(example) {
            return this.globalCommand.example(example), this;
        }
        outputHelp() {
            this.matchedCommand ? this.matchedCommand.outputHelp() : this.globalCommand.outputHelp();
        }
        outputVersion() {
            this.globalCommand.outputVersion();
        }
        setParsedInfo({ args, options }, matchedCommand, matchedCommandName) {
            return this.args = args, this.options = options, matchedCommand && (this.matchedCommand = matchedCommand), matchedCommandName && (this.matchedCommandName = matchedCommandName), this;
        }
        unsetMatchedCommand() {
            this.matchedCommand = void 0, this.matchedCommandName = void 0;
        }
        parse(argv = processArgs, { run = !0 } = {}) {
            var input;
            let m;
            this.rawArgs = argv, this.name || (this.name = argv[1] ? (input = argv[1], (m = /([^\\\/]+)$/.exec(input)) ? m[1] : "") : "cli");
            let shouldParse = !0;
            for (let command of this.commands){
                let parsed = this.mri(argv.slice(2), command), commandName = parsed.args[0];
                if (command.isMatched(commandName)) {
                    shouldParse = !1;
                    let parsedInfo = __assign(__assign({}, parsed), {
                        args: parsed.args.slice(1)
                    });
                    this.setParsedInfo(parsedInfo, command, commandName), this.emit(`command:${commandName}`, command);
                }
            }
            if (shouldParse) {
                for (let command of this.commands)if ("" === command.name) {
                    shouldParse = !1;
                    let parsed = this.mri(argv.slice(2), command);
                    this.setParsedInfo(parsed, command), this.emit("command:!", command);
                }
            }
            if (shouldParse) {
                let parsed = this.mri(argv.slice(2));
                this.setParsedInfo(parsed);
            }
            this.options.help && this.showHelpOnExit && (this.outputHelp(), run = !1, this.unsetMatchedCommand()), this.options.version && this.showVersionOnExit && null == this.matchedCommandName && (this.outputVersion(), run = !1, this.unsetMatchedCommand());
            let parsedArgv = {
                args: this.args,
                options: this.options
            };
            return run && this.runMatchedCommand(), !this.matchedCommand && this.args[0] && this.emit("command:*"), parsedArgv;
        }
        mri(argv, command) {
            let cliOptions = [
                ...this.globalCommand.options,
                ...command ? command.options : []
            ], mriOptions = ((options)=>{
                let result = {
                    alias: {},
                    boolean: []
                };
                for (let [index, option] of options.entries())option.names.length > 1 && (result.alias[option.names[0]] = option.names.slice(1)), option.isBoolean && (option.negated && options.some((o, i)=>i !== index && o.names.some((name)=>option.names.includes(name)) && "boolean" == typeof o.required) || result.boolean.push(option.names[0]));
                return result;
            })(cliOptions), argsAfterDoubleDashes = [], doubleDashesIndex = argv.indexOf("--");
            doubleDashesIndex > -1 && (argsAfterDoubleDashes = argv.slice(doubleDashesIndex + 1), argv = argv.slice(0, doubleDashesIndex));
            let parsed = mri2(argv, mriOptions), args = (parsed = Object.keys(parsed).reduce((res, name)=>__assign(__assign({}, res), {
                    [camelcaseOptionName(name)]: parsed[name]
                }), {
                _: []
            }))._, options = {
                "--": argsAfterDoubleDashes
            }, ignoreDefault = command && command.config.ignoreOptionDefaultValue ? command.config.ignoreOptionDefaultValue : this.globalCommand.config.ignoreOptionDefaultValue, transforms = Object.create(null);
            for (let cliOption of cliOptions){
                if (!ignoreDefault && void 0 !== cliOption.config.default) for (let name of cliOption.names)options[name] = cliOption.config.default;
                Array.isArray(cliOption.config.type) && void 0 === transforms[cliOption.name] && (transforms[cliOption.name] = Object.create(null), transforms[cliOption.name].shouldTransform = !0, transforms[cliOption.name].transformFunction = cliOption.config.type[0]);
            }
            for (let key of Object.keys(parsed))"_" !== key && (setDotProp(options, key.split("."), parsed[key]), setByType(options, transforms));
            return {
                args,
                options
            };
        }
        runMatchedCommand() {
            let { args, options, matchedCommand: command } = this;
            if (!command || !command.commandAction) return;
            command.checkUnknownOptions(), command.checkOptionValue(), command.checkRequiredArgs();
            let actionArgs = [];
            return command.args.forEach((arg, index)=>{
                arg.variadic ? actionArgs.push(args.slice(index)) : actionArgs.push(args[index]);
            }), actionArgs.push(options), command.commandAction.apply(this, actionArgs);
        }
    }
    var cjs = __webpack_require__("../../node_modules/.pnpm/deepmerge@4.3.1/node_modules/deepmerge/dist/cjs.js"), cjs_default = __webpack_require__.n(cjs), javascript_stringify_dist = __webpack_require__("../../node_modules/.pnpm/javascript-stringify@2.1.0/node_modules/javascript-stringify/dist/index.js");
    function createMap(superClass) {
        return class extends superClass {
            extend(methods) {
                return this.shorthands = methods, methods.forEach((method)=>{
                    this[method] = (value)=>this.set(method, value);
                }), this;
            }
            clear() {
                return this.store.clear(), this;
            }
            delete(key) {
                return this.store.delete(key), this;
            }
            order() {
                let entries = [
                    ...this.store
                ].reduce((acc, [key, value])=>(acc[key] = value, acc), {}), names = Object.keys(entries), order = [
                    ...names
                ];
                return names.forEach((name)=>{
                    if (!entries[name]) return;
                    let { __before, __after } = entries[name];
                    __before && order.includes(__before) ? (order.splice(order.indexOf(name), 1), order.splice(order.indexOf(__before), 0, name)) : __after && order.includes(__after) && (order.splice(order.indexOf(name), 1), order.splice(order.indexOf(__after) + 1, 0, name));
                }), {
                    entries,
                    order
                };
            }
            entries() {
                let { entries, order } = this.order();
                if (order.length) return entries;
            }
            values() {
                let { entries, order } = this.order();
                return order.map((name)=>entries[name]);
            }
            get(key) {
                return this.store.get(key);
            }
            getOrCompute(key, fn) {
                return this.has(key) || this.set(key, fn()), this.get(key);
            }
            has(key) {
                return this.store.has(key);
            }
            set(key, value) {
                return this.store.set(key, value), this;
            }
            merge(obj, omit = []) {
                return Object.keys(obj).forEach((key)=>{
                    if (omit.includes(key)) return;
                    let value = obj[key];
                    (Array.isArray(value) || 'object' == typeof value) && null !== value && this.has(key) ? this.set(key, cjs(this.get(key), value)) : this.set(key, value);
                }), this;
            }
            clean(obj) {
                return Object.keys(obj).reduce((acc, key)=>{
                    let value = obj[key];
                    return void 0 === value || Array.isArray(value) && !value.length || '[object Object]' === Object.prototype.toString.call(value) && !Object.keys(value).length || (acc[key] = value), acc;
                }, {});
            }
            when(condition, whenTruthy = Function.prototype, whenFalsy = Function.prototype) {
                return condition ? whenTruthy(this) : whenFalsy(this), this;
            }
            constructor(...args){
                super(...args), this.store = new Map();
            }
        };
    }
    function createChainable(superClass) {
        return class extends superClass {
            batch(handler) {
                return handler(this), this;
            }
            end() {
                return this.parent;
            }
            constructor(parent){
                super(), this.parent = parent;
            }
        };
    }
    let ChainedMap = createMap(createChainable(Object)), ChainedValueMap = (superClass = createMap(createChainable(class extends Function {
        classCall() {
            throw Error('not implemented');
        }
        constructor(){
            return super(), new Proxy(this, {
                apply: (target, thisArg, args)=>target.classCall(...args)
            });
        }
    })), class extends superClass {
        set(...args) {
            return this.useMap = !0, this.value = void 0, super.set(...args);
        }
        clear() {
            return this.value = void 0, super.clear();
        }
        classCall(value) {
            return this.clear(), this.useMap = !1, this.value = value, this.parent;
        }
        entries() {
            return this.useMap ? super.entries() : this.value;
        }
        values() {
            return this.useMap ? super.values() : this.value;
        }
        constructor(...args){
            super(...args), this.value = void 0, this.useMap = !0;
        }
    }), ChainedSet = (superClass1 = createChainable(Object), class extends superClass1 {
        add(value) {
            return this.store.add(value), this;
        }
        prepend(value) {
            return this.store = new Set([
                value,
                ...this.store
            ]), this;
        }
        clear() {
            return this.store.clear(), this;
        }
        delete(value) {
            return this.store.delete(value), this;
        }
        values() {
            return [
                ...this.store
            ];
        }
        has(value) {
            return this.store.has(value);
        }
        merge(arr) {
            return void 0 !== arr && (this.store = new Set([
                ...this.store,
                ...arr
            ])), this;
        }
        when(condition, whenTruthy = Function.prototype, whenFalsy = Function.prototype) {
            return condition ? whenTruthy(this) : whenFalsy(this), this;
        }
        constructor(...args){
            super(...args), this.store = new Set();
        }
    }), Orderable = (Class)=>class extends Class {
            before(name) {
                if (this.__after) throw Error(`Unable to set .before(${JSON.stringify(name)}) with existing value for .after()`);
                return this.__before = name, this;
            }
            after(name) {
                if (this.__before) throw Error(`Unable to set .after(${JSON.stringify(name)}) with existing value for .before()`);
                return this.__after = name, this;
            }
            merge(obj, omit = []) {
                return obj.before && this.before(obj.before), obj.after && this.after(obj.after), super.merge(obj, [
                    ...omit,
                    'before',
                    'after'
                ]);
            }
        }, src_Plugin = Orderable(class extends ChainedMap {
        use(plugin, args = []) {
            return this.set('plugin', plugin).set('args', args);
        }
        tap(f) {
            if (!this.has('plugin')) throw Error(`Cannot call .tap() on a plugin that has not yet been defined. Call ${this.type}('${this.name}').use(<Plugin>) first.`);
            return this.set('args', f(this.get('args') || [])), this;
        }
        set(key, value) {
            if ('args' === key && !Array.isArray(value)) throw Error('args must be an array of arguments');
            return super.set(key, value);
        }
        merge(obj, omit = []) {
            return 'plugin' in obj && this.set('plugin', obj.plugin), 'args' in obj && this.set('args', obj.args), super.merge(obj, [
                ...omit,
                'args',
                'plugin'
            ]);
        }
        toConfig() {
            let init = this.get('init'), plugin = this.get('plugin'), args = this.get('args'), pluginPath = null;
            if (void 0 === plugin) throw Error(`Invalid ${this.type} configuration: ${this.type}('${this.name}').use(<Plugin>) was not called to specify the plugin`);
            'string' == typeof plugin && (plugin = require(pluginPath = plugin));
            let constructorName = plugin.__expression ? `(${plugin.__expression})` : plugin.name, config = init(plugin, args);
            return Object.defineProperties(config, {
                __pluginName: {
                    value: this.name
                },
                __pluginType: {
                    value: this.type
                },
                __pluginArgs: {
                    value: args
                },
                __pluginConstructorName: {
                    value: constructorName
                },
                __pluginPath: {
                    value: pluginPath
                }
            }), config;
        }
        constructor(parent, name, type = 'plugin'){
            super(parent), this.name = name, this.type = type, this.extend([
                'init'
            ]), this.init((Plugin, args = [])=>'function' == typeof Plugin ? new Plugin(...args) : Plugin);
        }
    }), childMaps = [
        'alias',
        'fallback',
        'byDependency',
        'extensionAlias'
    ], childSets = [
        'aliasFields',
        'conditionNames',
        "descriptionFiles",
        'extensions',
        'mainFields',
        'mainFiles',
        'exportsFields',
        'importsFields',
        'restrictions',
        'roots',
        'modules'
    ];
    class Resolve_class extends ChainedMap {
        plugin(name) {
            return this.plugins.getOrCompute(name, ()=>new src_Plugin(this, name, 'resolve.plugin'));
        }
        get(key) {
            return childMaps.includes(key) ? this[key].entries() : childSets.includes(key) ? this[key].values() : super.get(key);
        }
        toConfig() {
            let config = Object.assign(this.entries() || {}, {
                plugins: this.plugins.values().map((plugin)=>plugin.toConfig())
            });
            return childMaps.forEach((key)=>{
                config[key] = this[key].entries();
            }), childSets.forEach((key)=>{
                config[key] = this[key].values();
            }), this.clean(config);
        }
        merge(obj, omit = []) {
            !omit.includes('plugin') && 'plugin' in obj && Object.keys(obj.plugin).forEach((name)=>this.plugin(name).merge(obj.plugin[name]));
            let omissions = [
                ...childMaps,
                ...childSets
            ];
            return omissions.forEach((key)=>{
                !omit.includes(key) && key in obj && this[key].merge(obj[key]);
            }), super.merge(obj, [
                ...omit,
                ...omissions,
                'plugin'
            ]);
        }
        constructor(parent){
            super(parent), childMaps.forEach((key)=>{
                this[key] = new ChainedMap(this);
            }), childSets.forEach((key)=>{
                this[key] = new ChainedSet(this);
            }), this.plugins = new ChainedMap(this), this.extend([
                'cachePredicate',
                'cacheWithContext',
                'enforceExtension',
                'symlinks',
                'unsafeCache',
                'preferRelative',
                'preferAbsolute',
                'tsConfig'
            ]);
        }
    }
    class ResolveLoader_class extends Resolve_class {
        toConfig() {
            return this.clean({
                modules: this.modules.values(),
                moduleExtensions: this.moduleExtensions.values(),
                packageMains: this.packageMains.values(),
                ...super.toConfig()
            });
        }
        merge(obj, omit = []) {
            let omissions = [
                'modules',
                'moduleExtensions',
                'packageMains'
            ];
            return omissions.forEach((key)=>{
                !omit.includes(key) && key in obj && this[key].merge(obj[key]);
            }), super.merge(obj, [
                ...omit,
                ...omissions
            ]);
        }
        constructor(parent){
            super(parent), this.modules = new ChainedSet(this), this.moduleExtensions = new ChainedSet(this), this.packageMains = new ChainedSet(this);
        }
    }
    class Output_class extends ChainedMap {
        constructor(parent){
            super(parent), this.extend([
                'auxiliaryComment',
                'charset',
                'chunkFilename',
                'chunkLoadTimeout',
                'chunkLoadingGlobal',
                'chunkLoading',
                'chunkFormat',
                'enabledChunkLoadingTypes',
                'crossOriginLoading',
                'devtoolFallbackModuleFilenameTemplate',
                'devtoolModuleFilenameTemplate',
                'devtoolNamespace',
                'filename',
                'assetModuleFilename',
                'globalObject',
                'uniqueName',
                'hashDigest',
                'hashDigestLength',
                'hashFunction',
                'hashSalt',
                'hotUpdateChunkFilename',
                'hotUpdateGlobal',
                'hotUpdateMainFilename',
                'library',
                'libraryExport',
                'libraryTarget',
                'importFunctionName',
                'path',
                'pathinfo',
                'publicPath',
                "scriptType",
                'sourceMapFilename',
                'sourcePrefix',
                'strictModuleErrorHandling',
                'strictModuleExceptionHandling',
                'umdNamedDefine',
                'workerChunkLoading',
                'enabledLibraryTypes',
                'environment',
                'compareBeforeEmit',
                'wasmLoading',
                'webassemblyModuleFilename',
                'enabledWasmLoadingTypes',
                'iife',
                'module',
                'clean'
            ]);
        }
    }
    class DevServer_class extends ChainedMap {
        toConfig() {
            return this.clean({
                allowedHosts: this.allowedHosts.values(),
                ...this.entries() || {}
            });
        }
        merge(obj, omit = []) {
            return !omit.includes('allowedHosts') && 'allowedHosts' in obj && this.allowedHosts.merge(obj.allowedHosts), super.merge(obj, [
                'allowedHosts'
            ]);
        }
        constructor(parent){
            super(parent), this.allowedHosts = new ChainedSet(this), this.extend([
                'after',
                'before',
                'bonjour',
                'clientLogLevel',
                'compress',
                'contentBase',
                'contentBasePublicPath',
                'disableHostCheck',
                'filename',
                'headers',
                'historyApiFallback',
                'host',
                'hot',
                'hotOnly',
                'http2',
                'https',
                'index',
                'injectClient',
                'injectHot',
                'inline',
                'lazy',
                'liveReload',
                'mimeTypes',
                'noInfo',
                'onListening',
                'open',
                'openPage',
                'overlay',
                'pfx',
                'pfxPassphrase',
                'port',
                'proxy',
                'progress',
                'public',
                'publicPath',
                'quiet',
                'serveIndex',
                'setup',
                'socket',
                'sockHost',
                'sockPath',
                'sockPort',
                'staticOptions',
                'stats',
                'stdin',
                'transportMode',
                'useLocalIp',
                'watchContentBase',
                'watchOptions',
                'writeToDisk'
            ]);
        }
    }
    let Use = Orderable(class extends ChainedMap {
        tap(f) {
            return this.options(f(this.get('options'))), this;
        }
        merge(obj, omit = []) {
            return !omit.includes('loader') && 'loader' in obj && this.loader(obj.loader), !omit.includes('options') && 'options' in obj && this.options(cjs(this.store.get('options') || {}, obj.options)), super.merge(obj, [
                ...omit,
                'loader',
                'options'
            ]);
        }
        toConfig() {
            let config = this.clean(this.entries() || {});
            return Object.defineProperties(config, {
                __useName: {
                    value: this.name
                },
                __ruleNames: {
                    value: this.parent && this.parent.names
                },
                __ruleTypes: {
                    value: this.parent && this.parent.ruleTypes
                }
            }), config;
        }
        constructor(parent, name){
            super(parent), this.name = name, this.extend([
                'loader',
                'options',
                'parallel'
            ]);
        }
    });
    function toArray(arr) {
        return Array.isArray(arr) ? arr : [
            arr
        ];
    }
    let Rule_Rule = Orderable(class extends ChainedMap {
        use(name) {
            return this.uses.getOrCompute(name, ()=>new Use(this, name));
        }
        rule(name) {
            return this.rules.getOrCompute(name, ()=>new Rule_Rule(this, name, 'rule'));
        }
        oneOf(name) {
            return this.oneOfs.getOrCompute(name, ()=>new Rule_Rule(this, name, 'oneOf'));
        }
        pre() {
            return this.enforce('pre');
        }
        post() {
            return this.enforce('post');
        }
        toConfig() {
            let config = this.clean(Object.assign(this.entries() || {}, {
                include: this.include.values(),
                exclude: this.exclude.values(),
                rules: this.rules.values().map((rule)=>rule.toConfig()),
                oneOf: this.oneOfs.values().map((oneOf)=>oneOf.toConfig()),
                use: this.uses.values().map((use)=>use.toConfig()),
                resolve: this.resolve.toConfig()
            }));
            return Object.defineProperties(config, {
                __ruleNames: {
                    value: this.names
                },
                __ruleTypes: {
                    value: this.ruleTypes
                }
            }), config;
        }
        merge(obj, omit = []) {
            return !omit.includes('include') && 'include' in obj && this.include.merge(toArray(obj.include)), !omit.includes('exclude') && 'exclude' in obj && this.exclude.merge(toArray(obj.exclude)), !omit.includes('use') && 'use' in obj && Object.keys(obj.use).forEach((name)=>this.use(name).merge(obj.use[name])), !omit.includes('rules') && 'rules' in obj && Object.keys(obj.rules).forEach((name)=>this.rule(name).merge(obj.rules[name])), !omit.includes('oneOf') && 'oneOf' in obj && Object.keys(obj.oneOf).forEach((name)=>this.oneOf(name).merge(obj.oneOf[name])), !omit.includes('resolve') && 'resolve' in obj && this.resolve.merge(obj.resolve), !omit.includes('test') && 'test' in obj && this.test(obj.test instanceof RegExp || 'function' == typeof obj.test ? obj.test : new RegExp(obj.test)), super.merge(obj, [
                ...omit,
                'include',
                'exclude',
                'use',
                'rules',
                'oneOf',
                'resolve',
                'test'
            ]);
        }
        constructor(parent, name, ruleType = 'rule'){
            super(parent), this.ruleName = name, this.names = [], this.ruleType = ruleType, this.ruleTypes = [];
            let rule = this;
            for(; rule instanceof Rule_Rule;)this.names.unshift(rule.ruleName), this.ruleTypes.unshift(rule.ruleType), rule = rule.parent;
            this.uses = new ChainedMap(this), this.include = new ChainedSet(this), this.exclude = new ChainedSet(this), this.rules = new ChainedMap(this), this.oneOfs = new ChainedMap(this), this.resolve = new Resolve_class(this), this.resolve.extend([
                'fullySpecified'
            ]), this.extend([
                'dependency',
                'enforce',
                'issuer',
                'issuerLayer',
                'layer',
                'mimetype',
                'parser',
                'generator',
                'resource',
                'resourceFragment',
                'resourceQuery',
                'sideEffects',
                'with',
                'test',
                'type'
            ]);
        }
    });
    class Module_class extends ChainedMap {
        defaultRule(name) {
            return this.defaultRules.getOrCompute(name, ()=>new Rule_Rule(this, name, 'defaultRule'));
        }
        rule(name) {
            return this.rules.getOrCompute(name, ()=>new Rule_Rule(this, name, 'rule'));
        }
        toConfig() {
            return this.clean(Object.assign(this.entries() || {}, {
                defaultRules: this.defaultRules.values().map((r)=>r.toConfig()),
                generator: this.generator.entries(),
                parser: this.parser.entries(),
                rules: this.rules.values().map((r)=>r.toConfig())
            }));
        }
        merge(obj, omit = []) {
            return !omit.includes('rule') && 'rule' in obj && Object.keys(obj.rule).forEach((name)=>this.rule(name).merge(obj.rule[name])), !omit.includes('defaultRule') && 'defaultRule' in obj && Object.keys(obj.defaultRule).forEach((name)=>this.defaultRule(name).merge(obj.defaultRule[name])), super.merge(obj, [
                'rule',
                'defaultRule'
            ]);
        }
        constructor(parent){
            super(parent), this.rules = new ChainedMap(this), this.defaultRules = new ChainedMap(this), this.generator = new ChainedMap(this), this.parser = new ChainedMap(this), this.extend([
                'noParse',
                'unsafeCache',
                'wrappedContextCritical',
                'exprContextRegExp',
                'wrappedContextRecursive',
                'strictExportPresence',
                'wrappedContextRegExp'
            ]);
        }
    }
    class Optimization_class extends ChainedMap {
        minimizer(name) {
            if (Array.isArray(name)) throw Error("optimization.minimizer() no longer supports being passed an array. Either switch to the new syntax (https://github.com/neutrinojs/webpack-chain#config-optimization-minimizers-adding) or downgrade to webpack-chain 4. If using Vue this likely means a Vue plugin has not yet been updated to support Vue CLI 4+.");
            return this.minimizers.getOrCompute(name, ()=>new src_Plugin(this, name, 'optimization.minimizer'));
        }
        toConfig() {
            return this.clean(Object.assign(this.entries() || {}, {
                splitChunks: this.splitChunks.entries(),
                minimizer: this.minimizers.values().map((plugin)=>plugin.toConfig())
            }));
        }
        merge(obj, omit = []) {
            return !omit.includes('minimizer') && 'minimizer' in obj && Object.keys(obj.minimizer).forEach((name)=>this.minimizer(name).merge(obj.minimizer[name])), super.merge(obj, [
                ...omit,
                'minimizer'
            ]);
        }
        constructor(parent){
            super(parent), this.minimizers = new ChainedMap(this), this.splitChunks = new ChainedValueMap(this), this.extend([
                'minimize',
                'runtimeChunk',
                'emitOnErrors',
                'moduleIds',
                'chunkIds',
                'nodeEnv',
                'mangleWasmImports',
                'removeAvailableModules',
                'removeEmptyChunks',
                'mergeDuplicateChunks',
                'flagIncludedChunks',
                'providedExports',
                'usedExports',
                'concatenateModules',
                'sideEffects',
                'portableRecords',
                'mangleExports',
                'innerGraph',
                'realContentHash',
                'avoidEntryIife'
            ]);
        }
    }
    class Performance_class extends ChainedValueMap {
        constructor(parent){
            super(parent), this.extend([
                'assetFilter',
                'hints',
                'maxAssetSize',
                'maxEntrypointSize'
            ]);
        }
    }
    let castArray = (value)=>Array.isArray(value) ? value : [
            value
        ];
    class src_class extends ChainedMap {
        static toString(config, { verbose = !1, configPrefix = 'config' } = {}) {
            return (0, javascript_stringify_dist.stringify)(config, (value, indent, stringify)=>{
                if (value && value.__pluginName) {
                    let prefix = `/* ${configPrefix}.${value.__pluginType}('${value.__pluginName}') */\n`, constructorExpression = value.__pluginPath ? `(require(${stringify(value.__pluginPath)}))` : value.__pluginConstructorName;
                    if (constructorExpression) {
                        let args = stringify(value.__pluginArgs).slice(1, -1);
                        return `${prefix}new ${constructorExpression}(${args})`;
                    }
                    return prefix + stringify(value.__pluginArgs && value.__pluginArgs.length ? {
                        args: value.__pluginArgs
                    } : {});
                }
                if (value && value.__ruleNames) {
                    let ruleTypes = value.__ruleTypes;
                    return `/* ${configPrefix}.module${value.__ruleNames.map((r, index)=>`.${ruleTypes ? ruleTypes[index] : 'rule'}('${r}')`).join('')}${value.__useName ? `.use('${value.__useName}')` : ""} */\n` + stringify(value);
                }
                return value && value.__expression ? value.__expression : 'function' == typeof value && !verbose && value.toString().length > 100 ? "function () { /* omitted long function */ }" : stringify(value);
            }, 2);
        }
        entry(name) {
            return this.entryPoints.getOrCompute(name, ()=>new ChainedSet(this));
        }
        plugin(name) {
            return this.plugins.getOrCompute(name, ()=>new src_Plugin(this, name));
        }
        toConfig() {
            let entryPoints = this.entryPoints.entries() || {}, baseConfig = this.entries() || {};
            return this.clean(Object.assign(baseConfig, {
                node: this.node.entries(),
                output: this.output.entries(),
                resolve: this.resolve.toConfig(),
                resolveLoader: this.resolveLoader.toConfig(),
                devServer: this.devServer.toConfig(),
                module: this.module.toConfig(),
                optimization: this.optimization.toConfig(),
                plugins: this.plugins.values().map((plugin)=>plugin.toConfig()),
                performance: this.performance.entries(),
                entry: ((entryPoints)=>{
                    let entry = Object.keys(entryPoints).reduce((acc, key)=>Object.assign(acc, {
                            [key]: entryPoints[key].values()
                        }), {}), formattedEntry = {};
                    for (let [entryName, entryValue] of Object.entries(entry)){
                        let entryImport = [], entryDescription = null;
                        for (let item of castArray(entryValue)){
                            if ('string' == typeof item) {
                                entryImport.push(item);
                                continue;
                            }
                            item.import && entryImport.push(...castArray(item.import)), entryDescription ? Object.assign(entryDescription, item) : entryDescription = item;
                        }
                        formattedEntry[entryName] = entryDescription ? {
                            ...entryDescription,
                            import: entryImport
                        } : entryImport;
                    }
                    return formattedEntry;
                })(entryPoints)
            }));
        }
        toString(options) {
            return this.constructor.toString(this.toConfig(), options);
        }
        merge(obj = {}, omit = []) {
            let omissions = [
                'node',
                'output',
                'resolve',
                'resolveLoader',
                'devServer',
                'optimization',
                'performance',
                'module'
            ];
            return !omit.includes('entry') && 'entry' in obj && Object.keys(obj.entry).forEach((name)=>this.entry(name).merge([].concat(obj.entry[name]))), !omit.includes('plugin') && 'plugin' in obj && Object.keys(obj.plugin).forEach((name)=>this.plugin(name).merge(obj.plugin[name])), omissions.forEach((key)=>{
                !omit.includes(key) && key in obj && this[key].merge(obj[key]);
            }), super.merge(obj, [
                ...omit,
                ...omissions,
                'entry',
                'plugin'
            ]);
        }
        constructor(){
            super(), this.entryPoints = new ChainedMap(this), this.output = new Output_class(this), this.module = new Module_class(this), this.resolve = new Resolve_class(this), this.resolveLoader = new ResolveLoader_class(this), this.optimization = new Optimization_class(this), this.plugins = new ChainedMap(this), this.devServer = new DevServer_class(this), this.performance = new Performance_class(this), this.node = new ChainedValueMap(this), this.extend([
                'context',
                'mode',
                'devtool',
                'target',
                'watch',
                'watchOptions',
                'externals',
                'externalsType',
                'externalsPresets',
                'stats',
                'experiments',
                'amd',
                'bail',
                'cache',
                'dependencies',
                'ignoreWarnings',
                'loader',
                'parallelism',
                'profile',
                'recordsPath',
                'recordsInputPath',
                'recordsOutputPath',
                'name',
                'infrastructureLogging',
                'snapshot',
                'lazyCompilation'
            ]);
        }
    }
    let setNodeEnv = (env)=>{
        process.env.NODE_ENV = env;
    }, isFunction = (func)=>'function' == typeof func, isObject = (obj)=>'[object Object]' === Object.prototype.toString.call(obj), objectPrototype = Object.prototype, getProto = Object.getPrototypeOf, isPlainObject = (obj)=>null !== obj && 'object' == typeof obj && getProto(obj) === objectPrototype, helpers_castArray = (arr)=>void 0 === arr ? [] : Array.isArray(arr) ? arr : [
            arr
        ], cloneDeep = (value)=>null == value ? value : cjs_default()({}, value, {
            isMergeableObject: isPlainObject
        });
    function getFilename(config, type, isProd, isServer) {
        let { filename, filenameHash } = config.output, defaultHash = '[contenthash:8]', getHash = ()=>'string' == typeof filenameHash ? filenameHash ? `.[${filenameHash}]` : '' : filenameHash ? `.${defaultHash}` : '';
        switch(type){
            case 'js':
                return filename.js ?? `[name]${isProd && !isServer ? getHash() : ''}.js`;
            case 'css':
                return filename.css ?? `[name]${isProd ? getHash() : ''}.css`;
            case 'svg':
                return filename.svg ?? `[name]${getHash()}.svg`;
            case 'font':
                return filename.font ?? `[name]${getHash()}[ext]`;
            case 'image':
                return filename.image ?? `[name]${getHash()}[ext]`;
            case 'media':
                return filename.media ?? `[name]${getHash()}[ext]`;
            case 'assets':
                return filename.assets ?? `[name]${getHash()}[ext]`;
            case 'wasm':
                {
                    let hash = 'string' == typeof filenameHash ? `[${filenameHash}]` : defaultHash;
                    return filename.wasm ?? `${hash}.module.wasm`;
                }
            case 'html':
                if (filename.html) return filename.html;
                return 'flat' === config.html.outputStructure ? '[name].html' : '[name]/index.html';
            default:
                throw Error(`${color.dim('[rsbuild:config]')} unknown key ${color.yellow(type)} in ${color.yellow('output.filename')}`);
        }
    }
    function partition(array, predicate) {
        let truthy = [], falsy = [];
        for (let value of array)predicate(value) ? truthy.push(value) : falsy.push(value);
        return [
            truthy,
            falsy
        ];
    }
    let upperFirst = (str)=>str ? str.charAt(0).toUpperCase() + str.slice(1) : '', createVirtualModule = (content)=>`data:text/javascript,${content}`;
    function isWebTarget(target) {
        let targets = helpers_castArray(target);
        return targets.includes('web') || targets.includes('web-worker');
    }
    function pick(obj, keys) {
        let result = {};
        for (let key of keys)void 0 !== obj[key] && (result[key] = obj[key]);
        return result;
    }
    let prettyTime = (seconds)=>{
        let time, time1;
        if (seconds < 10) {
            let time, digits = seconds >= 0.01 ? 2 : 3;
            return `${time = seconds.toFixed(digits), color.bold(time)} s`;
        }
        if (seconds < 60) {
            let time;
            return `${time = seconds.toFixed(1), color.bold(time)} s`;
        }
        let minutes = Math.floor(seconds / 60), minutesLabel = `${(time = minutes.toFixed(0), color.bold(time))} m`, remainingSeconds = seconds % 60;
        if (0 === remainingSeconds) return minutesLabel;
        let secondsLabel = `${(time1 = remainingSeconds.toFixed(+(remainingSeconds % 1 != 0)), color.bold(time1))} s`;
        return `${minutesLabel} ${secondsLabel}`;
    }, isTTY = (type = 'stdout')=>('stdin' === type ? process.stdin.isTTY : process.stdout.isTTY) && !process.env.CI;
    async function helpers_hash(data) {
        let crypto = await import("node:crypto");
        return crypto.hash ? crypto.hash('sha256', data, 'hex').slice(0, 16) : crypto.createHash('sha256').update(data).digest('hex').slice(0, 16);
    }
    let compiler_isMultiCompiler = (compiler)=>'compilers' in compiler && Array.isArray(compiler.compilers), getPublicPathFromCompiler = (compiler)=>{
        let { publicPath } = compiler.options.output;
        return 'string' == typeof publicPath ? 'auto' === publicPath ? '' : publicPath.endsWith('/') ? publicPath : `${publicPath}/` : DEFAULT_ASSET_PREFIX;
    }, applyToCompiler = (compiler, apply)=>{
        compiler_isMultiCompiler(compiler) ? compiler.compilers.forEach(apply) : apply(compiler, 0);
    }, addCompilationError = (compilation, message)=>{
        compilation.errors.push(new compilation.compiler.webpack.WebpackError(message));
    };
    function createEnvironmentAsyncHook() {
        let preGroup = [], postGroup = [], defaultGroup = [], tapEnvironment = ({ environment, handler: cb })=>{
            isFunction(cb) ? defaultGroup.push({
                environment,
                handler: cb
            }) : 'pre' === cb.order ? preGroup.push({
                environment,
                handler: cb.handler
            }) : 'post' === cb.order ? postGroup.push({
                environment,
                handler: cb.handler
            }) : defaultGroup.push({
                environment,
                handler: cb.handler
            });
        };
        return {
            tapEnvironment,
            tap: (handler)=>{
                tapEnvironment({
                    handler
                });
            },
            callChain: async ({ environment, args: params, afterEach })=>{
                for (let callback of [
                    ...preGroup,
                    ...defaultGroup,
                    ...postGroup
                ]){
                    if (environment && callback.environment && callback.environment !== environment) continue;
                    let result = await callback.handler(...params);
                    void 0 !== result && (params[0] = result), afterEach && afterEach(params);
                }
                return params;
            },
            callBatch: async ({ environment, args: params })=>{
                let results = [];
                for (let callback of [
                    ...preGroup,
                    ...defaultGroup,
                    ...postGroup
                ]){
                    if (environment && callback.environment && callback.environment !== environment) continue;
                    let result = await callback.handler(...params);
                    results.push(result);
                }
                return results;
            }
        };
    }
    function createAsyncHook() {
        let preGroup = [], postGroup = [], defaultGroup = [];
        return {
            tap: (cb)=>{
                isFunction(cb) ? defaultGroup.push(cb) : 'pre' === cb.order ? preGroup.push(cb.handler) : 'post' === cb.order ? postGroup.push(cb.handler) : defaultGroup.push(cb.handler);
            },
            callChain: async (...params)=>{
                for (let callback of [
                    ...preGroup,
                    ...defaultGroup,
                    ...postGroup
                ]){
                    let result = await callback(...params);
                    void 0 !== result && (params[0] = result);
                }
                return params;
            },
            callBatch: async (...params)=>{
                let results = [];
                for (let callback of [
                    ...preGroup,
                    ...defaultGroup,
                    ...postGroup
                ]){
                    let result = await callback(...params);
                    results.push(result);
                }
                return results;
            }
        };
    }
    function initHooks() {
        return {
            onExit: createAsyncHook(),
            onCloseBuild: createAsyncHook(),
            onAfterBuild: createAsyncHook(),
            onBeforeBuild: createAsyncHook(),
            onBeforeDevCompile: createAsyncHook(),
            onAfterDevCompile: createAsyncHook(),
            onCloseDevServer: createAsyncHook(),
            onAfterStartDevServer: createAsyncHook(),
            onBeforeStartDevServer: createAsyncHook(),
            onAfterStartProdServer: createAsyncHook(),
            onBeforeStartProdServer: createAsyncHook(),
            onAfterCreateCompiler: createAsyncHook(),
            onBeforeCreateCompiler: createAsyncHook(),
            modifyHTML: createEnvironmentAsyncHook(),
            modifyHTMLTags: createEnvironmentAsyncHook(),
            modifyRspackConfig: createEnvironmentAsyncHook(),
            modifyBundlerChain: createEnvironmentAsyncHook(),
            modifyWebpackChain: createEnvironmentAsyncHook(),
            modifyWebpackConfig: createEnvironmentAsyncHook(),
            modifyRsbuildConfig: createAsyncHook(),
            modifyEnvironmentConfig: createEnvironmentAsyncHook(),
            onBeforeEnvironmentCompile: createEnvironmentAsyncHook(),
            onAfterEnvironmentCompile: createEnvironmentAsyncHook()
        };
    }
    let onBeforeCompile = ({ compiler, beforeCompile, beforeEnvironmentCompile, isWatch })=>{
        let name = 'rsbuild:beforeCompile';
        if (compiler_isMultiCompiler(compiler)) {
            let waitBeforeCompileDone, { compilers } = compiler;
            compiler.hooks.invalid.tap(name, ()=>{
                waitBeforeCompileDone = void 0;
            });
            for(let index = 0; index < compilers.length; index++){
                let compiler = compilers[index];
                (isWatch ? compiler.hooks.watchRun : compiler.hooks.run).tapPromise(name, async ()=>{
                    waitBeforeCompileDone || (waitBeforeCompileDone = beforeCompile()), await waitBeforeCompileDone, await beforeEnvironmentCompile(index);
                });
            }
        } else (isWatch ? compiler.hooks.watchRun : compiler.hooks.run).tapPromise(name, async ()=>{
            await beforeCompile(), await beforeEnvironmentCompile(0);
        });
    }, onCompileDone = ({ compiler, onDone, onEnvironmentDone, MultiStatsCtor })=>{
        if (compiler_isMultiCompiler(compiler)) {
            let { compilers } = compiler, compilerStats = [], doneCompilers = 0;
            for(let index = 0; index < compilers.length; index++){
                let compiler = compilers[index], compilerIndex = index, compilerDone = !1;
                compiler.hooks.done.tapPromise('rsbuild:done', async (stats)=>{
                    !compilerDone && (compilerDone = !0, doneCompilers++), compilerStats[compilerIndex] = stats;
                    let lastCompilerDone = doneCompilers === compilers.length;
                    await onEnvironmentDone(index, stats), lastCompilerDone && await onDone(new MultiStatsCtor(compilerStats));
                }), compiler.hooks.invalid.tap('rsbuild:done', ()=>{
                    compilerDone && (compilerDone = !1, doneCompilers--);
                });
            }
        } else compiler.hooks.done.tapPromise('rsbuild:done', async (stats)=>{
            await onEnvironmentDone(0, stats), await onDone(stats);
        });
    }, registerBuildHook = ({ context, isWatch, compiler, bundlerConfigs, MultiStatsCtor })=>{
        let isFirstCompile = !0, { environmentList } = context, onDone = async (stats)=>{
            let promise = context.hooks.onAfterBuild.callBatch({
                isFirstCompile,
                stats,
                environments: context.environments,
                isWatch
            });
            isFirstCompile = !1, await promise;
        }, onEnvironmentDone = async (buildIndex, stats)=>{
            await context.hooks.onAfterEnvironmentCompile.callBatch({
                environment: environmentList[buildIndex].name,
                args: [
                    {
                        isFirstCompile,
                        stats,
                        environment: environmentList[buildIndex],
                        isWatch
                    }
                ]
            });
        };
        onBeforeCompile({
            compiler,
            beforeCompile: async ()=>context.hooks.onBeforeBuild.callBatch({
                    bundlerConfigs,
                    environments: context.environments,
                    isWatch,
                    isFirstCompile
                }),
            beforeEnvironmentCompile: async (buildIndex)=>{
                let environment = environmentList[buildIndex];
                return context.hooks.onBeforeEnvironmentCompile.callBatch({
                    environment: environment.name,
                    args: [
                        {
                            bundlerConfig: bundlerConfigs[buildIndex],
                            environment,
                            isWatch,
                            isFirstCompile
                        }
                    ]
                });
            },
            isWatch
        }), onCompileDone({
            compiler,
            onDone,
            onEnvironmentDone,
            MultiStatsCtor
        });
    }, registerDevHook = ({ context, compiler, bundlerConfigs, MultiStatsCtor })=>{
        let isFirstCompile = !0, { environmentList } = context, onDone = async (stats)=>{
            let promise = context.hooks.onAfterDevCompile.callBatch({
                isFirstCompile,
                stats,
                environments: context.environments
            });
            isFirstCompile = !1, await promise;
        }, onEnvironmentDone = async (buildIndex, stats)=>{
            await context.hooks.onAfterEnvironmentCompile.callBatch({
                environment: environmentList[buildIndex].name,
                args: [
                    {
                        isFirstCompile,
                        stats,
                        environment: environmentList[buildIndex],
                        isWatch: !0
                    }
                ]
            });
        };
        onBeforeCompile({
            compiler,
            beforeEnvironmentCompile: async (buildIndex)=>{
                let environment = environmentList[buildIndex];
                return context.hooks.onBeforeEnvironmentCompile.callBatch({
                    environment: environment.name,
                    args: [
                        {
                            bundlerConfig: bundlerConfigs[buildIndex],
                            environment,
                            isWatch: !0,
                            isFirstCompile
                        }
                    ]
                });
            },
            beforeCompile: async ()=>context.hooks.onBeforeDevCompile.callBatch({
                    bundlerConfigs,
                    environments: context.environments,
                    isFirstCompile,
                    isWatch: !0
                }),
            isWatch: !0
        }), onCompileDone({
            compiler,
            onDone,
            onEnvironmentDone,
            MultiStatsCtor
        });
    };
    function resolveFileName(stats) {
        let file = stats.file || stats.moduleName;
        if (file) return removeLoaderChainDelimiter(file);
        if (stats.moduleIdentifier) {
            let matched = stats.moduleIdentifier.match(/(?:!|^)([^!]+)$/);
            if (matched) {
                let fileName = matched.pop();
                if (fileName) return removeLoaderChainDelimiter(fileName);
            }
        }
        return '';
    }
    function formatModuleTrace(stats, errorFile) {
        if (!stats.moduleTrace) return;
        let moduleNames = stats.moduleTrace.map((trace)=>trace.originName).filter(Boolean);
        if (!moduleNames.length) return;
        errorFile && moduleNames.unshift(`${errorFile} ${color.bold(color.red(''))}`);
        let rawTrace = moduleNames.reverse().map((item)=>`\n  ${item}`).join('');
        return color.dim(`Import traces (entry  error):${rawTrace}`);
    }
    function hintUnknownFiles(message) {
        let hint = 'You may need an appropriate loader to handle this file type.';
        if (-1 === message.indexOf(hint)) return message;
        let createPluginHint = (packageName, keyword)=>`To enable support for ${keyword}, use "${color.yellow(`@rsbuild/plugin-${packageName}`)}" ${color.dim(`(https://npmjs.com/package/@rsbuild/plugin-${packageName})`)}.\n`;
        for (let plugin of [
            {
                test: /File: .+\.s(c|a)ss/,
                hint: createPluginHint('sass', 'Sass')
            },
            {
                test: /File: .+\.less/,
                hint: createPluginHint('less', 'Less')
            },
            {
                test: /File: .+\.styl(us)?/,
                hint: createPluginHint('stylus', 'Stylus')
            },
            {
                test: /File: .+\.vue?/,
                hint: createPluginHint('vue', 'Vue')
            },
            {
                test: /File: .+\.svelte?/,
                hint: createPluginHint('svelte', 'Svelte')
            },
            {
                test: /File: .+\.mdx/,
                hint: createPluginHint('mdx', 'MDX')
            },
            {
                test: /File: .+\.toml/,
                hint: createPluginHint('toml', 'TOML')
            },
            {
                test: /File: .+\.yaml/,
                hint: createPluginHint('yaml', 'YAML')
            }
        ])if (plugin.test.test(message)) return message.replace(hint, plugin.hint);
        return message;
    }
    function formatStatsError(stats) {
        var fileName, stats1;
        let fileName1 = resolveFileName(stats), message = `${(fileName = fileName1, stats1 = stats, !fileName ? '' : /:\d+:\d+/.test(fileName) ? `File: ${color.cyan(fileName)}\n` : stats1.loc ? `File: ${color.cyan(`${fileName}:${stats1.loc}`)}\n` : `File: ${color.cyan(`${fileName}:1:1`)}\n`)}${stats.message}`, verbose = 'verbose' === logger.level;
        verbose && (stats.details && (message += `\nDetails: ${stats.details}\n`), stats.stack && (message += `\n${stats.stack}`));
        let moduleTrace = formatModuleTrace(stats, fileName1);
        moduleTrace && (message += moduleTrace);
        let innerError = '-- inner error --';
        !verbose && message.includes(innerError) && (message = message.split(innerError)[0]);
        let lines = (message = ((message)=>{
            if (-1 === message.indexOf('Multiple assets emit different content to the same filename')) return message;
            let extraMessage = `You may need to adjust ${color.yellow('output.filename')} configuration to prevent name conflicts. (See ${color.yellow('https://rsbuild.rs/config/output/filename')})`;
            return `${message}\n${extraMessage}`;
        })(message = ((message)=>{
            let getTips = (moduleName)=>{
                let tips = [
                    `Error: "${moduleName}" is a built-in Node.js module and cannot be imported in client-side code.\n`,
                    'Solution: Check if you need to import Node.js module.',
                    '  - If not needed, remove the import.',
                    `  - If needed, use "${color.yellow('@rsbuild/plugin-node-polyfill')}" to polyfill it. (See ${color.yellow('https://npmjs.com/package/@rsbuild/plugin-node-polyfill')})`
                ];
                return `${message}\n\n${color.red(tips.join('\n'))}`;
            };
            if (message.includes('need an additional plugin to handle "node:" URIs')) return getTips('node:*');
            if (!message.includes("Can't resolve")) return message;
            let matchArray = message.match(/Can't resolve '(\w+)'/);
            if (!matchArray) return message;
            let moduleName = matchArray[1];
            return moduleName && [
                'assert',
                'buffer',
                'child_process',
                'cluster',
                'console',
                'constants',
                'crypto',
                'dgram',
                'dns',
                'domain',
                'events',
                'fs',
                'http',
                'https',
                'module',
                'net',
                'os',
                'path',
                'punycode',
                'process',
                'querystring',
                'readline',
                'repl',
                'stream',
                '_stream_duplex',
                '_stream_passthrough',
                '_stream_readable',
                '_stream_transform',
                '_stream_writable',
                'string_decoder',
                'sys',
                'timers',
                'tls',
                'tty',
                'url',
                'util',
                'vm',
                'zlib'
            ].includes(moduleName) ? getTips(moduleName) : message;
        })(message = hintUnknownFiles(message)))).split('\n');
        return (message = (lines = lines.filter((line, index, arr)=>0 === index || '' !== line.trim() || line.trim() !== arr[index - 1].trim())).join('\n')).trim();
    }
    function formatErrorMessage(errors) {
        if (!errors.length) return 'Build failed. No errors reported since Rspack\'s "stats.errors" is disabled.';
        let title = color.bold(color.red(errors.length > 1 ? 'Build errors: ' : 'Build error: ')), text = `${errors.join('\n\n')}\n`;
        return `${title}\n${text}`;
    }
    let getStatsErrors = ({ errors, children })=>void 0 !== errors && errors.length > 0 ? errors : children ? children.reduce((errors, ret)=>ret.errors ? errors.concat(ret.errors) : errors, []) : [], getStatsWarnings = ({ warnings, children })=>void 0 !== warnings && warnings.length > 0 ? warnings : children ? children.reduce((warnings, ret)=>ret.warnings ? warnings.concat(ret.warnings) : warnings, []) : [], getAssetsFromStats = (stats)=>Object.entries(stats.compilation.assets).map(([name, value])=>({
                name,
                size: value.size()
            }));
    function getStatsOptions(compiler, action) {
        let defaultOptions = {
            all: !1,
            timings: !0,
            errors: !0,
            warnings: !0,
            moduleTrace: !0,
            errorStack: 'verbose' === logger.level
        };
        if ('dev' === action && (defaultOptions = {
            ...defaultOptions,
            hash: !0,
            entrypoints: !0
        }), compiler_isMultiCompiler(compiler)) return {
            ...defaultOptions,
            children: compiler.compilers.map((compiler)=>compiler.options ? compiler.options.stats : void 0)
        };
        let { stats } = compiler.options;
        return 'string' == typeof stats ? {
            ...defaultOptions,
            preset: stats
        } : 'object' == typeof stats ? {
            ...defaultOptions,
            ...stats
        } : defaultOptions;
    }
    function getRsbuildStats(statsInstance, compiler, action) {
        let statsOptions = getStatsOptions(compiler, action);
        return statsInstance.toJson(statsOptions);
    }
    function formatStats(stats, hasErrors) {
        if (hasErrors) return {
            message: formatErrorMessage(getStatsErrors(stats).map((item)=>formatStatsError(item))),
            level: 'error'
        };
        let warningMessages = getStatsWarnings(stats).map((item)=>formatStatsError(item));
        if (warningMessages.length) {
            let title = color.bold(color.yellow(warningMessages.length > 1 ? 'Build warnings: \n' : 'Build warning: \n'));
            return {
                message: `${title}${warningMessages.join('\n\n')}\n`,
                level: 'warning'
            };
        }
        return {};
    }
    let removeLoaderChainDelimiter = (moduleId)=>'verbose' === logger.level ? moduleId : moduleId.split('!=!')[0];
    var external_node_fs_ = __webpack_require__("node:fs"), external_node_fs_default = __webpack_require__.n(external_node_fs_);
    function _define_property(obj, key, value) {
        return key in obj ? Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }) : obj[key] = value, obj;
    }
    class BrowserslistError extends Error {
        constructor(message){
            super(message), _define_property(this, "browserslist", void 0), this.name = 'BrowserslistError', this.browserslist = !0, Error.captureStackTrace && Error.captureStackTrace(this, BrowserslistError);
        }
    }
    let isFileCache = {};
    function isFile(file) {
        if (file in isFileCache) return isFileCache[file];
        let result = external_node_fs_.existsSync(file) && external_node_fs_.statSync(file).isFile();
        return isFileCache[file] = result, result;
    }
    function dist_check(section) {
        let FORMAT = 'Browserslist config should be a string or an array of strings with browser queries';
        if (Array.isArray(section)) {
            for(let i = 0; i < section.length; i++)if ('string' != typeof section[i]) throw new BrowserslistError(FORMAT);
        } else if ('string' != typeof section) throw new BrowserslistError(FORMAT);
    }
    function parsePackage(file) {
        let config = JSON.parse(external_node_fs_.readFileSync(file).toString().replace(/^\uFEFF/m, ''));
        if (config.browserlist && !config.browserslist) throw new BrowserslistError(`\`browserlist\` key instead of \`browserslist\` in ${file}`);
        let list = config.browserslist;
        for(let i in Array.isArray(list) && (list = {
            defaults: list
        }), 'string' == typeof list && (list = parseConfig(list)), list)dist_check(list[i]);
        return list;
    }
    let IS_SECTION = /^\s*\[(.+)]\s*$/;
    function parseConfig(string) {
        let result = {
            defaults: []
        }, sections = [
            'defaults'
        ];
        return string.toString().replace(/#[^\n]*/g, '').split(/\n|,/).map((line)=>line.trim()).filter((line)=>'' !== line).forEach((line)=>{
            let matched = line.match(IS_SECTION);
            matched ? (sections = matched[1].trim().split(' ')).forEach((section)=>{
                if (result[section]) throw new BrowserslistError(`Duplicate section ${section} in Browserslist config`);
                result[section] = [];
            }) : sections.forEach((section)=>{
                result[section].push(line);
            });
        }), result;
    }
    function readConfig(file) {
        if (!isFile(file)) throw new BrowserslistError(`Can't read ${file} config`);
        return parseConfig(external_node_fs_.readFileSync(file, 'utf-8'));
    }
    function parsePackageOrReadConfig(file) {
        return 'package.json' === external_node_path_.basename(file) ? parsePackage(file) : readConfig(file);
    }
    function pickEnv(config, opts) {
        return 'object' != typeof config ? config : config['string' == typeof opts.env ? opts.env : process.env.BROWSERSLIST_ENV ? process.env.BROWSERSLIST_ENV : process.env.NODE_ENV ? process.env.NODE_ENV : 'production'] || config.defaults;
    }
    function eachParent(file, callback) {
        let dir = isFile(file) ? external_node_path_.dirname(file) : file, loc = external_node_path_.resolve(dir);
        do {
            let result = callback(loc);
            if (void 0 !== result) return result;
        }while (loc !== (loc = external_node_path_.dirname(loc)));
    }
    function findConfigFile(from) {
        return eachParent(from, (dir)=>{
            let pkgBrowserslist, config = external_node_path_.join(dir, 'browserslist'), pkg = external_node_path_.join(dir, 'package.json'), rc = external_node_path_.join(dir, '.browserslistrc');
            if (isFile(pkg)) try {
                pkgBrowserslist = parsePackage(pkg);
            } catch (e) {
                if (e instanceof BrowserslistError) throw e;
                console.warn(`[Browserslist] Could not parse ${pkg}. Ignoring it.`);
            }
            if (isFile(config) && pkgBrowserslist) throw new BrowserslistError(`${dir} contains both browserslist and package.json with browsers`);
            if (isFile(rc) && pkgBrowserslist) throw new BrowserslistError(`${dir} contains both .browserslistrc and package.json with browsers`);
            if (isFile(config) && isFile(rc)) throw new BrowserslistError(`${dir} contains both .browserslistrc and browserslist`);
            return isFile(config) ? config : isFile(rc) ? rc : pkgBrowserslist ? pkg : void 0;
        });
    }
    let configCache = {};
    function findConfig(from) {
        let resolved, fromDir = isFile(from = external_node_path_.resolve(from)) ? external_node_path_.dirname(from) : from;
        if (fromDir in configCache) return configCache[fromDir];
        let configFile = findConfigFile(from);
        configFile && (resolved = parsePackageOrReadConfig(configFile));
        let configDir = configFile && external_node_path_.dirname(configFile);
        return eachParent(from, (dir)=>{
            if (resolved && (configCache[dir] = resolved), dir === configDir) return null;
        }), resolved;
    }
    function loadConfig(opts) {
        if (opts.config) return pickEnv(parsePackageOrReadConfig(opts.config), opts);
        if (opts.path) {
            let config = findConfig(opts.path);
            if (!config) return;
            return pickEnv(config, opts);
        }
    }
    function toRelativePath(base, filepath) {
        let relativePath = (0, external_node_path_.relative)(base, filepath);
        return '' === relativePath ? `.${external_node_path_.sep}` : relativePath.startsWith('.') ? relativePath : `.${external_node_path_.sep}${relativePath}`;
    }
    function getCommonParentPath(paths) {
        let uniquePaths = [
            ...new Set(paths)
        ];
        if (1 === uniquePaths.length) return uniquePaths[0];
        let [first, ...rest] = uniquePaths.map((p)=>p.split(external_node_path_.sep)), common = [];
        for(let i = 0; i < first.length; i++){
            let segment = first[i];
            if (rest.every((p)=>p[i] === segment)) common.push(segment);
            else break;
        }
        return common.join(external_node_path_.sep);
    }
    let getCompiledPath = (packageName)=>(0, external_node_path_.join)(COMPILED_PATH, packageName, 'index.js'), ensureAbsolutePath = (base, filePath)=>(0, external_node_path_.isAbsolute)(filePath) ? filePath : (0, external_node_path_.join)(base, filePath), getPathnameFromUrl = (url)=>{
        try {
            return url ? new URL(url, 'http://localhost').pathname : url;
        } catch  {
            return url;
        }
    }, dedupeNestedPaths = (paths)=>paths.sort((p1, p2)=>p2.length > p1.length ? -1 : 1).reduce((prev, curr)=>prev.find((p)=>curr.startsWith(p) || curr === p) ? prev : prev.concat(curr), []), toPosixPath = (filepath)=>'/' === external_node_path_.sep ? filepath : filepath.replace(/\\/g, '/'), normalizeRuleConditionPath = (filepath)=>isWindows && 'string' == typeof filepath && filepath.includes('/') && external_node_path_.win32.isAbsolute(filepath) ? filepath.replace(/\//g, '\\') : filepath, isFileSync = (filePath)=>{
        try {
            return external_node_fs_default().statSync(filePath, {
                throwIfNoEntry: !1
            })?.isFile();
        } catch (_) {
            return !1;
        }
    };
    function isEmptyDir(path) {
        let files = external_node_fs_default().readdirSync(path);
        return 0 === files.length || 1 === files.length && '.git' === files[0];
    }
    let findExists = (files)=>{
        for (let file of files)if (isFileSync(file)) return file;
        return !1;
    };
    async function pathExists(path) {
        return external_node_fs_default().promises.access(path).then(()=>!0).catch(()=>!1);
    }
    async function isFileExists(file) {
        return external_node_fs_default().promises.access(file, external_node_fs_default().constants.F_OK).then(()=>!0).catch(()=>!1);
    }
    async function fileExistsByCompilation({ inputFileSystem }, filePath) {
        return new Promise((resolve)=>{
            inputFileSystem ? inputFileSystem.stat(filePath, (err, stats)=>{
                err ? resolve(!1) : resolve(!!stats?.isFile());
            }) : resolve(!1);
        });
    }
    async function emptyDir(dir, keep = [], checkExists = !0) {
        if (!checkExists || await pathExists(dir)) try {
            let entries = await external_node_fs_default().promises.readdir(dir, {
                withFileTypes: !0
            });
            await Promise.all(entries.map(async (entry)=>{
                let fullPath = external_node_path_default().join(dir, entry.name);
                !keep.some((reg)=>reg.test(toPosixPath(fullPath))) && (entry.isDirectory() ? (await emptyDir(fullPath, keep, !1), keep.length || await external_node_fs_default().promises.rmdir(fullPath)) : await external_node_fs_default().promises.unlink(fullPath));
            }));
        } catch (err) {
            logger.debug(`failed to empty dir: ${dir}`), logger.debug(err);
        }
    }
    let OVERRIDE_PATHS = new Set([
        'performance.removeConsole',
        'output.inlineScripts',
        'output.inlineStyles',
        'output.cssModules.auto',
        'output.overrideBrowserslist',
        'server.open',
        'server.printUrls',
        'resolve.extensions',
        'resolve.conditionNames',
        'resolve.mainFields',
        'provider'
    ]), merge = (x, y, path = '')=>{
        if (((key)=>{
            if (key.startsWith('environments.')) {
                let realKey = key.split('.').slice(2).join('.');
                return OVERRIDE_PATHS.has(realKey);
            }
            return OVERRIDE_PATHS.has(key) || key.startsWith('output.filename.');
        })(path)) return y ?? x;
        if (void 0 === x) return isPlainObject(y) ? cloneDeep(y) : y;
        if (void 0 === y) return isPlainObject(x) ? cloneDeep(x) : x;
        let typeX = typeof x, typeY = typeof y;
        if ('boolean' === typeX || 'boolean' === typeY) return y;
        let isArrayX = Array.isArray(x), isArrayY = Array.isArray(y);
        if (isArrayX && isArrayY) return x.concat(y);
        if (isArrayX) return [
            ...x,
            y
        ];
        if (isArrayY) return [
            x,
            ...y
        ];
        if ('function' === typeX || 'function' === typeY) return [
            x,
            y
        ];
        if (!isPlainObject(x) || !isPlainObject(y)) return y;
        let merged = {};
        for (let key of new Set([
            ...Object.keys(x),
            ...Object.keys(y)
        ])){
            let childPath = path ? `${path}.${key}` : key;
            merged[key] = merge(x[key], y[key], childPath);
        }
        return merged;
    }, normalizeConfigStructure = (config)=>{
        let { dev, output } = config, normalizedConfig = {
            ...config
        };
        return output && (Array.isArray((output = {
            ...output
        }).copy) && (output.copy = {
            patterns: output.copy
        }), 'string' == typeof output.distPath && (output.distPath = {
            root: output.distPath
        }), normalizedConfig.output = output), dev && ((dev = {
            ...dev
        }).watchFiles && !Array.isArray(dev.watchFiles) && (dev.watchFiles = [
            dev.watchFiles
        ]), normalizedConfig.dev = dev), normalizedConfig;
    }, mergeRsbuildConfig = (...originalConfigs)=>{
        let configs = originalConfigs.filter((config)=>void 0 !== config).map(normalizeConfigStructure);
        return 2 === configs.length ? merge(configs[0], configs[1]) : 1 === configs.length ? configs[0] : 0 === configs.length ? {} : configs.reduce((result, config)=>merge(result, config), {});
    }, defaultConfig_require = (0, external_node_module_.createRequire)(__rslib_import_meta_url__), defaultAllowedOrigins = /^https?:\/\/(?:(?:[^:]+\.)?localhost|127\.0\.0\.1|\[::1\])(?::\d+)?$/, createDefaultConfig = ()=>({
            dev: {
                hmr: !0,
                liveReload: !0,
                browserLogs: {
                    stackTrace: 'summary'
                },
                watchFiles: [],
                assetPrefix: DEFAULT_ASSET_PREFIX,
                writeToDisk: !1,
                cliShortcuts: !1,
                client: {
                    path: '/rsbuild-hmr',
                    port: '',
                    host: '',
                    overlay: !0,
                    reconnect: 100
                }
            },
            server: {
                port: 3000,
                host: DEFAULT_DEV_HOST,
                open: !1,
                base: '/',
                htmlFallback: 'index',
                compress: !0,
                printUrls: !0,
                strictPort: !1,
                cors: {
                    origin: defaultAllowedOrigins
                },
                middlewareMode: !1
            },
            html: {
                meta: {
                    charset: {
                        charset: 'UTF-8'
                    },
                    viewport: 'width=device-width, initial-scale=1.0'
                },
                title: 'Rsbuild App',
                inject: 'head',
                mountId: 'root',
                crossorigin: !1,
                outputStructure: 'flat',
                scriptLoading: 'defer',
                implementation: 'js'
            },
            resolve: (swcHelpersPath || (swcHelpersPath = (0, external_node_path_.dirname)(defaultConfig_require.resolve('@swc/helpers/package.json'))), {
                alias: {
                    '@swc/helpers': swcHelpersPath
                },
                aliasStrategy: 'prefer-tsconfig',
                extensions: [
                    '.ts',
                    '.tsx',
                    '.mjs',
                    '.js',
                    '.jsx',
                    '.json'
                ]
            }),
            source: {
                define: {},
                preEntry: [],
                decorators: {
                    version: '2022-03'
                }
            },
            output: {
                target: 'web',
                cleanDistPath: 'auto',
                distPath: {
                    root: ROOT_DIST_DIR,
                    css: 'static/css',
                    svg: 'static/svg',
                    font: 'static/font',
                    html: './',
                    wasm: 'static/wasm',
                    image: 'static/image',
                    media: 'static/media',
                    assets: 'static/assets',
                    favicon: './'
                },
                assetPrefix: DEFAULT_ASSET_PREFIX,
                filename: {},
                charset: 'utf8',
                polyfill: 'off',
                dataUriLimit: {
                    svg: 4096,
                    font: 4096,
                    image: 4096,
                    media: 4096,
                    assets: 4096
                },
                legalComments: 'linked',
                injectStyles: !1,
                minify: !0,
                module: !1,
                manifest: !1,
                sourceMap: {
                    js: void 0,
                    css: !1
                },
                filenameHash: !0,
                inlineScripts: !1,
                inlineStyles: !1,
                cssModules: {
                    auto: !0,
                    namedExport: !1,
                    exportGlobals: !1,
                    exportLocalsConvention: 'camelCase'
                },
                emitAssets: !0
            },
            tools: {
                cssExtract: {
                    loaderOptions: {},
                    pluginOptions: {
                        ignoreOrder: !0
                    }
                }
            },
            security: {
                nonce: '',
                sri: {
                    enable: !1
                }
            },
            performance: {
                profile: !1,
                printFileSize: !0,
                removeConsole: !1,
                removeMomentLocale: !1,
                chunkSplit: {
                    strategy: 'split-by-experience'
                }
            },
            environments: {}
        });
    function getDefaultEntry(root) {
        let entryFile = findExists([
            'ts',
            'js',
            'tsx',
            'jsx',
            'mts',
            'cts',
            'mjs',
            'cjs'
        ].map((ext)=>(0, external_node_path_.join)(root, `src/index.${ext}`)));
        return entryFile ? {
            index: entryFile
        } : {};
    }
    let withDefaultConfig = async (rootPath, config)=>{
        let merged = mergeRsbuildConfig(createDefaultConfig(), config);
        if (merged.root ||= rootPath, merged.source ||= {}, merged.server?.base && (config.dev?.assetPrefix === void 0 && (merged.dev ||= {}, merged.dev.assetPrefix = merged.server.base), config.output?.assetPrefix === void 0 && (merged.output ||= {}, merged.output.assetPrefix = merged.server.base)), merged.dev?.lazyCompilation === void 0 && (merged.dev ||= {}, merged.dev.lazyCompilation = {
            imports: !0,
            entries: !1
        }), !merged.source.tsconfigPath) {
            let tsconfigPath = (0, external_node_path_.join)(rootPath, 'tsconfig.json');
            await isFileExists(tsconfigPath) && (merged.source.tsconfigPath = tsconfigPath);
        }
        return merged;
    }, normalizePublicDirs = (rootPath, publicDir)=>{
        if (!1 === publicDir) return [];
        let defaultConfig = {
            name: (0, external_node_path_.join)(rootPath, 'public'),
            copyOnBuild: 'auto',
            watch: !1
        };
        if (void 0 === publicDir) return [
            defaultConfig
        ];
        let mergeWithDefault = (options)=>{
            if ('' === options.name) throw Error('[rsbuild:config] `publicDir.name` cannot be empty string.');
            let merged = {
                ...defaultConfig,
                ...options
            };
            return (0, external_node_path_.isAbsolute)(merged.name) || (merged.name = (0, external_node_path_.join)(rootPath, merged.name)), merged;
        };
        return Array.isArray(publicDir) ? publicDir.map((options)=>mergeWithDefault(options)) : [
            mergeWithDefault(publicDir)
        ];
    };
    var external_node_os_ = __webpack_require__("node:os"), external_node_os_default = __webpack_require__.n(external_node_os_), external_node_process_ = __webpack_require__("node:process"), external_node_process_default = __webpack_require__.n(external_node_process_);
    let exitHook_callbacks = new Set(), isCalled = !1, isRegistered = !1;
    function exit(exitCode, type) {
        if (!isCalled) {
            for (let callback of (isCalled = !0, exitHook_callbacks))callback(exitCode);
            if ('SIGINT' === type) {
                let listeners = external_node_process_default().listeners('SIGINT');
                Array.isArray(listeners) && listeners.length <= 1 && external_node_process_default().exit(exitCode);
            }
        }
    }
    function exitHook(onExit) {
        return exitHook_callbacks.add(onExit), isRegistered || (isRegistered = !0, external_node_process_default().on('SIGINT', ()=>{
            exit(external_node_os_.constants.signals.SIGINT + 128, 'SIGINT');
        }), external_node_process_default().once('SIGTERM', ()=>{
            exit(external_node_os_.constants.signals.SIGTERM + 128, 'SIGTERM');
        }), external_node_process_default().once('exit', (exitCode)=>{
            exit(exitCode, 'exit');
        })), ()=>{
            exitHook_callbacks.delete(onExit);
        };
    }
    let addTrailingSlash = (s)=>s.endsWith('/') ? s : `${s}/`, isURL = (str)=>str.startsWith('http') || str.startsWith('//'), urlJoin = (base, path)=>{
        let [urlProtocol, baseUrl] = base.split('://');
        return `${urlProtocol}://${external_node_path_.posix.join(baseUrl, path)}`;
    }, canParse = (url)=>{
        try {
            return new external_node_url_.URL(url), !0;
        } catch  {
            return !1;
        }
    }, ensureAssetPrefix = (url, assetPrefix = DEFAULT_ASSET_PREFIX)=>url.startsWith('//') || canParse(url) || 'auto' === assetPrefix || 'function' == typeof assetPrefix ? url : assetPrefix.startsWith('http') ? urlJoin(assetPrefix, url) : assetPrefix.startsWith('//') ? urlJoin(`https:${assetPrefix}`, url).replace('https:', '') : external_node_path_.posix.join(assetPrefix, url), formatPublicPath = (publicPath, withSlash = !0)=>'auto' === publicPath ? publicPath : withSlash ? addTrailingSlash(publicPath) : publicPath.replace(/\/+$/, ''), getPublicPathFromChain = (chain, withSlash = !0)=>{
        let publicPath = chain.output.get('publicPath');
        return 'string' == typeof publicPath ? formatPublicPath(publicPath, withSlash) : formatPublicPath(DEFAULT_ASSET_PREFIX, withSlash);
    };
    function validatePlugin(plugin) {
        let type = typeof plugin;
        if ('object' !== type || null === plugin) throw Error(`${color.dim('[rsbuild:plugin]')} Expect Rsbuild plugin instance to be an object, but got ${color.yellow(type)}.`);
        if (!isFunction(plugin.setup)) {
            if (isFunction(plugin.apply)) {
                let { name = 'SomeWebpackPlugin' } = plugin.constructor || {};
                throw Error([
                    `${color.yellow(name)} looks like a webpack or Rspack plugin, please use ${color.yellow('`tools.rspack`')} to register it:`,
                    color.green(`
  // rsbuild.config.ts
  export default {
    tools: {
      rspack: {
        plugins: [new ${name}()]
      }
    }
  };
`)
                ].join('\n'));
            }
            throw Error(`${color.dim('[rsbuild:plugin]')} Expect the setup function of Rsbuild plugin to be a function, but got ${color.yellow(type)}.`);
        }
    }
    let isEnvironmentMatch = (pluginEnvironment, specifiedEnvironment)=>pluginEnvironment === specifiedEnvironment || void 0 === pluginEnvironment;
    function createPluginManager() {
        let plugins = [];
        return {
            getPlugins: (options = {})=>plugins.filter((plugin)=>isEnvironmentMatch(plugin.environment, options.environment)).map(({ instance })=>instance),
            getAllPluginsWithMeta: ()=>plugins,
            addPlugins: (newPlugins, options)=>{
                let { before, environment } = options || {};
                for (let newPlugin of newPlugins)if (newPlugin) if (validatePlugin(newPlugin), before) {
                    let index = plugins.findIndex((item)=>item.instance.name === before);
                    -1 === index ? (logger.warn(`Plugin "${before}" does not exist.`), plugins.push({
                        environment,
                        instance: newPlugin
                    })) : plugins.splice(index, 0, {
                        environment,
                        instance: newPlugin
                    });
                } else plugins.push({
                    environment,
                    instance: newPlugin
                });
            },
            removePlugins: (pluginNames, options = {})=>{
                plugins = plugins.filter((plugin)=>!(pluginNames.includes(plugin.instance.name) && (!options.environment || plugin.environment === options.environment)));
            },
            isPluginExists: (pluginName, options = {})=>plugins.some((plugin)=>plugin.instance.name === pluginName && isEnvironmentMatch(plugin.environment, options.environment))
        };
    }
    async function initPlugins({ context, pluginManager }) {
        logger.debug('initializing plugins');
        let plugins = pluginManager.getAllPluginsWithMeta();
        plugins = ((plugins)=>{
            let allLines = [];
            function getPlugin(name) {
                let targets = plugins.filter((item)=>item.instance.name === name);
                if (!targets.length) throw Error(`${color.dim('[rsbuild:plugin]')} Plugin "${color.yellow(name)}" not existed`);
                return targets;
            }
            for (let plugin of plugins){
                if (plugin.instance.pre) for (let pre of plugin.instance.pre)pre && plugins.some((item)=>item.instance.name === pre) && allLines.push([
                    pre,
                    plugin.instance.name
                ]);
                if (plugin.instance.post) for (let post of plugin.instance.post)post && plugins.some((item)=>item.instance.name === post) && allLines.push([
                    plugin.instance.name,
                    post
                ]);
            }
            let zeroEndPoints = plugins.filter((item)=>!allLines.find((l)=>l[1] === item.instance.name)), sortedPoint = [];
            for(; zeroEndPoints.length;){
                let pluginInstances = getPlugin(zeroEndPoints.shift().instance.name);
                sortedPoint.push(...pluginInstances), allLines = allLines.filter((l)=>l[0] !== pluginInstances[0].instance.name), zeroEndPoints = plugins.filter((item)=>!sortedPoint.find((sp)=>sp.instance.name === item.instance.name)).filter((item)=>!allLines.find((l)=>l[1] === item.instance.name));
            }
            if (allLines.length) {
                let restInRingPoints = {};
                for (let l of allLines)restInRingPoints[l[0]] = !0, restInRingPoints[l[1]] = !0;
                throw Error(`${color.dim('[rsbuild:plugin]')} Plugins dependencies has loop: ${color.yellow(Object.keys(restInRingPoints).join(','))}`);
            }
            return sortedPoint;
        })(plugins = ((plugins)=>{
            let prePlugins = [], normalPlugins = [], postPlugins = [];
            for (let plugin of plugins){
                let { enforce } = plugin.instance;
                'pre' === enforce ? prePlugins.push(plugin) : 'post' === enforce ? postPlugins.push(plugin) : normalPlugins.push(plugin);
            }
            return [
                ...prePlugins,
                ...normalPlugins,
                ...postPlugins
            ];
        })(plugins));
        let removedPlugins = new Set(), removedEnvPlugins = {};
        for (let { environment, instance } of plugins)if (instance.remove) if (environment) for (let item of (removedEnvPlugins[environment] ??= new Set(), instance.remove))removedEnvPlugins[environment].add(item);
        else for (let item of instance.remove)removedPlugins.add(item);
        for (let { instance, environment } of plugins){
            let { name, setup } = instance;
            if (!(removedPlugins.has(name) || environment && removedEnvPlugins[environment]?.has(name))) {
                if (instance.apply && context.action) if (isFunction(instance.apply)) {
                    if (!instance.apply(context.originalConfig, {
                        action: context.action
                    })) continue;
                } else {
                    let expected = {
                        build: 'build',
                        dev: 'serve',
                        preview: 'serve'
                    }[context.action];
                    if (expected && instance.apply !== expected) continue;
                }
                await setup(context.getPluginAPI(environment));
            }
        }
        logger.debug('plugins initialized');
    }
    function getHTMLPathByEntry(entryName, config) {
        let filename = getFilename(config, 'html').replace('[name]', entryName), prefix = config.output.distPath.html;
        return prefix.startsWith('/') && logger.warn(`${color.dim('[rsbuild:config]')} Absolute path is not recommended at ${color.yellow(`output.distPath.html: "${prefix}"`)}, use relative path instead.`), external_node_path_.posix.join(prefix, filename).replace(/^\/+/, '');
    }
    let mapProcessAssetsStage = (compiler, stage)=>{
        let { Compilation } = compiler.webpack;
        switch(stage){
            case 'additional':
                return Compilation.PROCESS_ASSETS_STAGE_ADDITIONAL;
            case 'pre-process':
                return Compilation.PROCESS_ASSETS_STAGE_PRE_PROCESS;
            case 'derived':
                return Compilation.PROCESS_ASSETS_STAGE_DERIVED;
            case 'additions':
                return Compilation.PROCESS_ASSETS_STAGE_ADDITIONS;
            case 'none':
                return Compilation.PROCESS_ASSETS_STAGE_NONE;
            case 'optimize':
                return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE;
            case 'optimize-count':
                return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COUNT;
            case 'optimize-compatibility':
                return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_COMPATIBILITY;
            case 'optimize-size':
                return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_SIZE;
            case 'dev-tooling':
                return Compilation.PROCESS_ASSETS_STAGE_DEV_TOOLING;
            case 'optimize-inline':
                return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_INLINE;
            case 'summarize':
                return Compilation.PROCESS_ASSETS_STAGE_SUMMARIZE;
            case 'optimize-hash':
                return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_HASH;
            case 'optimize-transfer':
                return Compilation.PROCESS_ASSETS_STAGE_OPTIMIZE_TRANSFER;
            case 'analyse':
                return Compilation.PROCESS_ASSETS_STAGE_ANALYSE;
            case 'report':
                return Compilation.PROCESS_ASSETS_STAGE_REPORT;
            default:
                throw Error(`${color.dim('[rsbuild]')} Invalid process assets stage: ${stage}`);
        }
    };
    function initPluginAPI({ context, pluginManager }) {
        let { hooks } = context, publicContext = createPublicContext(context);
        function getNormalizedConfig(options) {
            if (context.normalizedConfig) {
                if (options?.environment) {
                    let config = context.normalizedConfig.environments[options.environment];
                    if (!config) throw Error(`${color.dim('[rsbuild]')} Cannot find normalized config by environment: ${options.environment}.`);
                    return config;
                }
                return context.normalizedConfig;
            }
            throw Error(`${color.dim('[rsbuild]')} Cannot access normalized config until ${color.yellow('modifyRsbuildConfig')} is called.`);
        }
        let getRsbuildConfig = (type = 'current')=>{
            switch(type){
                case 'original':
                    return context.originalConfig;
                case 'current':
                    return context.config;
                case 'normalized':
                    return getNormalizedConfig();
            }
            throw Error(`${color.dim('[rsbuild]')} ${color.yellow('getRsbuildConfig')} get an invalid type param.`);
        }, exposed = [], expose = (id, api)=>{
            exposed.push({
                id,
                api
            });
        }, useExposed = (id)=>{
            let matched = exposed.find((item)=>item.id === id);
            if (matched) return matched.api;
        }, transformId = 0, transformer = {}, processAssetsFns = [], resolveFns = [];
        hooks.modifyBundlerChain.tap((chain, { target, environment })=>{
            let pluginName = 'RsbuildCorePlugin';
            chain.plugin(pluginName).use(class {
                name = pluginName;
                apply(compiler) {
                    for (let { handler, environment: pluginEnvironment } of (compiler.__rsbuildTransformer = transformer, resolveFns))(!pluginEnvironment || isEnvironmentMatch(pluginEnvironment, environment.name)) && compiler.hooks.compilation.tap(pluginName, (compilation, { normalModuleFactory })=>{
                        normalModuleFactory.hooks.resolve.tapPromise(pluginName, async (resolveData)=>handler({
                                compiler,
                                compilation,
                                environment,
                                resolveData
                            }));
                    });
                    compiler.hooks.thisCompilation.tap(pluginName, (compilation)=>{
                        compilation.hooks.childCompiler.tap(pluginName, (childCompiler)=>{
                            childCompiler.__rsbuildTransformer = transformer;
                        });
                        let { sources } = compiler.webpack;
                        for (let { descriptor, handler, environment: pluginEnvironment } of processAssetsFns)(!descriptor.targets || descriptor.targets.includes(target)) && (!descriptor.environments || descriptor.environments.includes(environment.name)) && (!pluginEnvironment || isEnvironmentMatch(pluginEnvironment, environment.name)) && compilation.hooks.processAssets.tapPromise({
                            name: pluginName,
                            stage: mapProcessAssetsStage(compiler, descriptor.stage)
                        }, async (assets)=>handler({
                                assets,
                                compiler,
                                compilation,
                                environment,
                                sources
                            }));
                    });
                }
            });
        });
        let onExitListened = !1, onExit = (cb)=>{
            onExitListened || (exitHook((exitCode)=>{
                hooks.onExit.callBatch({
                    exitCode
                });
            }), onExitListened = !0), hooks.onExit.tap(cb);
        };
        return (environment)=>{
            let environment1, environment2, environment3;
            return {
                context: publicContext,
                expose,
                logger: logger,
                transform: (environment1 = environment, (descriptor, handler)=>{
                    let id = `rsbuild-transform-${transformId++}`;
                    transformer[id] = handler, hooks.modifyBundlerChain.tapEnvironment({
                        environment: environment1,
                        handler: (chain, { target, environment: environmentContext })=>{
                            if (descriptor.targets && !descriptor.targets.includes(target) || descriptor.environments && !descriptor.environments.includes(environmentContext.name)) return;
                            let rule = chain.module.rule(id);
                            descriptor.test && rule.test(descriptor.test), descriptor.resourceQuery && rule.resourceQuery(descriptor.resourceQuery), descriptor.layer && rule.layer(descriptor.layer), descriptor.issuerLayer && rule.issuerLayer(descriptor.issuerLayer), descriptor.issuer && rule.issuer(descriptor.issuer), descriptor.with && rule.with(descriptor.with), descriptor.mimetype && rule.mimetype(descriptor.mimetype), descriptor.order && 'default' !== descriptor.order ? rule.enforce(descriptor.order) : descriptor.enforce && rule.enforce(descriptor.enforce);
                            let loaderName = descriptor.raw ? 'transformRawLoader.mjs' : 'transformLoader.mjs', loaderPath = (0, external_node_path_.join)(LOADER_PATH, loaderName);
                            rule.use(id).loader(loaderPath).options({
                                id,
                                getEnvironment: ()=>environmentContext
                            });
                        }
                    });
                }),
                useExposed,
                processAssets: (environment2 = environment, (descriptor, handler)=>{
                    processAssetsFns.push({
                        environment: environment2,
                        descriptor,
                        handler
                    });
                }),
                resolve: (environment3 = environment, (handler)=>{
                    resolveFns.push({
                        environment: environment3,
                        handler
                    });
                }),
                getRsbuildConfig,
                getNormalizedConfig,
                isPluginExists: pluginManager.isPluginExists,
                onExit,
                onAfterBuild: hooks.onAfterBuild.tap,
                onCloseBuild: hooks.onCloseBuild.tap,
                onBeforeBuild: hooks.onBeforeBuild.tap,
                onCloseDevServer: hooks.onCloseDevServer.tap,
                onBeforeDevCompile: hooks.onBeforeDevCompile.tap,
                onAfterDevCompile: hooks.onAfterDevCompile.tap,
                onDevCompileDone: hooks.onAfterDevCompile.tap,
                onAfterCreateCompiler: hooks.onAfterCreateCompiler.tap,
                onAfterStartDevServer: hooks.onAfterStartDevServer.tap,
                onBeforeCreateCompiler: hooks.onBeforeCreateCompiler.tap,
                onBeforeStartDevServer: hooks.onBeforeStartDevServer.tap,
                onAfterStartProdServer: hooks.onAfterStartProdServer.tap,
                onBeforeStartProdServer: hooks.onBeforeStartProdServer.tap,
                modifyRsbuildConfig: hooks.modifyRsbuildConfig.tap,
                modifyHTML: (handler)=>{
                    hooks.modifyHTML.tapEnvironment({
                        environment,
                        handler
                    });
                },
                modifyHTMLTags: (handler)=>{
                    hooks.modifyHTMLTags.tapEnvironment({
                        environment,
                        handler
                    });
                },
                modifyBundlerChain: (handler)=>{
                    hooks.modifyBundlerChain.tapEnvironment({
                        environment,
                        handler
                    });
                },
                modifyRspackConfig: (handler)=>{
                    hooks.modifyRspackConfig.tapEnvironment({
                        environment,
                        handler
                    });
                },
                modifyWebpackChain: (handler)=>{
                    hooks.modifyWebpackChain.tapEnvironment({
                        environment,
                        handler
                    });
                },
                modifyWebpackConfig: (handler)=>{
                    hooks.modifyWebpackConfig.tapEnvironment({
                        environment,
                        handler
                    });
                },
                modifyEnvironmentConfig: (handler)=>{
                    hooks.modifyEnvironmentConfig.tapEnvironment({
                        environment,
                        handler
                    });
                },
                onAfterEnvironmentCompile: (handler)=>{
                    hooks.onAfterEnvironmentCompile.tapEnvironment({
                        environment,
                        handler
                    });
                },
                onBeforeEnvironmentCompile: (handler)=>{
                    hooks.onBeforeEnvironmentCompile.tapEnvironment({
                        environment,
                        handler
                    });
                }
            };
        };
    }
    function getAbsoluteDistPath(cwd, config) {
        return ensureAbsolutePath(cwd, config.output?.distPath?.root ?? ROOT_DIST_DIR);
    }
    let browsersListCache = new Map();
    function getBrowserslist(path) {
        let env = process.env.NODE_ENV, cacheKey = path + env;
        if (browsersListCache.has(cacheKey)) return browsersListCache.get(cacheKey);
        let result = loadConfig({
            path,
            env
        });
        return result ? (browsersListCache.set(cacheKey, result), result) : null;
    }
    function getBrowserslistByEnvironment(path, config) {
        let { target, overrideBrowserslist } = config.output;
        if (Array.isArray(overrideBrowserslist)) return overrideBrowserslist;
        if ('web' === target || 'web-worker' === target) {
            let browserslistrc = getBrowserslist(path);
            if (browserslistrc) return browserslistrc;
        }
        return DEFAULT_BROWSERSLIST[target];
    }
    let getEnvironmentHTMLPaths = (entry, config)=>'web' !== config.output.target || !1 === config.tools.htmlPlugin ? {} : Object.keys(entry).reduce((prev, key)=>{
            let entryValue = entry[key];
            return ('string' == typeof entryValue || Array.isArray(entryValue) || !1 !== entryValue.html) && (prev[key] = getHTMLPathByEntry(key, config)), prev;
        }, {});
    async function updateEnvironmentContext(context, configs) {
        for (let [index, [name, config]] of (context.environments ||= {}, Object.entries(configs).entries())){
            let browserslist = getBrowserslistByEnvironment(context.rootPath, config), { entry = {}, tsconfigPath } = config.source, htmlPaths = getEnvironmentHTMLPaths(entry, config), webSocketToken = 'dev' === context.action ? await helpers_hash(context.rootPath + name) : '', environmentContext = {
                index,
                name,
                distPath: getAbsoluteDistPath(context.rootPath, config),
                entry,
                browserslist,
                htmlPaths,
                tsconfigPath,
                config,
                webSocketToken
            }, readonlyEnvironmentContext = new Proxy(environmentContext, {
                get: (target, prop)=>target[prop],
                set: (target, prop, newValue)=>('manifest' === prop ? target[prop] = newValue : logger.error(`EnvironmentContext is readonly, you can not assign to the "environment.${prop}" prop.`), !0)
            });
            context.environmentList[index] = readonlyEnvironmentContext, context.environments[name] = readonlyEnvironmentContext;
        }
    }
    function updateContextByNormalizedConfig(context) {
        let distPaths = context.environmentList.map((item)=>item.distPath);
        context.distPath = getCommonParentPath(distPaths);
    }
    function createPublicContext(context) {
        let exposedKeys = [
            'action',
            'version',
            'rootPath',
            'distPath',
            'devServer',
            'cachePath',
            'callerName',
            'bundlerType'
        ];
        return new Proxy(context, {
            get (target, prop) {
                if (exposedKeys.includes(prop)) return target[prop];
            },
            set: (_, prop)=>(logger.error(`Context is readonly, you can not assign to the "context.${prop}" prop.`), !0)
        });
    }
    async function createContext(options, userConfig) {
        let { cwd } = options, rootPath = userConfig.root ? ensureAbsolutePath(cwd, userConfig.root) : cwd, rsbuildConfig = await withDefaultConfig(rootPath, userConfig), cachePath = (0, external_node_path_.join)(rootPath, 'node_modules', '.cache'), specifiedEnvironments = options.environment && options.environment.length > 0 ? options.environment : void 0, bundlerType = userConfig.provider ? 'webpack' : 'rspack';
        return {
            version: "1.6.7",
            rootPath,
            distPath: '',
            cachePath,
            callerName: options.callerName,
            bundlerType,
            environments: {},
            environmentList: [],
            publicPathnames: [],
            hooks: initHooks(),
            config: {
                ...rsbuildConfig
            },
            originalConfig: userConfig,
            specifiedEnvironments,
            buildState: {
                stats: null,
                status: 'idle',
                hasErrors: !1
            }
        };
    }
    let normalizePluginObject = (plugin)=>{
        let { setup: _, ...rest } = plugin;
        return {
            ...rest,
            setup () {}
        };
    };
    async function outputInspectConfigFiles({ rawBundlerConfigs, rawEnvironmentConfigs, inspectOptions, rawExtraConfigs, configType }) {
        let { outputPath } = inspectOptions, files = [
            ...rawEnvironmentConfigs.map(({ name, content })=>{
                if (1 === rawEnvironmentConfigs.length) return {
                    path: (0, external_node_path_.join)(outputPath, 'rsbuild.config.mjs'),
                    label: 'Rsbuild config',
                    content
                };
                let outputFile = `rsbuild.config.${name}.mjs`;
                return {
                    path: (0, external_node_path_.join)(outputPath, outputFile),
                    label: `Rsbuild config (${name})`,
                    content
                };
            }),
            ...rawBundlerConfigs.map(({ name, content })=>{
                let outputFile = `${configType}.config.${name}.mjs`, outputFilePath = (0, external_node_path_.join)(outputPath, outputFile);
                return external_node_fs_default().existsSync(outputFilePath) && (outputFilePath = outputFilePath.replace(/\.mjs$/, `.${Date.now()}.mjs`)), {
                    path: outputFilePath,
                    label: `${upperFirst(configType)} Config (${name})`,
                    content
                };
            }),
            ...(rawExtraConfigs || []).map(({ name, content })=>({
                    path: (0, external_node_path_.join)(outputPath, `${name}.config.mjs`),
                    label: `${upperFirst(name)} Config`,
                    content
                }))
        ];
        await external_node_fs_default().promises.mkdir(outputPath, {
            recursive: !0
        }), await Promise.all(files.map(async (item)=>external_node_fs_default().promises.writeFile(item.path, `export default ${item.content}`)));
        let fileInfos = files.map((item)=>`  - ${color.bold(color.yellow(item.label))}: ${color.underline(item.path)}`).join('\n');
        logger.success(`config inspection completed, generated files: \n\n${fileInfos}\n`);
    }
    function stringifyConfig(config, verbose) {
        return src_class.toString(config, {
            verbose
        });
    }
    async function inspectConfig_inspectConfig({ context, pluginManager, bundlerConfigs, inspectOptions = {}, bundler = 'rspack' }) {
        var context1, inspectOptions1;
        inspectOptions.mode ? setNodeEnv(inspectOptions.mode) : process.env.NODE_ENV || setNodeEnv('development');
        let rawBundlerConfigs = bundlerConfigs.map((config, index)=>({
                name: config.name || String(index),
                content: stringifyConfig(config, inspectOptions.verbose)
            })), { rsbuildConfig, rawRsbuildConfig, environmentConfigs, rawEnvironmentConfigs } = (({ normalizedConfig, inspectOptions, pluginManager })=>{
            let { environments, ...rsbuildConfig } = normalizedConfig, rawRsbuildConfig = stringifyConfig({
                ...rsbuildConfig,
                plugins: pluginManager.getPlugins().map(normalizePluginObject)
            }, inspectOptions.verbose), environmentConfigs = {}, rawEnvironmentConfigs = [];
            for (let [name, config] of Object.entries(environments)){
                let debugConfig = {
                    ...config,
                    plugins: pluginManager.getPlugins({
                        environment: name
                    }).map(normalizePluginObject)
                };
                rawEnvironmentConfigs.push({
                    name,
                    content: stringifyConfig(debugConfig, inspectOptions.verbose)
                }), environmentConfigs[name] = debugConfig;
            }
            return {
                rsbuildConfig,
                rawRsbuildConfig,
                environmentConfigs: environments,
                rawEnvironmentConfigs
            };
        })({
            normalizedConfig: context.normalizedConfig,
            inspectOptions,
            pluginManager
        }), outputPath = (context1 = context, (inspectOptions1 = inspectOptions).outputPath ? (0, external_node_path_.isAbsolute)(inspectOptions1.outputPath) ? inspectOptions1.outputPath : (0, external_node_path_.join)(context1.distPath, inspectOptions1.outputPath) : (0, external_node_path_.join)(context1.distPath, RSBUILD_OUTPUTS_PATH)), rawExtraConfigs = inspectOptions.extraConfigs ? Object.entries(inspectOptions.extraConfigs).map(([name, content])=>({
                name,
                content: 'string' == typeof content ? content : stringifyConfig(content, inspectOptions.verbose)
            })) : void 0;
        return inspectOptions.writeToDisk && await outputInspectConfigFiles({
            rawBundlerConfigs,
            rawEnvironmentConfigs,
            rawExtraConfigs,
            inspectOptions: {
                ...inspectOptions,
                outputPath
            },
            configType: bundler
        }), {
            rsbuildConfig: rawRsbuildConfig,
            environmentConfigs: rawEnvironmentConfigs.map((r)=>r.content),
            bundlerConfigs: rawBundlerConfigs.map((r)=>r.content),
            origin: {
                rsbuildConfig,
                environmentConfigs,
                bundlerConfigs
            }
        };
    }
    let dist_isPlainObject = (obj)=>{
        let obj1;
        return null !== (obj1 = obj) && 'object' == typeof obj1 && '[object Object]' === Object.prototype.toString.call(obj);
    };
    function reduceConfigs({ initial, config, mergeFn = Object.assign }) {
        return null == config ? initial : dist_isPlainObject(config) ? dist_isPlainObject(initial) ? mergeFn(initial, config) : config : 'function' == typeof config ? config(initial) ?? initial : Array.isArray(config) ? config.reduce((initial, config)=>reduceConfigs({
                initial,
                config,
                mergeFn
            }), initial) : config ?? initial;
    }
    function reduceConfigsWithContext({ initial, config, ctx, mergeFn = Object.assign }) {
        return null == config ? initial : dist_isPlainObject(config) ? dist_isPlainObject(initial) ? mergeFn(initial, config) : config : 'function' == typeof config ? config(initial, ctx) ?? initial : Array.isArray(config) ? config.reduce((initial, config)=>reduceConfigsWithContext({
                initial,
                config,
                ctx,
                mergeFn
            }), initial) : config ?? initial;
    }
    async function reduceConfigsAsyncWithContext({ initial, config, ctx, mergeFn = Object.assign }) {
        return null == config ? initial : dist_isPlainObject(config) ? dist_isPlainObject(initial) ? mergeFn(initial, config) : config : 'function' == typeof config ? await config(initial, ctx) ?? initial : Array.isArray(config) ? config.reduce((initial, config)=>reduceConfigsWithContext({
                initial,
                config,
                ctx,
                mergeFn
            }), initial) : config ?? initial;
    }
    function reduceConfigsMergeContext({ initial, config, ctx, mergeFn = Object.assign }) {
        return null == config ? initial : dist_isPlainObject(config) ? dist_isPlainObject(initial) ? mergeFn(initial, config) : config : 'function' == typeof config ? config({
            value: initial,
            ...ctx
        }) ?? initial : Array.isArray(config) ? config.reduce((initial, config)=>reduceConfigsMergeContext({
                initial,
                config,
                ctx,
                mergeFn
            }), initial) : config ?? initial;
    }
    var webpack_merge_dist = __webpack_require__("../../node_modules/.pnpm/webpack-merge@6.0.1/node_modules/webpack-merge/dist/index.js");
    async function modifyBundlerChain(context, utils) {
        logger.debug('applying modifyBundlerChain hook');
        let bundlerChain = new src_class(), [modifiedBundlerChain] = await context.hooks.modifyBundlerChain.callChain({
            environment: utils.environment.name,
            args: [
                bundlerChain,
                utils
            ]
        });
        if (utils.environment.config.tools?.bundlerChain) for (let item of helpers_castArray(utils.environment.config.tools.bundlerChain))await item(modifiedBundlerChain, utils);
        return logger.debug('applied modifyBundlerChain hook'), modifiedBundlerChain;
    }
    let configChain_CHAIN_ID = {
        RULE: {
            MJS: 'mjs',
            FONT: 'font',
            JSON: 'json',
            IMAGE: 'image',
            MEDIA: 'media',
            ADDITIONAL_ASSETS: 'additional-assets',
            JS: 'js',
            JS_RAW: 'js-raw',
            JS_DATA_URI: 'js-data-uri',
            TS: 'ts',
            CSS: 'css',
            CSS_RAW: 'css-raw',
            CSS_INLINE: 'css-inline',
            LESS: 'less',
            LESS_RAW: 'less-raw',
            LESS_INLINE: 'less-inline',
            SASS: 'sass',
            SASS_RAW: 'sass-raw',
            SASS_INLINE: 'sass-inline',
            STYLUS: 'stylus',
            STYLUS_RAW: 'stylus-raw',
            STYLUS_INLINE: 'stylus-inline',
            SVG: 'svg',
            VUE: 'vue',
            WASM: 'wasm',
            SVELTE: 'svelte'
        },
        ONE_OF: {
            SVG: 'svg',
            SVG_RAW: 'svg-asset-raw',
            SVG_URL: 'svg-asset-url',
            SVG_ASSET: 'svg-asset',
            SVG_REACT: 'svg-react',
            SVG_INLINE: 'svg-asset-inline'
        },
        USE: {
            TS: 'ts',
            CSS: 'css',
            SASS: 'sass',
            LESS: 'less',
            STYLUS: 'stylus',
            URL: 'url',
            VUE: 'vue',
            SWC: 'swc',
            SVGR: 'svgr',
            BABEL: 'babel',
            STYLE: 'style-loader',
            SVELTE: 'svelte',
            POSTCSS: 'postcss',
            LIGHTNINGCSS: 'lightningcss',
            IGNORE_CSS: 'ignore-css',
            CSS_MODULES_TS: "css-modules-typescript",
            MINI_CSS_EXTRACT: 'mini-css-extract',
            RESOLVE_URL: 'resolve-url-loader'
        },
        PLUGIN: {
            HMR: 'hmr',
            COPY: 'copy',
            HTML: 'html',
            DEFINE: 'define',
            PROGRESS: 'progress',
            MANIFEST: 'webpack-manifest',
            TS_CHECKER: 'ts-checker',
            BUNDLE_ANALYZER: 'bundle-analyze',
            MODULE_FEDERATION: 'module-federation',
            HTML_PREFETCH: 'html-prefetch-plugin',
            HTML_PRELOAD: 'html-preload-plugin',
            MINI_CSS_EXTRACT: 'mini-css-extract',
            VUE_LOADER_PLUGIN: 'vue-loader-plugin',
            REACT_FAST_REFRESH: 'react-fast-refresh',
            SUBRESOURCE_INTEGRITY: 'subresource-integrity'
        },
        MINIMIZER: {
            JS: 'js',
            CSS: 'css'
        },
        RESOLVE_PLUGIN: {
            TS_CONFIG_PATHS: 'ts-config-paths'
        }
    }, setHTMLPlugin = (plugin)=>{
        plugin && (pluginHelper_htmlPlugin = plugin);
    }, pluginHelper_getHTMLPlugin = (config)=>config?.html.implementation === 'native' ? rspack_rspack.HtmlRspackPlugin : (pluginHelper_htmlPlugin || (pluginHelper_htmlPlugin = requireCompiledPackage('html-rspack-plugin')), pluginHelper_htmlPlugin), setCssExtractPlugin = (plugin)=>{
        cssExtractPlugin = plugin;
    }, getCssExtractPlugin = ()=>cssExtractPlugin || rspack_rspack.CssExtractRspackPlugin;
    async function modifyRspackConfig(context, rspackConfig, chainUtils) {
        logger.debug('applying modifyRspackConfig hook');
        let currentConfig = rspackConfig, utils = getConfigUtils(()=>currentConfig, chainUtils);
        if ([currentConfig] = await context.hooks.modifyRspackConfig.callChain({
            environment: utils.environment.name,
            args: [
                rspackConfig,
                utils
            ],
            afterEach: ([config])=>{
                currentConfig = config;
            }
        }), utils.environment.config.tools?.rspack) {
            let toolsRspackConfig = utils.environment.config.tools.rspack;
            currentConfig = await reduceConfigsAsyncWithContext({
                initial: currentConfig,
                config: toolsRspackConfig,
                ctx: utils,
                mergeFn: (...args)=>currentConfig = utils.mergeConfig.call(utils, args)
            });
        }
        return logger.debug('applied modifyRspackConfig hook'), currentConfig;
    }
    function getConfigUtils(getCurrentConfig, chainUtils) {
        return {
            ...chainUtils,
            mergeConfig: webpack_merge_dist.merge,
            addRules (rules) {
                let config = getCurrentConfig(), ruleArr = helpers_castArray(rules);
                config.module || (config.module = {}), config.module.rules || (config.module.rules = []), config.module.rules.unshift(...ruleArr);
            },
            appendRules (rules) {
                let config = getCurrentConfig(), ruleArr = helpers_castArray(rules);
                config.module || (config.module = {}), config.module.rules || (config.module.rules = []), config.module.rules.push(...ruleArr);
            },
            prependPlugins (plugins) {
                let config = getCurrentConfig(), pluginArr = helpers_castArray(plugins);
                config.plugins || (config.plugins = []), config.plugins.unshift(...pluginArr);
            },
            appendPlugins (plugins) {
                let config = getCurrentConfig(), pluginArr = helpers_castArray(plugins);
                config.plugins || (config.plugins = []), config.plugins.push(...pluginArr);
            },
            removePlugin (pluginName) {
                let config = getCurrentConfig();
                config.plugins && (config.plugins = config.plugins.filter((plugin)=>!plugin || (plugin.name || plugin.constructor.name) !== pluginName));
            }
        };
    }
    function getChainUtils(target, environment, environments) {
        return {
            rspack: rspack_rspack,
            environment,
            environments,
            env: process.env.NODE_ENV || '',
            target,
            isDev: 'development' === environment.config.mode,
            isProd: 'production' === environment.config.mode,
            isServer: 'node' === target,
            isWebWorker: 'web-worker' === target,
            CHAIN_ID: configChain_CHAIN_ID,
            HtmlPlugin: pluginHelper_getHTMLPlugin(environment.config)
        };
    }
    function validateRspackConfig(config) {
        if (config.plugins) {
            for (let plugin of config.plugins)if (plugin && void 0 === plugin.apply && 'name' in plugin && 'setup' in plugin) {
                let name = color.bold(color.yellow(plugin.name));
                throw Error(`${color.dim('[rsbuild:plugin]')} "${color.yellow(name)}" appears to be an Rsbuild plugin. It cannot be used as an Rspack plugin.`);
            }
        }
        config.devServer && logger.warn(`${color.dim('[rsbuild:config]')} Find invalid Rspack config: "${color.yellow('devServer')}". Note that Rspack's "devServer" config is not supported by Rsbuild. You can use Rsbuild's "dev" config to configure the Rsbuild dev server.`);
    }
    async function generateRspackConfig({ target, context, environmentName }) {
        let chainUtils = getChainUtils(target, context.environments[environmentName], context.environments), { BannerPlugin, DefinePlugin, IgnorePlugin, ProvidePlugin, SourceMapDevToolPlugin, HotModuleReplacementPlugin } = rspack_rspack, rspackConfig = (await modifyBundlerChain(context, {
            ...chainUtils,
            bundler: {
                BannerPlugin,
                DefinePlugin,
                IgnorePlugin,
                ProvidePlugin,
                SourceMapDevToolPlugin,
                HotModuleReplacementPlugin
            }
        })).toConfig();
        return validateRspackConfig(rspackConfig = await modifyRspackConfig(context, rspackConfig, chainUtils)), rspackConfig;
    }
    let allowedEnvironmentDevKeys = [
        'hmr',
        'client',
        'liveReload',
        'browserLogs',
        'writeToDisk',
        'assetPrefix',
        'progressBar',
        'lazyCompilation'
    ];
    async function modifyRsbuildConfig(context) {
        logger.debug('applying modifyRsbuildConfig hook');
        let pluginsCount = context.config.plugins?.length ?? 0, [modified] = await context.hooks.modifyRsbuildConfig.callChain(context.config, {
            mergeRsbuildConfig: mergeRsbuildConfig
        });
        context.config = modified, (modified.plugins?.length ?? 0) !== pluginsCount && logger.warn(`${color.dim('[rsbuild]')} Cannot change plugins via ${color.yellow('modifyRsbuildConfig')} as plugins are already initialized when it executes.`), logger.debug('applied modifyRsbuildConfig hook');
    }
    async function modifyEnvironmentConfig(context, config, name) {
        logger.debug(`applying modifyEnvironmentConfig hook (${name})`);
        let [modified] = await context.hooks.modifyEnvironmentConfig.callChain({
            environment: name,
            args: [
                config,
                {
                    name,
                    mergeEnvironmentConfig: mergeRsbuildConfig
                }
            ]
        });
        return logger.debug(`applied modifyEnvironmentConfig hook (${name})`), modified;
    }
    let createEnvironmentNotFoundError = (environments = [])=>{
        let envList = color.yellow(environments.join(','));
        return Error(`${color.dim('[rsbuild:config]')} The current build is specified to run only in the ${envList} environment, but the configuration of the specified environment was not found.`);
    };
    async function initRsbuildConfig({ context, pluginManager }) {
        var config, rootPath;
        let defaultConfig;
        if (context.normalizedConfig) return context.normalizedConfig;
        await initPlugins({
            context,
            pluginManager
        }), await modifyRsbuildConfig(context);
        let normalizedBaseConfig = (config = context.config, rootPath = context.rootPath, config.server ||= {}, config.server.publicDir = normalizePublicDirs(rootPath, config.server.publicDir), (defaultConfig = createDefaultConfig()).mode = (()=>{
            if (config.mode) return config.mode;
            let nodeEnv = process.env.NODE_ENV || '';
            return 'production' === nodeEnv || 'development' === nodeEnv ? nodeEnv : 'none';
        })(), mergeRsbuildConfig(defaultConfig, config)), environments = {}, mergedEnvironments = ((normalizedConfig, rootPath, specifiedEnvironments)=>{
            let defaultEntry, { environments, dev, server: _server, provider: _provider, ...baseConfig } = normalizedConfig, isEnvironmentEnabled = (name)=>!specifiedEnvironments || specifiedEnvironments.includes(name), applyEnvironmentDefaultConfig = (config)=>{
                config.source.entry && 0 !== Object.keys(config.source.entry).length || (config.source.entry = (defaultEntry || (defaultEntry = getDefaultEntry(rootPath)), defaultEntry));
                let isServer = 'node' === config.output.target;
                return void 0 === config.output.distPath.js && (config.output.distPath.js = isServer ? '' : 'static/js'), config;
            };
            if (environments && Object.keys(environments).length > 0) {
                let resolvedEnvironments = Object.fromEntries(Object.entries(environments).filter(([name])=>isEnvironmentEnabled(name)).map(([name, config])=>[
                        name,
                        applyEnvironmentDefaultConfig({
                            ...mergeRsbuildConfig({
                                ...baseConfig,
                                dev: pick(dev, allowedEnvironmentDevKeys)
                            }, config)
                        })
                    ]));
                if (0 === Object.keys(resolvedEnvironments).length) throw createEnvironmentNotFoundError(specifiedEnvironments);
                return resolvedEnvironments;
            }
            let defaultEnvironmentName = baseConfig.output.target.replace(/[-_](\w)/g, (_, c)=>c.toUpperCase());
            if (!isEnvironmentEnabled(defaultEnvironmentName)) throw createEnvironmentNotFoundError(specifiedEnvironments);
            return {
                [defaultEnvironmentName]: applyEnvironmentDefaultConfig({
                    ...baseConfig,
                    dev: pick(dev, allowedEnvironmentDevKeys)
                })
            };
        })(normalizedBaseConfig, context.rootPath, context.specifiedEnvironments), tsconfigPaths = new Set();
        for (let [name, config] of Object.entries(mergedEnvironments)){
            let environmentConfig = await modifyEnvironmentConfig(context, config, name), normalizedEnvironmentConfig = {
                ...environmentConfig,
                dev: {
                    ...normalizedBaseConfig.dev,
                    ...environmentConfig.dev
                },
                server: normalizedBaseConfig.server
            }, { tsconfigPath } = normalizedEnvironmentConfig.source;
            if (tsconfigPath) {
                let absoluteTsconfigPath = ensureAbsolutePath(context.rootPath, tsconfigPath);
                normalizedEnvironmentConfig.source.tsconfigPath = absoluteTsconfigPath, tsconfigPaths.add(absoluteTsconfigPath);
            }
            environments[name] = normalizedEnvironmentConfig;
        }
        return tsconfigPaths.size && 'prefer-tsconfig' === normalizedBaseConfig.resolve.aliasStrategy && normalizedBaseConfig.dev.watchFiles.push({
            paths: Array.from(tsconfigPaths),
            type: 'reload-server'
        }), context.normalizedConfig = {
            ...normalizedBaseConfig,
            environments
        }, await updateEnvironmentContext(context, environments), updateContextByNormalizedConfig(context), ((config)=>{
            if (config.server.base && !config.server.base.startsWith('/')) throw Error(`${color.dim('[rsbuild:config]')} The ${color.yellow('"server.base"')} option should start with a slash, for example: "/base"`);
            if (!config.environments) return;
            let environmentNames = Object.keys(config.environments), environmentNameRegexp = /^[\w$-]+$/, validTargets = [
                'web',
                'node',
                'web-worker'
            ];
            for (let name of environmentNames){
                environmentNameRegexp.test(name) || logger.warn(`${color.dim('[rsbuild:config]')} Environment name "${color.yellow(name)}" contains invalid characters. Only letters, numbers, "-", "_", and "$" are allowed.`);
                let outputConfig = config.environments[name].output;
                if (outputConfig.target && !validTargets.includes(outputConfig.target)) throw Error(`${color.dim('[rsbuild:config]')} Invalid value of ${color.yellow('output.target')}: ${color.yellow(`"${outputConfig.target}"`)}, valid values are: ${color.yellow(validTargets.join(', '))}`);
            }
        })(context.normalizedConfig), context.normalizedConfig;
    }
    async function initConfigs({ context, pluginManager, rsbuildOptions }) {
        let normalizedConfig = await initRsbuildConfig({
            context,
            pluginManager
        }), rspackConfigs = await Promise.all(Object.entries(normalizedConfig.environments).map(([environmentName, config])=>generateRspackConfig({
                target: config.output.target,
                context,
                environmentName
            })));
        if (isDebug()) {
            let inspect = async ()=>{
                await inspectConfig_inspectConfig({
                    context,
                    pluginManager,
                    inspectOptions: {
                        verbose: !0,
                        writeToDisk: !0
                    },
                    rsbuildOptions,
                    bundlerConfigs: rspackConfigs
                });
            };
            context.hooks.onBeforeBuild.tap(async ({ isFirstCompile })=>{
                isFirstCompile && await inspect();
            }), context.hooks.onAfterStartDevServer.tap(inspect);
        }
        return {
            rspackConfigs
        };
    }
    function cutPath(originalFilePath, root) {
        let prefix = root.endsWith(external_node_path_.sep) ? root : root + external_node_path_.sep, filePath = originalFilePath;
        filePath.startsWith(prefix) && (filePath = filePath.slice(prefix.length));
        let parts = filePath.split(external_node_path_.sep).filter(Boolean);
        return parts.length > 3 ? parts.slice(-3).join(external_node_path_.sep) : parts.join(external_node_path_.sep);
    }
    function isLikelyFile(filePath) {
        return (filePath.split(external_node_path_.sep).pop() || '').includes('.');
    }
    function formatFileList(paths, rootPath) {
        let files = paths.filter(isLikelyFile);
        0 === files.length && paths.length > 0 && (files = [
            paths[0]
        ]);
        let fileInfo = files.slice(0, 1).map((file)=>cutPath(file, rootPath)).join(', ');
        return files.length > 1 ? `${fileInfo} and ${files.length - 1} more` : fileInfo;
    }
    function printBuildLog(compiler, context, lazyModules) {
        let { modifiedFiles } = compiler, changedFiles = modifiedFiles?.size ? Array.from(modifiedFiles) : lazyModules.size ? Array.from(lazyModules) : null;
        if (changedFiles?.length) {
            let fileInfo = formatFileList(changedFiles, context.rootPath);
            logger.start(`building ${color.dim(fileInfo)}`);
            return;
        }
        let removedFiles = compiler.removedFiles ? Array.from(compiler.removedFiles) : null;
        if (removedFiles?.length) {
            let fileInfo = formatFileList(removedFiles, context.rootPath);
            logger.start(`building ${color.dim(`removed ${fileInfo}`)}`);
            return;
        }
        logger.start('build started...');
    }
    async function createCompiler_createCompiler(options) {
        let version;
        logger.debug('creating compiler');
        let HOOK_NAME = 'rsbuild:compiler', { context } = options, { rspackConfigs } = await initConfigs(options);
        if (await context.hooks.onBeforeCreateCompiler.callBatch({
            bundlerConfigs: rspackConfigs,
            environments: context.environments
        }), (version = rspack_rspack.rspackVersion).includes('-canary') && (version = version.split('-canary')[0]), !(!(version && /^[\d.]+$/.test(version)) || ((version1, version2)=>{
            let parts1 = version1.split('.').map(Number), parts2 = version2.split('.').map(Number), len = Math.max(parts1.length, parts2.length);
            for(let i = 0; i < len; i++){
                let item1 = parts1[i] ?? 0, item2 = parts2[i] ?? 0;
                if (item1 > item2) return 1;
                if (item1 < item2) return -1;
            }
            return 0;
        })(version, '1.5.0') >= 0)) throw Error(`${color.dim('[rsbuild]')} The current Rspack version does not meet the requirements, the minimum supported version of Rspack is ${color.green("1.5.0")}`);
        let isMultiCompiler = rspackConfigs.length > 1, compiler = isMultiCompiler ? rspack_rspack(rspackConfigs) : rspack_rspack(rspackConfigs[0]);
        'true' === process.env.RSPACK_UNSAFE_FAST_DROP && (compiler.unsafeFastDrop = !0);
        let isVersionLogged = !1, isCompiling = !1, logRspackVersion = ()=>{
            isVersionLogged || (logger.debug(`using Rspack v${rspack_rspack.rspackVersion}`), isVersionLogged = !0);
        }, lazyModules = new Set();
        return compiler.hooks.infrastructureLog.tap(HOOK_NAME, (name, _, args)=>{
            let log = args[0];
            if ('LazyCompilation' === name && 'string' == typeof log && log.startsWith('lazy-compilation-proxy')) {
                let resource = log.split(' ')[0];
                if (!resource) return;
                let { rootPath } = context, absolutePath = resource.split('!').pop();
                if (absolutePath?.startsWith(rootPath)) {
                    let relativePath = absolutePath.replace(rootPath, '');
                    lazyModules.add(relativePath);
                }
            }
        }), compiler.hooks.run.tap(HOOK_NAME, ()=>{
            context.buildState.status = 'building';
        }), compiler.hooks.watchRun.tap(HOOK_NAME, (compiler)=>{
            context.buildState.status = 'building', logRspackVersion(), isCompiling || printBuildLog(compiler, context, lazyModules), lazyModules.size && lazyModules.clear(), isCompiling = !0;
        }), compiler.hooks.invalid.tap(HOOK_NAME, ()=>{
            context.buildState.stats = null, context.buildState.status = 'idle', context.buildState.hasErrors = !1;
        }), 'build' === context.action && (isMultiCompiler ? compiler.compilers[0] : compiler).hooks.run.tap(HOOK_NAME, ()=>{
            logger.info('build started...'), logRspackVersion();
        }), compiler.hooks.done.tap(HOOK_NAME, (statsInstance)=>{
            let stats = getRsbuildStats(statsInstance, compiler, context.action), hasErrors = statsInstance.hasErrors();
            context.buildState.stats = stats, context.buildState.status = 'done', context.buildState.hasErrors = hasErrors, context.socketServer?.onBuildDone();
            let printTime = (statsItem, index)=>{
                if (statsItem.time) {
                    let time = prettyTime(statsItem.time / 1000), { name } = rspackConfigs[index], suffix = name && isMultiCompiler ? color.dim(` (${name})`) : '';
                    logger.ready(`built in ${time}${suffix}`);
                }
            };
            hasErrors || (isMultiCompiler && stats.children?.length ? stats.children.forEach((item, index)=>{
                printTime(item, index);
            }) : printTime(stats, 0));
            let { message, level } = formatStats(stats, hasErrors);
            'error' === level && logger.error(message), 'warning' === level && logger.warn(message), isCompiling = !1;
        }), 'dev' === context.action && registerDevHook({
            context,
            compiler,
            bundlerConfigs: rspackConfigs,
            MultiStatsCtor: rspack_rspack.MultiStats
        }), await context.hooks.onAfterCreateCompiler.callBatch({
            compiler,
            environments: context.environments
        }), logger.debug('compiler created'), {
            compiler,
            rspackConfigs
        };
    }
    let RSPACK_BUILD_ERROR = 'Rspack build failed.', build_build = async (initOptions, { watch, compiler: customCompiler } = {})=>{
        let compiler, bundlerConfigs, { context } = initOptions;
        if (customCompiler) compiler = customCompiler, bundlerConfigs = customCompiler.options;
        else {
            let result = await createCompiler_createCompiler(initOptions);
            compiler = result.compiler, bundlerConfigs = result.rspackConfigs;
        }
        if (registerBuildHook({
            context,
            bundlerConfigs,
            compiler,
            isWatch: !!watch,
            MultiStatsCtor: rspack_rspack.MultiStats
        }), watch) {
            let watchOptions = bundlerConfigs ? bundlerConfigs.map((options)=>options.watchOptions || {}) : [];
            return compiler.watch(watchOptions.length > 1 ? watchOptions : watchOptions[0] || {}, (err)=>{
                err && logger.error(err);
            }), {
                close: ()=>new Promise((resolve)=>{
                        compiler.close(()=>{
                            resolve();
                        });
                    })
            };
        }
        let { stats } = await new Promise((resolve, reject)=>{
            compiler.run((err, stats)=>{
                compiler.close((closeErr)=>{
                    closeErr && logger.error('Failed to close compiler: ', closeErr), err ? reject(err) : context.buildState.hasErrors ? reject(Error(RSPACK_BUILD_ERROR)) : resolve({
                        stats
                    });
                });
            });
        });
        return {
            stats,
            close: async ()=>{}
        };
    }, types_namespaceObject = require("node:util/types");
    var main = __webpack_require__("../../node_modules/.pnpm/dotenv-expand@12.0.3/node_modules/dotenv-expand/lib/main.js");
    let DOTENV_LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/gm;
    function loadEnv_parse(src) {
        let match, obj = {}, lines = src.toString();
        for(lines = lines.replace(/\r\n?/gm, '\n'); null != (match = DOTENV_LINE.exec(lines));){
            let key = match[1], value = match[2] || '', maybeQuote = (value = value.trim())[0];
            value = value.replace(/^(['"`])([\s\S]*)\1$/gm, '$2'), '"' === maybeQuote && (value = (value = value.replace(/\\n/g, '\n')).replace(/\\r/g, '\r')), obj[key] = value;
        }
        return obj;
    }
    function loadEnv({ cwd = process.cwd(), mode = process.env.NODE_ENV || '', prefixes = [
        'PUBLIC_'
    ], processEnv = process.env } = {}) {
        if ('local' === mode) throw Error(`${color.dim('[rsbuild:loadEnv]')} ${color.yellow('local')} cannot be used as a value for env mode, because ${color.yellow('.env.local')} represents a temporary local file. Please use another value.`);
        let filePaths = [
            '.env',
            '.env.local',
            `.env.${mode}`,
            `.env.${mode}.local`
        ].map((filename)=>(0, external_node_path_.join)(cwd, filename)).filter(isFileSync), parsed = {};
        for (let envPath of filePaths)Object.assign(parsed, loadEnv_parse(external_node_fs_default().readFileSync(envPath))), logger.debug('loaded env file:', envPath);
        parsed.NODE_ENV && (processEnv.NODE_ENV = parsed.NODE_ENV), (0, main.expand)({
            parsed,
            processEnv
        });
        let publicVars = {}, rawPublicVars = {};
        for (let key of Object.keys(processEnv))if (prefixes.some((prefix)=>key.startsWith(prefix))) {
            let val = processEnv[key];
            publicVars[`import.meta.env.${key}`] = JSON.stringify(val), publicVars[`process.env.${key}`] = JSON.stringify(val), rawPublicVars[key] = val;
        }
        let cleaned = !1;
        return {
            parsed,
            cleanup: ()=>{
                if (!cleaned) {
                    for (let key of Object.keys(parsed))'NODE_ENV' !== key && processEnv[key] === parsed[key] && delete processEnv[key];
                    cleaned = !0;
                }
            },
            filePaths,
            publicVars,
            rawPublicVars
        };
    }
    var external_node_util_ = __webpack_require__("node:util");
    let chainStaticAssetRule = ({ emit, rule, maxSize, filename, assetType })=>{
        let generatorOptions = {
            filename
        };
        emit || (generatorOptions.emit = !1), rule.oneOf(`${assetType}-asset-url`).type('asset/resource').resourceQuery(/^\?(__inline=false|url)$/).set('generator', generatorOptions), rule.oneOf(`${assetType}-asset-inline`).type('asset/inline').resourceQuery(INLINE_QUERY_REGEX), rule.oneOf(`${assetType}-asset-raw`).type('asset/source').resourceQuery(RAW_QUERY_REGEX), rule.oneOf(`${assetType}-asset`).type('asset').parser({
            dataUrlCondition: {
                maxSize
            }
        }).set('generator', generatorOptions);
    };
    function getRegExpForExts(exts) {
        let normalizedExts = [];
        for (let ext of exts){
            let trimmed = ext.trim();
            normalizedExts.push(trimmed.startsWith('.') ? trimmed.slice(1) : trimmed);
        }
        let matcher = normalizedExts.join('|');
        return RegExp(1 === normalizedExts.length ? `\\.${matcher}$` : `\\.(?:${matcher})$`, 'i');
    }
    let isUseAnalyzer = (config)=>process.env.BUNDLE_ANALYZE || config.performance?.bundleAnalyze;
    function pluginBundleAnalyzer() {
        return {
            name: 'rsbuild:bundle-analyzer',
            setup (api) {
                api.modifyRsbuildConfig({
                    order: 'post',
                    handler: (config)=>{
                        if (isUseAnalyzer(config) || Object.values(config.environments || []).some((config)=>isUseAnalyzer(config))) return config.dev ||= {}, config.dev.writeToDisk = !0, config;
                    }
                }), api.modifyBundlerChain((chain, { CHAIN_ID, environment })=>{
                    let { config } = environment;
                    if (!isUseAnalyzer(config)) return;
                    let BundleAnalyzer = requireCompiledPackage('webpack-bundle-analyzer');
                    chain.plugin(CHAIN_ID.PLUGIN.BUNDLE_ANALYZER).use(BundleAnalyzer.BundleAnalyzerPlugin, [
                        {
                            analyzerMode: 'static',
                            openAnalyzer: !1,
                            reportFilename: `report-${environment.name}.html`,
                            ...config.performance.bundleAnalyze || {}
                        }
                    ]);
                });
            }
        };
    }
    async function validateWebpackCache(cacheDirectory, buildDependencies) {
        let configFile = (0, external_node_path_.join)(cacheDirectory, 'buildDependencies.json');
        if (await isFileExists(configFile)) {
            let rawConfigFile = await external_node_fs_default().promises.readFile(configFile, 'utf-8'), prevBuildDependencies = null;
            try {
                prevBuildDependencies = JSON.parse(rawConfigFile);
            } catch (e) {
                logger.debug('failed to parse the previous buildDependencies.json', e);
            }
            if (JSON.stringify(prevBuildDependencies) === JSON.stringify(buildDependencies)) return;
            await external_node_fs_default().promises.rm(cacheDirectory, {
                force: !0,
                recursive: !0
            });
        }
        try {
            await external_node_fs_default().promises.mkdir(cacheDirectory, {
                recursive: !0
            }), await external_node_fs_default().promises.writeFile(configFile, JSON.stringify(buildDependencies));
        } catch (e) {
            logger.debug('failed to write the buildDependencies.json', e);
        }
    }
    function getCacheDirectory({ cacheDirectory }, context) {
        return cacheDirectory ? (0, external_node_path_.isAbsolute)(cacheDirectory) ? cacheDirectory : (0, external_node_path_.join)(context.rootPath, cacheDirectory) : (0, external_node_path_.join)(context.cachePath, context.bundlerType);
    }
    async function getBuildDependencies(context, config, environmentContext, additionalDependencies) {
        let rootPackageJson = (0, external_node_path_.join)(context.rootPath, 'package.json'), browserslistConfig = (0, external_node_path_.join)(context.rootPath, '.browserslistrc'), buildDependencies = {};
        await isFileExists(rootPackageJson) && (buildDependencies.packageJson = [
            rootPackageJson
        ]);
        let { tsconfigPath } = environmentContext;
        tsconfigPath && (buildDependencies.tsconfig = [
            tsconfigPath
        ]), config._privateMeta?.configFilePath && (buildDependencies.rsbuildConfig = [
            config._privateMeta.configFilePath
        ]), await isFileExists(browserslistConfig) && (buildDependencies.browserslistrc = [
            browserslistConfig
        ]);
        let tailwindConfig = findExists([
            'ts',
            'js',
            'cjs',
            'mjs'
        ].map((ext)=>(0, external_node_path_.join)(context.rootPath, `tailwind.config.${ext}`)));
        return tailwindConfig && (buildDependencies.tailwindcss = [
            tailwindConfig
        ]), additionalDependencies && (buildDependencies.additional = additionalDependencies), buildDependencies;
    }
    let addTrailingSep = (dir)=>dir.endsWith(external_node_path_.sep) ? dir : dir + external_node_path_.sep, isStrictSubdir = (parent, child)=>{
        let parentDir = addTrailingSep(parent), childDir = addTrailingSep(child);
        return parentDir !== childDir && childDir.startsWith(parentDir);
    }, normalizeCleanDistPath = (userOptions)=>{
        let defaultOptions = {
            enable: 'auto'
        };
        return 'boolean' == typeof userOptions || 'auto' === userOptions ? {
            ...defaultOptions,
            enable: userOptions
        } : {
            ...defaultOptions,
            ...userOptions
        };
    };
    var postcss_load_config_src = __webpack_require__("../../node_modules/.pnpm/postcss-load-config@6.0.1_jiti@2.6.1_postcss@8.5.6_yaml@2.8.1/node_modules/postcss-load-config/src/index.js"), src_default = __webpack_require__.n(postcss_load_config_src);
    let parseMinifyOptions = (config)=>{
        let isProd = 'production' === config.mode, { minify } = config.output;
        if ('boolean' == typeof minify) {
            let shouldMinify = minify && isProd;
            return {
                minifyJs: shouldMinify,
                minifyCss: shouldMinify
            };
        }
        return {
            minifyJs: !1 !== minify.js && ('always' === minify.js || isProd),
            minifyCss: !1 !== minify.css && ('always' === minify.css || isProd),
            jsOptions: minify.jsOptions,
            cssOptions: minify.cssOptions
        };
    }, getLightningCSSLoaderOptions = (config, targets, minify)=>{
        let userOptions = 'object' == typeof config.tools.lightningcssLoader ? config.tools.lightningcssLoader : {}, initialOptions = {
            targets,
            errorRecovery: !0
        };
        return minify && (initialOptions.minify = !0), reduceConfigs({
            initial: initialOptions,
            config: userOptions
        });
    }, clonePostCSSConfig = (config)=>({
            ...config,
            plugins: config.plugins ? [
                ...config.plugins
            ] : void 0
        }), getCSSSourceMap = (config)=>{
        let { sourceMap } = config.output;
        return 'boolean' == typeof sourceMap ? sourceMap : sourceMap.css;
    };
    async function loadUserPostcssrc(root, postcssrcCache) {
        let cached = postcssrcCache.get(root);
        if (cached) return clonePostCSSConfig(await cached);
        let promise = src_default()({}, root).catch((err)=>{
            if (err.message?.includes('No PostCSS Config found')) return {};
            throw err;
        });
        return postcssrcCache.set(root, promise), promise.then((config)=>(postcssrcCache.set(root, config), clonePostCSSConfig(config)));
    }
    let getPostcssLoaderOptions = async ({ config, root, postcssrcCache })=>{
        let extraPlugins = [], userOptions = await loadUserPostcssrc(root, postcssrcCache);
        userOptions.plugins ||= [];
        let finalOptions = reduceConfigsWithContext({
            initial: {
                implementation: getCompiledPath('postcss'),
                postcssOptions: userOptions,
                sourceMap: getCSSSourceMap(config)
            },
            config: config.tools.postcss,
            ctx: {
                addPlugins (plugins) {
                    extraPlugins.push(...helpers_castArray(plugins));
                }
            }
        });
        finalOptions.postcssOptions ||= {};
        let updatePostcssOptions = (options)=>(options.plugins ||= [], extraPlugins.length && options.plugins.push(...extraPlugins), options.plugins = options.plugins.map((plugin)=>{
                let plugin1;
                return 'function' == typeof (plugin1 = plugin) && plugin1.postcss ? plugin() : plugin;
            }), options.config = !1, options), { postcssOptions } = finalOptions;
        if ('function' == typeof postcssOptions) {
            let postcssOptionsWrapper = (loaderContext)=>{
                let options = postcssOptions(loaderContext);
                if ('object' != typeof options || null === options) throw Error(`${color.dim('[rsbuild:css]')} \`postcssOptions\` function must return a PostCSSOptions object, got ${color.yellow(typeof options)}.`);
                return updatePostcssOptions({
                    ...userOptions,
                    ...options,
                    plugins: [
                        ...userOptions.plugins || [],
                        ...options.plugins || []
                    ]
                });
            };
            return postcssOptionsWrapper.config = !1, {
                ...finalOptions,
                postcssOptions: postcssOptionsWrapper
            };
        }
        return finalOptions.postcssOptions = updatePostcssOptions(postcssOptions), finalOptions;
    };
    function checkProcessEnvSecurity(define) {
        let value = define['process.env'];
        if (!value) return;
        let check = (value)=>{
            let pathKey = Object.keys(value).find((key)=>'path' === key.toLowerCase() && value[key] === process.env[key]);
            pathKey && logger.warn(`${color.dim('[rsbuild:config]')} The ${color.yellow('"source.define"')} option includes an object with the key ${color.yellow(JSON.stringify(pathKey))} under ${color.yellow('"process.env"')}, indicating potential exposure of all environment variables. This can lead to security risks and should be avoided.`);
        };
        if ('object' == typeof value) return void check(value);
        if ('string' == typeof value) try {
            check(JSON.parse(value));
        } catch  {}
    }
    function pluginExternals() {
        return {
            name: 'rsbuild:externals',
            setup (api) {
                api.modifyBundlerChain((chain, { environment })=>{
                    let { externals } = environment.config.output;
                    externals && chain.externals(externals);
                }), api.onBeforeCreateCompiler(({ bundlerConfigs })=>{
                    for (let config of bundlerConfigs)(Array.isArray(config.target) ? config.target.includes('webworker') : 'webworker' === config.target) && config.externals && delete config.externals;
                });
            }
        };
    }
    let external_node_zlib_namespaceObject = require("node:zlib");
    var external_node_zlib_default = __webpack_require__.n(external_node_zlib_namespaceObject);
    let fileSize_gzip = (0, external_node_util_.promisify)(external_node_zlib_default().gzip);
    async function gzipSize(input) {
        let data = await fileSize_gzip(input);
        return Buffer.byteLength(data);
    }
    let EXCLUDE_ASSET_REGEX = /\.(?:map|LICENSE\.txt|d\.ts)$/, excludeAsset = (asset)=>EXCLUDE_ASSET_REGEX.test(asset.name), getAssetColor = (size)=>size > 300000 ? color.red : size > 100000 ? color.yellow : color.green;
    function getHeader(maxFileLength, maxSizeLength, fileHeader, showGzipHeader) {
        let lengths = [
            maxFileLength,
            maxSizeLength
        ], rowTypes = [
            fileHeader,
            'Size'
        ];
        showGzipHeader && rowTypes.push('Gzip');
        let headerRow = rowTypes.reduce((prev, cur, index)=>{
            let length = lengths[index], curLabel = cur;
            return length && (curLabel = cur.length < length ? cur + ' '.repeat(length - cur.length) : cur), `${prev + curLabel}   `;
        }, '');
        return color.blue(headerRow);
    }
    let calcFileSize = (len)=>{
        let val = len / 1000;
        return `${val.toFixed(val < 1 ? 2 : 1)} kB`;
    }, coloringAssetName = (assetName)=>JS_REGEX.test(assetName) ? color.cyan(assetName) : assetName.endsWith('.css') ? color.yellow(assetName) : assetName.endsWith('.html') ? color.green(assetName) : color.magenta(assetName), COMPRESSIBLE_REGEX = /\.(?:js|css|html|json|svg|txt|xml|xhtml|wasm|manifest|md)$/i;
    async function printFileSizes(options, stats, rootPath, distPath, environmentName) {
        let logs = [], showDetail = !1 !== options.detail, showTotal = !1 !== options.total;
        if (!showTotal && !showDetail) return logs;
        let exclude = options.exclude ?? excludeAsset, relativeDistPath = external_node_path_default().relative(rootPath, distPath), formatAsset = async (asset)=>{
            let assetName, fileName = asset.name.split('?')[0], contents = await external_node_fs_default().promises.readFile(external_node_path_default().join(distPath, fileName)), size = Buffer.byteLength(contents), gzippedSize = options.compressed && (assetName = fileName, COMPRESSIBLE_REGEX.test(assetName)) ? await gzipSize(contents) : null, gzipSizeLabel = gzippedSize ? getAssetColor(gzippedSize)(calcFileSize(gzippedSize)) : null;
            return {
                size,
                folder: external_node_path_default().join(relativeDistPath, external_node_path_default().dirname(fileName)),
                name: external_node_path_default().basename(fileName),
                gzippedSize,
                sizeLabel: calcFileSize(size),
                gzipSizeLabel
            };
        }, getAssets = async ()=>Promise.all(getAssetsFromStats(stats).filter((asset)=>!exclude(asset) && (!options.include || options.include(asset))).map((asset)=>formatAsset(asset))), assets = await getAssets();
        if (0 === assets.length) return logs;
        logs.push(''), assets.sort((a, b)=>a.size - b.size);
        let totalSize = 0, totalGzipSize = 0;
        for (let asset of (showTotal = showTotal && !(showDetail && 1 === assets.length), assets))totalSize += asset.size, options.compressed && (totalGzipSize += asset.gzippedSize ?? asset.size);
        let fileHeader = showDetail ? `File (${environmentName})` : '', totalSizeLabel = showTotal ? showDetail ? 'Total:' : `Total size (${environmentName}):` : '', totalSizeStr = showTotal ? calcFileSize(totalSize) : '', getCustomTotal = ()=>'function' == typeof options.total ? options.total({
                environmentName,
                distPath: relativeDistPath,
                assets: assets.map((asset)=>{
                    let asset1;
                    return {
                        name: (asset1 = asset).name,
                        size: asset1.size
                    };
                }),
                totalSize,
                totalGzipSize
            }) : null;
        if (showDetail) {
            let maxFileLength = Math.max(...assets.map((a)=>(a.folder + external_node_path_default().sep + a.name).length), showTotal ? totalSizeLabel.length : 0, fileHeader.length), maxSizeLength = Math.max(...assets.map((a)=>a.sizeLabel.length), totalSizeStr.length), showGzipHeader = !!(options.compressed && assets.some((item)=>null !== item.gzippedSize));
            for (let asset of (logs.push(getHeader(maxFileLength, maxSizeLength, fileHeader, showGzipHeader)), assets)){
                let { sizeLabel } = asset, { name, folder, gzipSizeLabel } = asset, fileNameLength = (folder + external_node_path_default().sep + name).length, sizeLength = sizeLabel.length;
                sizeLength < maxSizeLength && (sizeLabel += ' '.repeat(maxSizeLength - sizeLength));
                let fileNameLabel = color.dim(asset.folder + external_node_path_default().sep) + coloringAssetName(asset.name);
                fileNameLength < maxFileLength && (fileNameLabel += ' '.repeat(maxFileLength - fileNameLength));
                let log = `${fileNameLabel}   ${sizeLabel}`;
                gzipSizeLabel && (log += `   ${gzipSizeLabel}`), logs.push(log);
            }
            if (showTotal) {
                logs.push('');
                let customTotal = getCustomTotal();
                if (customTotal) logs.push(customTotal);
                else {
                    let log = '';
                    if (log += ' '.repeat(maxFileLength - totalSizeLabel.length), log += color.magenta(totalSizeLabel), log += `   ${totalSizeStr}`, options.compressed) {
                        let colorFn = getAssetColor(totalGzipSize / assets.length);
                        log += ' '.repeat(maxSizeLength - totalSizeStr.length), log += `   ${colorFn(calcFileSize(totalGzipSize))}`;
                    }
                    logs.push(log);
                }
            }
        } else if (showTotal) {
            let customTotal = getCustomTotal();
            if (customTotal) logs.push(customTotal);
            else {
                let log = `${color.magenta(totalSizeLabel)} ${totalSizeStr}`;
                options.compressed && (log += color.green(` (${calcFileSize(totalGzipSize)} gzipped)`)), logs.push(log);
            }
        }
        return logs.push(''), logs;
    }
    let entryNameSymbol = Symbol('entryName'), VOID_TAGS = [
        'area',
        'base',
        'br',
        'col',
        'embed',
        'hr',
        'img',
        'input',
        'keygen',
        'link',
        'meta',
        'param',
        'source',
        'track',
        'wbr'
    ], HEAD_TAGS = [
        'title',
        'base',
        'link',
        'style',
        'meta',
        "script",
        "noscript",
        'template'
    ], FILE_ATTRS = {
        link: 'href',
        script: 'src'
    }, getTagPriority = (tag, tagConfig)=>{
        let priority = tag.head ?? HEAD_TAGS.includes(tag.tag) ? -2 : 2, append = tag.append ?? tagConfig.append;
        return 'boolean' == typeof append && (priority += append ? 1 : -1), priority;
    }, formatBasicTag = (tag)=>({
            tag: tag.tagName,
            attrs: tag.attributes,
            children: tag.innerHTML,
            metadata: tag.meta
        }), fromBasicTag = (tag)=>({
            meta: tag.metadata ?? {},
            tagName: tag.tag,
            attributes: tag.attrs ?? {},
            voidTag: VOID_TAGS.includes(tag.tag),
            innerHTML: tag.children
        }), formatTags = (tags, override)=>tags.map((tag)=>({
                ...formatBasicTag(tag),
                publicPath: !1,
                ...override
            }));
    class RsbuildHtmlPlugin {
        name;
        getExtraData;
        getHTMLPlugin;
        constructor(getExtraData, getHTMLPlugin){
            this.name = 'RsbuildHtmlPlugin', this.getExtraData = getExtraData, this.getHTMLPlugin = getHTMLPlugin;
        }
        apply(compiler) {
            let emitFavicon = async ({ compilation, favicon, faviconDistPath })=>{
                let buffer, name = external_node_path_default().basename(favicon);
                if (compilation.assets[name]) return name;
                if (!compilation.inputFileSystem) return addCompilationError(compilation, `${color.dim('[rsbuild:html]')} Failed to read the favicon file as ${color.yellow('compilation.inputFileSystem')} is not available.`), null;
                let inputFilename = external_node_path_default().isAbsolute(favicon) ? favicon : external_node_path_default().join(compilation.compiler.context, favicon);
                try {
                    if (!(buffer = await (0, external_node_util_.promisify)(compilation.inputFileSystem.readFile)(inputFilename))) throw Error('Buffer is undefined');
                } catch (error) {
                    return logger.debug(`read favicon error: ${error}`), addCompilationError(compilation, `${color.dim('[rsbuild:html]')} Failed to read the favicon file at ${color.yellow(inputFilename)}.`), null;
                }
                let source = new compiler.webpack.sources.RawSource(buffer, !1), outputFilename = external_node_path_default().posix.join(faviconDistPath, name);
                return compilation.emitAsset(outputFilename, source), outputFilename;
            }, addFavicon = async ({ headTags, favicon, faviconDistPath, compilation, publicPath })=>{
                let href = favicon;
                if (!isURL(favicon)) {
                    let name = await emitFavicon({
                        compilation,
                        favicon,
                        faviconDistPath
                    });
                    if (null === name) return;
                    href = ensureAssetPrefix(name, publicPath);
                }
                let tag = {
                    tagName: 'link',
                    voidTag: !0,
                    attributes: {
                        rel: 'icon',
                        href
                    },
                    meta: {}
                };
                href.endsWith('.svg') && (tag.attributes.type = 'image/svg+xml'), headTags.unshift(tag);
            }, getExtraDataByPlugin = (plugin)=>{
                if (!plugin.options) return;
                let entryName = plugin.options[entryNameSymbol];
                if (entryName) return this.getExtraData(entryName);
            };
            compiler.hooks.compilation.tap(this.name, (compilation)=>{
                let hooks = this.getHTMLPlugin().getCompilationHooks(compilation);
                hooks.alterAssetTagGroups.tapPromise(this.name, async (data)=>{
                    let html, extraData = getExtraDataByPlugin(data.plugin);
                    if (!extraData) return data;
                    let { headTags, bodyTags } = data, { favicon, faviconDistPath, context, tagConfig, entryName, environment, templateContent } = extraData;
                    (html = templateContent) && /<title/i.test(html) && /<\/title/i.test(html) || ((headTags, title = '')=>{
                        '' !== title && void 0 !== title && headTags.unshift({
                            tagName: 'title',
                            innerHTML: title,
                            attributes: {},
                            voidTag: !1,
                            meta: {}
                        });
                    })(headTags, data.plugin.options?.title), favicon && await addFavicon({
                        headTags,
                        favicon,
                        faviconDistPath,
                        compilation,
                        publicPath: data.publicPath
                    });
                    let tags = {
                        headTags: headTags.map(formatBasicTag),
                        bodyTags: bodyTags.map(formatBasicTag)
                    }, [modified] = await context.hooks.modifyHTMLTags.callChain({
                        environment: environment.name,
                        args: [
                            tags,
                            {
                                compiler,
                                compilation,
                                assetPrefix: data.publicPath,
                                filename: data.outputName,
                                environment
                            }
                        ]
                    });
                    return Object.assign(data, {
                        headTags: modified.headTags.map(fromBasicTag),
                        bodyTags: modified.bodyTags.map(fromBasicTag)
                    }), tagConfig && ((data, tagConfig, compilationHash, entryName)=>{
                        if (!tagConfig.tags?.length) return;
                        let fromInjectTags = (tags)=>{
                            let ret = [];
                            for (let tag of tags){
                                let attrs = {
                                    ...tag.attrs
                                }, filenameTag = FILE_ATTRS[tag.tag], filename = attrs[filenameTag];
                                if ('string' == typeof filename) {
                                    let optPublicPath = tag.publicPath ?? tagConfig.publicPath;
                                    'function' == typeof optPublicPath ? filename = optPublicPath(filename, data.publicPath) : 'string' == typeof optPublicPath ? filename = ensureAssetPrefix(filename, optPublicPath) : !1 !== optPublicPath && (filename = ensureAssetPrefix(filename, data.publicPath));
                                    let optHash = tag.hash ?? tagConfig.hash;
                                    'function' == typeof optHash ? compilationHash.length && (filename = optHash(filename, compilationHash)) : 'string' == typeof optHash ? optHash.length && (filename = `${filename}?${optHash}`) : !0 === optHash && compilationHash.length && (filename = `${filename}?${compilationHash}`), attrs[filenameTag] = filename, tag.attrs = attrs;
                                }
                                ret.push(fromBasicTag(tag));
                            }
                            return ret;
                        }, tags = [
                            ...formatTags(data.headTags, {
                                head: !0
                            }),
                            ...formatTags(data.bodyTags, {
                                head: !1
                            })
                        ], context = {
                            hash: compilationHash,
                            entryName,
                            outputName: data.outputName,
                            publicPath: data.publicPath
                        };
                        for (let item of tagConfig.tags)isFunction(item) ? tags = item(tags, context) || tags : tags.push(item), tags = tags.sort((tag1, tag2)=>getTagPriority(tag1, tagConfig) - getTagPriority(tag2, tagConfig));
                        let [headTags, bodyTags] = partition(tags, (tag)=>tag.head ?? HEAD_TAGS.includes(tag.tag));
                        return data.headTags = fromInjectTags(headTags), data.bodyTags = fromInjectTags(bodyTags);
                    })(data, tagConfig, compilation.hash ?? '', entryName), data;
                }), hooks.beforeEmit.tapPromise(this.name, async (data)=>{
                    let extraData = getExtraDataByPlugin(data.plugin);
                    if (!extraData) return data;
                    let { context, environment } = extraData, [modified] = await context.hooks.modifyHTML.callChain({
                        environment: environment.name,
                        args: [
                            data.html,
                            {
                                compiler,
                                compilation,
                                filename: data.outputName,
                                environment
                            }
                        ]
                    });
                    return {
                        ...data,
                        html: modified
                    };
                });
            });
        }
    }
    function getTitle(entryName, config) {
        return reduceConfigsMergeContext({
            initial: '',
            config: config.html.title,
            ctx: {
                entryName
            }
        });
    }
    function getInject(entryName, config) {
        return reduceConfigsMergeContext({
            initial: 'head',
            config: config.html.inject,
            ctx: {
                entryName
            }
        });
    }
    let existTemplatePath = new Set();
    async function getTemplate(entryName, config, rootPath) {
        let templatePath = reduceConfigsMergeContext({
            initial: '',
            config: config.html.template,
            ctx: {
                entryName
            }
        });
        if (!templatePath) {
            let mountId;
            return {
                templatePath: void 0,
                templateContent: (mountId = config.html.mountId, `<!doctype html><html><head></head><body><div id="${mountId}"></div></body></html>`)
            };
        }
        let absolutePath = (0, external_node_path_.isAbsolute)(templatePath) ? templatePath : external_node_path_default().join(rootPath, templatePath);
        if (!existTemplatePath.has(absolutePath)) {
            if (!await isFileExists(absolutePath)) throw Error(`${color.dim('[rsbuild:html]')} Failed to resolve HTML template, check if the file exists: ${color.yellow(absolutePath)}`);
            existTemplatePath.add(absolutePath);
        }
        let templateContent = await external_node_fs_default().promises.readFile(absolutePath, 'utf-8');
        return {
            templatePath: absolutePath,
            templateContent
        };
    }
    function getFavicon(entryName, config) {
        return reduceConfigsMergeContext({
            initial: '',
            config: config.html.favicon,
            ctx: {
                entryName
            }
        });
    }
    function getMetaTags(entryName, config, templateContent) {
        let metaTags = reduceConfigsMergeContext({
            initial: {},
            config: config.html.meta,
            ctx: {
                entryName
            }
        });
        return templateContent && metaTags.charset && /<meta[^>]+charset=["'][^>]*>/i.test(templateContent) && delete metaTags.charset, metaTags;
    }
    function getTemplateParameters(entryName, config, assetPrefix) {
        return (compilation, assets, assetTags, pluginOptions)=>{
            let { mountId, templateParameters } = config.html, rspackConfig = compilation.options, htmlPlugin = {
                tags: assetTags,
                files: assets,
                options: pluginOptions
            };
            return reduceConfigsWithContext({
                initial: {
                    mountId,
                    entryName,
                    assetPrefix,
                    compilation,
                    htmlPlugin,
                    rspackConfig,
                    webpackConfig: rspackConfig,
                    htmlWebpackPlugin: htmlPlugin
                },
                config: templateParameters,
                ctx: {
                    entryName
                }
            });
        };
    }
    function getChunks(entryName, entryValue) {
        let chunks = [
            entryName
        ];
        for (let item of entryValue){
            if (!isPlainObject(item)) continue;
            let { dependOn } = item;
            dependOn && ('string' == typeof dependOn ? chunks.unshift(dependOn) : chunks.unshift(...dependOn));
        }
        return chunks;
    }
    function updateSourceMappingURL({ source, compilation, publicPath, type, config }) {
        let { devtool } = compilation.options;
        if (devtool && !devtool.includes('inline') && source.includes('# sourceMappingURL')) {
            let prefix = addTrailingSlash(ensureAssetPrefix(config.output.distPath[type] || '', publicPath));
            return source.replace(/# sourceMappingURL=/, `# sourceMappingURL=${prefix}`);
        }
        return source;
    }
    function matchTests(name, asset, tests) {
        return tests.some((test)=>isFunction(test) ? test({
                name,
                size: asset.size()
            }) : test.exec(name));
    }
    let getInlineTests = (config)=>{
        let isProd = 'production' === config.mode, { inlineStyles, inlineScripts } = config.output, scriptTests = [], styleTests = [];
        return inlineScripts && (!0 === inlineScripts ? isProd && scriptTests.push(JS_REGEX) : (0, types_namespaceObject.isRegExp)(inlineScripts) || isFunction(inlineScripts) ? isProd && scriptTests.push(inlineScripts) : ('auto' === inlineScripts.enable ? isProd : inlineScripts.enable) && scriptTests.push(inlineScripts.test)), inlineStyles && (!0 === inlineStyles ? isProd && styleTests.push(CSS_REGEX) : (0, types_namespaceObject.isRegExp)(inlineStyles) || isFunction(inlineStyles) ? isProd && styleTests.push(inlineStyles) : ('auto' === inlineStyles.enable ? isProd : inlineStyles.enable) && styleTests.push(inlineStyles.test)), {
            scriptTests,
            styleTests
        };
    }, normalizeUrl = (url)=>url.replace(/([^:]\/)\/+/g, '$1'), joinUrlSegments = (s1, s2)=>s1 && s2 ? addTrailingSlash(s1) + s2.replace(/^\/+/, '') : s1 || s2 || '', stripBase = (path, base)=>{
        if (path === base) return '/';
        let trailingSlashBase = addTrailingSlash(base);
        return path.startsWith(trailingSlashBase) ? path.slice(trailingSlashBase.length - 1) : path;
    }, getRoutes = (context)=>{
        let environmentWithHtml = context.environmentList.filter((item)=>Object.keys(item.htmlPaths).length > 0);
        if (0 === environmentWithHtml.length) return [];
        let commonDistPath = getCommonParentPath(environmentWithHtml.map((item)=>item.distPath));
        return environmentWithHtml.reduce((prev, environmentContext)=>{
            let { distPath, config } = environmentContext, distPrefix = (0, external_node_path_.relative)(commonDistPath, distPath).split(external_node_path_.sep).join('/'), routes = formatRoutes(environmentContext.htmlPaths, context.normalizedConfig.server.base, external_node_path_.posix.join(distPrefix, config.output.distPath.html), config.html.outputStructure);
            return prev.concat(...routes);
        }, []);
    }, formatRoutes = (entry, base, distPathPrefix, outputStructure)=>{
        let prefix = joinUrlSegments(base, ((input)=>{
            let prefix = input;
            if (prefix?.startsWith('./') && (prefix = prefix.replace('./', '')), !prefix) return '/';
            let hasLeadingSlash = prefix.startsWith('/'), hasTailSlash = prefix.endsWith('/');
            return `${hasLeadingSlash ? '' : '/'}${prefix}${hasTailSlash ? '' : '/'}`;
        })(distPathPrefix));
        return Object.keys(entry).map((entryName)=>({
                entryName,
                pathname: prefix + ('index' === entryName && 'nested' !== outputStructure ? '' : entryName)
            })).sort((a)=>'index' === a.entryName ? -1 : 1);
    };
    function getURLMessages(urls, routes) {
        if (routes.length <= 1) {
            let pathname = routes.length ? routes[0].pathname : '';
            return urls.map(({ label, url })=>{
                let normalizedPathname = normalizeUrl(`${url}${pathname}`), prefix = `  ${color.dim(label.padEnd(10))}`;
                return `  ${prefix}${color.cyan(normalizedPathname)}\n`;
            }).join('');
        }
        let message = '', prevLabel = '', maxNameLength = Math.max(...routes.map((r)=>r.entryName.length));
        return urls.forEach(({ label, url }, index)=>{
            for (let { entryName, pathname } of (prevLabel !== label && (index > 0 && (message += '\n'), message += `    ${label}\n`, prevLabel = label), routes))message += `  ${color.dim('-')}  ${color.dim(entryName.padEnd(maxNameLength + 4))}${color.cyan(normalizeUrl(`${url}${pathname}`))}\n`;
        }), message;
    }
    function printServerURLs({ urls: originalUrls, port, routes, protocol, printUrls, trailingLineBreak = !0 }) {
        if (!1 === printUrls) return null;
        let urls = originalUrls, useCustomUrl = isFunction(printUrls);
        if (useCustomUrl) {
            let newUrls = printUrls({
                urls: urls.map((item)=>item.url),
                port,
                routes,
                protocol
            });
            if (!newUrls) return null;
            if (!Array.isArray(newUrls)) throw Error(`${color.dim('[rsbuild:config]')} "server.printUrls" must return an array, but got ${typeof newUrls}.`);
            urls = newUrls.map((u)=>{
                let { url, label } = 'string' == typeof u ? {
                    url: u
                } : u;
                return {
                    url,
                    label: label ?? getUrlLabel(url)
                };
            });
        }
        if (0 === urls.length || 0 === routes.length && !useCustomUrl) return null;
        let message = getURLMessages(urls, routes);
        return !trailingLineBreak && message.endsWith('\n') && (message = message.slice(0, -1)), logger.log(message), message;
    }
    let getPort = async ({ host, port, strictPort, tryLimits = 20 })=>{
        'string' == typeof port && (port = Number.parseInt(port, 10)), strictPort && (tryLimits = 1);
        let { createServer } = await import("node:net"), original = port, found = !1, attempts = 0;
        for(; !found && attempts <= tryLimits;)try {
            await new Promise((resolve, reject)=>{
                let server = createServer();
                server.unref(), server.on('error', reject), server.listen({
                    port,
                    host
                }, ()=>{
                    found = !0, server.close(resolve);
                });
            });
        } catch (e) {
            if ('EADDRINUSE' !== e.code) throw e;
            port++, attempts++;
        }
        if (port !== original && strictPort) throw Error(`${color.dim('[rsbuild:server]')} Port ${color.yellow(original)} is occupied, please choose another one.`);
        return port;
    }, getServerConfig = async ({ config })=>{
        let { host, port: originalPort, strictPort } = config.server, port = await getPort({
            host,
            port: originalPort,
            strictPort
        }), https = !!config.server.https, portTip = port !== originalPort ? `port ${originalPort} is in use, ${color.yellow(`using port ${port}.`)}` : void 0;
        return {
            port,
            host,
            https,
            portTip
        };
    }, isLoopbackHost = (host)=>new Set([
            'localhost',
            '127.0.0.1',
            '::1',
            '0000:0000:0000:0000:0000:0000:0000:0001'
        ]).has(host), getHostInUrl = async (host)=>{
        if (host === DEFAULT_DEV_HOST) return 'localhost';
        let { isIPv6 } = await import("node:net");
        return isIPv6(host) ? '::' === host ? '[::1]' : `[${host}]` : host;
    }, concatUrl = ({ host, port, protocol })=>`${protocol}://${host}:${port}`, LOCAL_LABEL = 'Local:  ', NETWORK_LABEL = 'Network:  ', getUrlLabel = (url)=>{
        try {
            let { hostname } = new URL(url);
            return isLoopbackHost(hostname) ? LOCAL_LABEL : NETWORK_LABEL;
        } catch  {
            return NETWORK_LABEL;
        }
    }, getAddressUrls = async ({ protocol = 'http', port, host })=>{
        if (host && host !== DEFAULT_DEV_HOST) {
            let url = concatUrl({
                port,
                host: await getHostInUrl(host),
                protocol
            });
            return [
                {
                    label: isLoopbackHost(host) ? LOCAL_LABEL : NETWORK_LABEL,
                    url
                }
            ];
        }
        let ipv4Interfaces = (()=>{
            let interfaces = external_node_os_default().networkInterfaces(), ipv4Interfaces = new Map();
            for (let key of Object.keys(interfaces))for (let detail of interfaces[key]){
                let familyV4Value = 'string' == typeof detail.family ? 'IPv4' : 4;
                detail.family !== familyV4Value || ipv4Interfaces.has(detail.address) || ipv4Interfaces.set(detail.address, detail);
            }
            return Array.from(ipv4Interfaces.values());
        })(), addressUrls = [], hasLocalUrl = !1;
        for (let detail of ipv4Interfaces)if (isLoopbackHost(detail.address) || detail.internal) {
            if (hasLocalUrl) continue;
            addressUrls.push({
                label: LOCAL_LABEL,
                url: concatUrl({
                    host: 'localhost',
                    port,
                    protocol
                })
            }), hasLocalUrl = !0;
        } else addressUrls.push({
            label: NETWORK_LABEL,
            url: concatUrl({
                host: detail.address,
                port,
                protocol
            })
        });
        return addressUrls;
    };
    function getServerTerminator(server) {
        let listened = !1, pendingSockets = new Set(), onConnection = (socket)=>{
            pendingSockets.add(socket), socket.on('close', ()=>{
                pendingSockets.delete(socket);
            });
        };
        return server.on('connection', onConnection), server.on('secureConnection', onConnection), server.once('listening', ()=>{
            listened = !0;
        }), ()=>new Promise((resolve, reject)=>{
                for (let socket of pendingSockets)socket.destroy();
                listened ? server.close((err)=>{
                    err ? reject(err) : resolve();
                }) : resolve();
            });
    }
    function escapeHtml(text) {
        return text ? text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;') : '';
    }
    let supportedChromiumBrowsers = [
        'Google Chrome Canary',
        'Google Chrome Dev',
        'Google Chrome Beta',
        'Google Chrome',
        'Microsoft Edge',
        'Brave Browser',
        'Vivaldi',
        'Chromium'
    ], mapChromiumBrowserName = (browser)=>'chrome' === browser || 'google chrome' === browser ? 'Google Chrome' : browser;
    async function openBrowser(url) {
        var browser, browserArgs;
        let browser1 = process.env.BROWSER, browserArgs1 = process.env.BROWSER_ARGS;
        if (browser = browser1, browserArgs = browserArgs1, 'darwin' === process.platform && (!browser || !browserArgs) && (!browser || supportedChromiumBrowsers.includes(mapChromiumBrowserName(browser)))) {
            let { exec } = await import("node:child_process"), { promisify } = await import("node:util"), execAsync = promisify(exec), getDefaultBrowserForAppleScript = async ()=>{
                let { stdout: ps } = await execAsync('ps cax');
                return supportedChromiumBrowsers.find((b)=>ps.includes(b));
            };
            try {
                let chromiumBrowser = browser1 ? mapChromiumBrowserName(browser1) : await getDefaultBrowserForAppleScript();
                if (chromiumBrowser) return await execAsync(`osascript openChrome.applescript "${encodeURI(url)}" "${chromiumBrowser}"`, {
                    cwd: STATIC_PATH
                }), !0;
                logger.debug('failed to find the target browser.');
            } catch (err) {
                logger.debug("failed to open start URL with apple script."), logger.debug(err);
            }
        }
        let { apps, default: baseOpen } = await __webpack_require__.e("664").then(__webpack_require__.bind(__webpack_require__, "../../node_modules/.pnpm/open@10.2.0/node_modules/open/index.js"));
        try {
            let options = browser1 ? {
                app: {
                    name: apps[browser1] ?? browser1,
                    arguments: browserArgs1?.split(' ')
                }
            } : {};
            return (await baseOpen(url, options)).on('error', (err)=>{
                logger.error('Failed to launch browser in child process', err);
            }), !0;
        } catch (err) {
            return logger.error('Failed to launch browser.'), logger.error(err), !1;
        }
    }
    let openedURLs = [], replacePortPlaceholder = (url, port)=>url.replace(/<port>/g, String(port));
    function resolveUrl(str, base) {
        if (canParse(str)) return str;
        try {
            return new URL(str, base).href;
        } catch  {
            throw Error(`${color.dim('[rsbuild:open]')} Invalid input: ${color.yellow(str)} is not a valid URL or pathname`);
        }
    }
    async function open_open({ https, port, routes, config, clearCache }) {
        if ('true' === process.env.CSB) return;
        let { targets, before } = ((config)=>{
            let { open } = config.server;
            return 'boolean' == typeof open ? {
                targets: []
            } : 'string' == typeof open ? {
                targets: [
                    open
                ]
            } : Array.isArray(open) ? {
                targets: open
            } : {
                targets: open.target ? helpers_castArray(open.target) : [],
                before: open.before
            };
        })(config);
        clearCache && (openedURLs = []);
        let urls = [], host = await getHostInUrl(config.server.host), baseUrl = `${https ? 'https' : 'http'}://${host}:${port}`;
        for (let url of (targets.length ? urls.push(...targets.map((target)=>resolveUrl(replacePortPlaceholder(target, port), baseUrl))) : routes.length && urls.push(`${baseUrl}${routes[0].pathname}`), before && await before(), urls))openedURLs.includes(url) || (openBrowser(url), openedURLs.push(url));
    }
    function recursiveChunkGroup(chunkGroup, visited = new Set()) {
        if (visited.has(chunkGroup)) return [];
        visited.add(chunkGroup);
        let parents = chunkGroup.getParents();
        return parents.length ? parents.flatMap((chunkParent)=>recursiveChunkGroup(chunkParent, visited)) : [
            chunkGroup.name
        ];
    }
    function recursiveChunkEntryNames(chunk) {
        let [...chunkGroups] = chunk.groupsIterable;
        return [
            ...new Set(chunkGroups.flatMap((chunkGroup)=>recursiveChunkGroup(chunkGroup)).filter((name)=>!!name))
        ];
    }
    function isChunksFiltered(chunkName, includeChunks, excludeChunks) {
        return !(Array.isArray(includeChunks) && -1 === includeChunks.indexOf(chunkName) || Array.isArray(excludeChunks) && -1 !== excludeChunks.indexOf(chunkName));
    }
    function doesChunkBelongToHtml({ chunk, htmlPluginData }) {
        let { options } = htmlPluginData.plugin;
        return recursiveChunkEntryNames(chunk).some((chunkName)=>isChunksFiltered(chunkName, options?.chunks, options?.excludeChunks));
    }
    let isCSSPath = (filePath)=>filePath.endsWith('.css');
    function normalizeManifestObjectConfig(manifest) {
        if ('string' == typeof manifest) return {
            filename: manifest
        };
        let defaultOptions = {
            filename: 'manifest.json'
        };
        return 'boolean' == typeof manifest ? defaultOptions : {
            ...defaultOptions,
            ...manifest
        };
    }
    function pluginModuleFederation() {
        return {
            name: 'rsbuild:module-federation',
            setup (api) {
                'webpack' !== api.context.bundlerType && (api.modifyRsbuildConfig((config)=>{
                    let { moduleFederation } = config;
                    if (moduleFederation?.options && moduleFederation.options.exposes) {
                        let userConfig = api.getRsbuildConfig('original');
                        config.dev ||= {}, config.server ||= {}, userConfig.server?.cors === void 0 && (config.server.cors = !0), config.server?.port && !config.dev.client?.port && (config.dev.client ||= {}, config.dev.client.port = config.server.port), userConfig.dev?.assetPrefix === void 0 && config.dev.assetPrefix === config.server?.base && (config.dev.assetPrefix = !0);
                    }
                }), api.modifyEnvironmentConfig((config)=>{
                    config.moduleFederation?.options && (config.performance?.chunkSplit?.strategy === 'split-by-experience' && (config.performance.chunkSplit = {
                        ...config.performance.chunkSplit,
                        strategy: 'custom'
                    }), config.source.include = [
                        ...config.source.include || [],
                        /@module-federation[\\/]/
                    ]);
                }), api.modifyBundlerChain((chain, { CHAIN_ID, target, environment })=>{
                    let { config } = environment;
                    if (!config.moduleFederation?.options || 'web' !== target) return;
                    let { options } = config.moduleFederation;
                    chain.plugin(CHAIN_ID.PLUGIN.MODULE_FEDERATION).use(rspack_rspack.container.ModuleFederationPlugin, [
                        options
                    ]), options.name && !chain.output.get('uniqueName') && chain.output.set('uniqueName', options.name);
                }));
            }
        };
    }
    function getPublicPath({ isDev, config, context }) {
        let { dev, output, server } = config, publicPath = DEFAULT_ASSET_PREFIX;
        if (isDev) {
            if ('string' == typeof dev.assetPrefix) publicPath = dev.assetPrefix;
            else if (dev.assetPrefix) {
                let protocol = context.devServer?.https ? 'https' : 'http', hostname = context.devServer?.hostname || DEFAULT_DEV_HOST;
                publicPath = hostname === DEFAULT_DEV_HOST ? `${protocol}://localhost:<port>/` : `${protocol}://${hostname}:<port>/`, server.base && '/' !== server.base && (publicPath = urlJoin(publicPath, server.base));
            }
        } else 'string' == typeof output.assetPrefix && (publicPath = output.assetPrefix);
        let defaultPort = server.port ?? 3000;
        return formatPublicPath(replacePortPlaceholder(publicPath, isDev ? context.devServer?.port ?? defaultPort : defaultPort));
    }
    let resolve_require = (0, external_node_module_.createRequire)(__rslib_import_meta_url__);
    function applyAlias({ chain, config, rootPath }) {
        let mergedAlias = reduceConfigs({
            initial: {},
            config: config.resolve.alias
        });
        if (config.source.alias && (logger.warn(`${color.dim('[rsbuild:config]')} The ${color.yellow('"source.alias"')} config is deprecated, use ${color.yellow('"resolve.alias"')} instead.`), mergedAlias = reduceConfigs({
            initial: mergedAlias,
            config: config.source.alias
        })), config.resolve.dedupe) for (let pkgName of config.resolve.dedupe){
            let pkgPath;
            if (mergedAlias[pkgName]) {
                logger.debug(`${color.dim('[rsbuild:resolve]')} The package ${color.yellow(pkgName)} is already in the alias config, dedupe option for ${color.yellow(pkgName)} will be ignored.`);
                continue;
            }
            try {
                pkgPath = (0, external_node_path_.dirname)(resolve_require.resolve(`${pkgName}/package.json`, {
                    paths: [
                        rootPath
                    ]
                }));
            } catch  {}
            if (!pkgPath) try {
                pkgPath = resolve_require.resolve(pkgName, {
                    paths: [
                        rootPath
                    ]
                });
                let trailing = [
                    'node_modules',
                    ...pkgName.split('/')
                ].join(external_node_path_.sep);
                for(; !pkgPath.endsWith(trailing) && pkgPath.includes('node_modules');)pkgPath = (0, external_node_path_.dirname)(pkgPath);
            } catch  {
                logger.debug(`${color.dim('[rsbuild:resolve]')} The package ${color.yellow(pkgName)} is not resolved in the project, dedupe option for ${color.yellow(pkgName)} will be ignored.`);
                continue;
            }
            mergedAlias[pkgName] = pkgPath;
        }
        for (let name of Object.keys(mergedAlias)){
            let formattedValues = helpers_castArray(mergedAlias[name]).map((value)=>'string' == typeof value && value.startsWith('.') ? ensureAbsolutePath(rootPath, value) : value);
            chain.resolve.alias.set(name, 1 === formattedValues.length ? formattedValues[0] : formattedValues);
        }
    }
    function isAsyncChunk(chunk) {
        return 'canBeInitial' in chunk ? !chunk.canBeInitial() : 'isInitial' in chunk && !chunk.isInitial();
    }
    function extractChunks(compilation, includeType) {
        let chunks = [
            ...compilation.chunks
        ];
        if (void 0 === includeType || 'async-chunks' === includeType) return chunks.filter(isAsyncChunk);
        if ('initial' === includeType) return chunks.filter((chunk)=>!isAsyncChunk(chunk));
        if ('all-chunks' === includeType) return chunks;
        if ('all-assets' === includeType) {
            let licenseAssets = [
                ...compilation.assetsInfo?.values() || []
            ].map((info)=>!!info.related?.license && info.related.license).filter(Boolean);
            return [
                {
                    files: Object.keys(compilation.assets).filter((t)=>!licenseAssets.includes(t))
                }
            ];
        }
        return chunks;
    }
    function getResourceType({ href, file }) {
        let url = new external_node_url_.URL(file || href, 'https://example.com'), extension = external_node_path_default().extname(url.pathname).slice(1);
        return [
            'css'
        ].includes(extension) ? 'style' : IMAGE_EXTENSIONS.includes(extension) ? 'image' : VIDEO_EXTENSIONS.includes(extension) ? 'video' : AUDIO_EXTENSIONS.includes(extension) ? 'audio' : FONT_EXTENSIONS.includes(extension) ? 'font' : [
            'vtt'
        ].includes(extension) ? 'track' : "script";
    }
    let HtmlResourceHintsPlugin_defaultOptions = {
        type: 'async-chunks',
        dedupe: !0
    };
    function filterResourceHints(resourceHints, scripts) {
        return resourceHints.filter((resourceHint)=>!scripts.find((script)=>script.attributes.src === resourceHint.attributes.href));
    }
    function generateLinks(options, type, compilation, data, HTMLCount, isDev) {
        let extractedChunks = extractChunks(compilation, options.type), sortedFilteredFiles = ((files, include, exclude)=>{
            let includeRegExp = [], excludeRegExp = [], includeFn = [], excludeFn = [];
            if (include) for (let item of helpers_castArray(include))'string' == typeof item ? includeRegExp.push(new RegExp(item)) : isFunction(item) ? includeFn.push(item) : includeRegExp.push(item);
            if (exclude) for (let item of helpers_castArray(exclude))'string' == typeof item ? excludeRegExp.push(new RegExp(item)) : isFunction(item) ? excludeFn.push(item) : excludeRegExp.push(item);
            return files.filter((file)=>{
                let includeMatched = !1;
                for (let item of includeRegExp)item.test(file) && (includeMatched = !0);
                for (let item of includeFn)item(file) && (includeMatched = !0);
                if (includeRegExp.length + includeFn.length > 0 && !includeMatched) return !1;
                for (let item of excludeRegExp)if (item.test(file)) return !1;
                for (let item of excludeFn)if (item(file)) return !1;
                return !0;
            });
        })([
            ...new Set(('all-assets' === options.type || 1 === HTMLCount ? extractedChunks : extractedChunks.filter((chunk)=>doesChunkBelongToHtml({
                    chunk: chunk,
                    compilation,
                    htmlPluginData: data,
                    pluginOptions: options
                }))).reduce((accumulated, chunk)=>accumulated.concat([
                    ...chunk.files,
                    ...chunk.auxiliaryFiles || []
                ]), []).filter((file)=>!(isDev && file.endsWith('.hot-update.js')) && !file.endsWith('.map')))
        ], options.include, options.exclude).sort(), links = [], { publicPath, crossOriginLoading } = compilation.outputOptions;
        for (let file of sortedFilteredFiles){
            let href = ensureAssetPrefix(file, publicPath), attributes = {
                href,
                rel: type
            };
            'preload' === type && (attributes.as = getResourceType({
                href,
                file
            }), 'font' === attributes.as && (attributes.crossorigin = ''), ("script" === attributes.as || 'style' === attributes.as) && crossOriginLoading && ('use-credentials' === crossOriginLoading || '/' !== publicPath) && (attributes.crossorigin = 'anonymous' === crossOriginLoading ? '' : crossOriginLoading)), links.push({
                tagName: 'link',
                attributes,
                voidTag: !0,
                meta: {}
            });
        }
        return links;
    }
    class HtmlResourceHintsPlugin {
        options;
        name = 'HtmlResourceHintsPlugin';
        resourceHints = [];
        type;
        HTMLCount;
        isDev;
        getHTMLPlugin;
        constructor(options, type, HTMLCount, isDev, getHTMLPlugin){
            this.options = {
                ...HtmlResourceHintsPlugin_defaultOptions,
                ...options
            }, this.type = type, this.HTMLCount = HTMLCount, this.isDev = isDev, this.getHTMLPlugin = getHTMLPlugin;
        }
        apply(compiler) {
            compiler.hooks.compilation.tap(this.name, (compilation)=>{
                let pluginHooks = this.getHTMLPlugin().getCompilationHooks(compilation), pluginName = `HTML${upperFirst(this.type)}Plugin`;
                pluginHooks.beforeAssetTagGeneration.tap(pluginName, (data)=>(this.resourceHints = generateLinks(this.options, this.type, compilation, data, this.HTMLCount, this.isDev), data)), pluginHooks.alterAssetTags.tap(pluginName, (data)=>(this.resourceHints && (data.assetTags.styles = [
                        ...this.options.dedupe ? filterResourceHints(this.resourceHints, data.assetTags.scripts) : this.resourceHints,
                        ...data.assetTags.styles
                    ]), data));
            });
        }
    }
    let resourceHints_generateLinks = (options, rel)=>options.map((option)=>({
                tag: 'link',
                attrs: {
                    rel,
                    ...option
                }
            })), rsdoctor_require = (0, external_node_module_.createRequire)(__rslib_import_meta_url__);
    function resolveLayer(value) {
        return "OVERVIEW" === value ? 'info' : "ALL" === value ? 'trace' : value;
    }
    async function ensureFileDir(outputFilePath) {
        let dir = external_node_path_default().dirname(outputFilePath);
        await external_node_fs_default().promises.mkdir(dir, {
            recursive: !0
        });
    }
    async function applyProfile(root, filterValue, traceLayer = 'perfetto', traceOutput) {
        if ('perfetto' !== traceLayer && 'logger' !== traceLayer) throw Error(`unsupported trace layer: ${traceLayer}`);
        if (!traceOutput) {
            let timestamp = Date.now(), defaultOutputDir = external_node_path_default().join(root, `.rspack-profile-${timestamp}-${process.pid}`), defaultRustTracePerfettoOutput = external_node_path_default().join(defaultOutputDir, 'rspack.pftrace');
            traceOutput = 'perfetto' === traceLayer ? defaultRustTracePerfettoOutput : 'stdout';
        }
        let filter = resolveLayer(filterValue);
        return await ensureFileDir(traceOutput), await rspack_rspack.experiments.globalTrace.register(filter, traceLayer, traceOutput), traceOutput;
    }
    function getForceSplittingGroups(forceSplitting, strategy) {
        let cacheGroups = {};
        for (let [key, regexp] of Array.isArray(forceSplitting) ? forceSplitting.map((regexp, index)=>[
                `force-split-${index}`,
                regexp
            ]) : Object.entries(forceSplitting))cacheGroups[key] = {
            test: regexp,
            name: key,
            chunks: 'all',
            priority: +('single-vendor' === strategy),
            enforce: !0
        };
        return cacheGroups;
    }
    let MODULE_PATH_REGEX = /.*[\\/]node_modules[\\/](?!\.pnpm[\\/])(?:(@[^\\/]+)[\\/])?([^\\/]+)/;
    function getPackageNameFromModulePath(modulePath) {
        let handleModuleContext = modulePath?.match(MODULE_PATH_REGEX);
        if (!handleModuleContext) return;
        let [, scope, name] = handleModuleContext;
        return [
            'npm',
            (scope ?? '').replace('@', ''),
            name
        ].filter(Boolean).join('.');
    }
    let SPLIT_STRATEGY_DISPATCHER = {
        'split-by-experience': function splitByExperience(ctx) {
            let { override, polyfill, defaultConfig, forceSplittingGroups } = ctx, experienceCacheGroup = {}, packageRegExps = {
                axios: /node_modules[\\/]axios(-.+)?[\\/]/
            };
            for (let [name, test] of (('entry' === polyfill || 'usage' === polyfill) && (packageRegExps.polyfill = /node_modules[\\/](?:tslib|core-js|@swc[\\/]helpers)[\\/]/), Object.entries(packageRegExps))){
                let key = `lib-${name}`;
                experienceCacheGroup[key] = {
                    test,
                    priority: 0,
                    name: key
                };
            }
            return {
                ...defaultConfig,
                ...override,
                cacheGroups: {
                    ...defaultConfig.cacheGroups,
                    ...experienceCacheGroup,
                    ...forceSplittingGroups,
                    ...override.cacheGroups
                }
            };
        },
        'split-by-module': function splitByModule(ctx) {
            let { override, forceSplittingGroups, defaultConfig } = ctx;
            return {
                ...defaultConfig,
                minSize: 0,
                maxInitialRequests: 1 / 0,
                ...override,
                cacheGroups: {
                    ...defaultConfig.cacheGroups,
                    ...forceSplittingGroups,
                    vendors: {
                        priority: -9,
                        test: NODE_MODULES_REGEX,
                        name: (module)=>module ? getPackageNameFromModulePath(module.context) : void 0
                    },
                    ...override.cacheGroups
                }
            };
        },
        'split-by-size': function splitBySize(ctx) {
            let { override, forceSplittingGroups, defaultConfig, userConfig } = ctx;
            return {
                ...defaultConfig,
                minSize: userConfig.minSize ?? 0,
                maxSize: userConfig.maxSize ?? 1 / 0,
                ...override,
                cacheGroups: {
                    ...defaultConfig.cacheGroups,
                    ...forceSplittingGroups,
                    ...override.cacheGroups
                }
            };
        },
        custom: function splitCustom(ctx) {
            let { override, forceSplittingGroups, defaultConfig } = ctx;
            return {
                ...defaultConfig,
                ...override,
                cacheGroups: {
                    ...defaultConfig.cacheGroups,
                    ...forceSplittingGroups,
                    ...override.cacheGroups
                }
            };
        },
        'all-in-one': function allInOne(_ctx) {
            return !1;
        },
        'single-vendor': function singleVendor(ctx) {
            let { override, defaultConfig, forceSplittingGroups } = ctx;
            return {
                ...defaultConfig,
                ...override,
                cacheGroups: {
                    ...defaultConfig.cacheGroups,
                    singleVendor: {
                        test: NODE_MODULES_REGEX,
                        priority: 0,
                        chunks: 'all',
                        name: 'vendor',
                        enforce: !0
                    },
                    ...forceSplittingGroups,
                    ...override.cacheGroups
                }
            };
        }
    }, swc_require = (0, external_node_module_.createRequire)(__rslib_import_meta_url__), builtinSwcLoaderName = 'builtin:swc-loader';
    function applyScriptCondition({ rule, isDev, config, rsbuildTarget }) {
        for (let condition of (rule.include.add({
            not: NODE_MODULES_REGEX
        }), rule.include.add(/\.(?:ts|tsx|jsx|mts|cts)$/), 'web' === rsbuildTarget && isDev && rule.include.add(/[\\/]@rsbuild[\\/]core[\\/]dist[\\/]/), config.source.include || []))rule.include.add(normalizeRuleConditionPath(condition));
        for (let condition of config.source.exclude || [])rule.exclude.add(normalizeRuleConditionPath(condition));
    }
    function getDefaultSwcConfig({ browserslist, cacheRoot, config, isProd }) {
        return {
            jsc: {
                externalHelpers: !0,
                parser: {
                    tsx: !1,
                    syntax: "typescript",
                    decorators: !0
                },
                experimental: {
                    cacheRoot,
                    keepImportAttributes: !0
                },
                output: {
                    charset: config.output.charset
                }
            },
            isModule: 'unknown',
            env: {
                targets: browserslist
            },
            rspackExperiments: {
                collectTypeScriptInfo: {
                    typeExports: !0,
                    exportedEnum: isProd
                }
            }
        };
    }
    function applyCoreJs(swcConfig, polyfillMode) {
        let coreJsPath = swc_require.resolve('core-js/package.json'), version = ((corejsPkgPath)=>{
            try {
                let rawJson = external_node_fs_default().readFileSync(corejsPkgPath, 'utf-8'), { version } = JSON.parse(rawJson), [major, minor] = version.split('.');
                return `${major}.${minor}`;
            } catch  {
                return '3';
            }
        })(coreJsPath), coreJsDir = external_node_path_default().dirname(coreJsPath);
        return swcConfig.env.coreJs = version, 'usage' === polyfillMode && (swcConfig.env.shippedProposals = !0), coreJsDir;
    }
    function applyTransformImport(swcConfig, pluginImport) {
        let finalPluginImport = ((options)=>{
            if (!options) return [];
            let imports = [];
            for (let item of helpers_castArray(options))isFunction(item) ? imports = item(imports) ?? imports : imports.push(item);
            return imports;
        })(pluginImport);
        finalPluginImport?.length && (swcConfig.rspackExperiments ??= {}, swcConfig.rspackExperiments.import ??= [], swcConfig.rspackExperiments.import.push(...finalPluginImport));
    }
    function applySwcDecoratorConfig(swcConfig, config) {
        swcConfig.jsc ||= {}, swcConfig.jsc.transform ||= {};
        let { version } = config.source.decorators;
        switch(version){
            case 'legacy':
                swcConfig.jsc.transform.legacyDecorator = !0, swcConfig.jsc.transform.decoratorMetadata = !0, swcConfig.jsc.transform.useDefineForClassFields = !1;
                break;
            case '2022-03':
                swcConfig.jsc.transform.legacyDecorator = !1, swcConfig.jsc.transform.decoratorVersion = '2022-03';
                break;
            default:
                throw Error(`${color.dim('[rsbuild:swc]')} Unknown decorators version: ${color.yellow(version)}`);
        }
    }
    async function getLocalhostResolvedAddress() {
        let { promises: dns } = await import("node:dns"), [defaultLookup, explicitLookup] = await Promise.all([
            dns.lookup('localhost'),
            dns.lookup('localhost', {
                verbatim: !0
            })
        ]);
        return defaultLookup.family === explicitLookup.family && defaultLookup.address === explicitLookup.address ? void 0 : defaultLookup.address;
    }
    async function resolveHostname(host = 'localhost') {
        var host1;
        if ('localhost' === host) {
            let resolvedAddress = await getLocalhostResolvedAddress();
            if (resolvedAddress) return resolvedAddress;
        }
        return void 0 === host || (host1 = host, new Set([
            '0.0.0.0',
            '::',
            '0000:0000:0000:0000:0000:0000:0000:0000'
        ]).has(host1)) ? 'localhost' : host;
    }
    var on_finished = __webpack_require__("../../node_modules/.pnpm/on-finished@2.4.1/node_modules/on-finished/index.js"), on_finished_default = __webpack_require__.n(on_finished);
    let UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
    async function getFileFromUrl(url, outputFileSystem, context) {
        let pathname = getPathnameFromUrl(url);
        try {
            pathname = decodeURIComponent(pathname);
        } catch  {
            return {
                errorCode: 400
            };
        }
        if (!pathname) return;
        if (pathname.includes('\0')) return {
            errorCode: 400
        };
        if (UP_PATH_REGEXP.test(external_node_path_default().normalize(`./${pathname}`))) return {
            errorCode: 403
        };
        let stat = async (filename)=>new Promise((resolve, reject)=>{
                outputFileSystem.stat(filename, (err, stats)=>{
                    err ? reject(err) : resolve(stats);
                });
            }), { environmentList, publicPathnames } = context, distPaths = environmentList.map((env)=>env.distPath), possibleFilenames = new Set();
        for (let [index, distPath] of distPaths.entries()){
            let prefix = publicPathnames[index];
            prefix && '/' !== prefix && pathname.startsWith(prefix) && possibleFilenames.add(external_node_path_default().join(distPath, pathname.slice(prefix.length)));
        }
        for (let distPath of distPaths)possibleFilenames.add(external_node_path_default().join(distPath, pathname));
        for (let filename of possibleFilenames){
            let fsStats;
            try {
                fsStats = await stat(filename);
            } catch  {
                continue;
            }
            if (fsStats) {
                if (fsStats.isFile()) return {
                    filename,
                    fsStats
                };
                if (fsStats.isDirectory()) {
                    filename = external_node_path_default().join(filename, 'index.html');
                    try {
                        fsStats = await stat(filename);
                    } catch  {
                        continue;
                    }
                    if (!fsStats) continue;
                    if (fsStats.isFile()) return {
                        filename,
                        fsStats
                    };
                }
            }
        }
    }
    function parseTokenList(str) {
        let end = 0, start = 0, list = [];
        for(let i = 0, len = str.length; i < len; i++)switch(str.charCodeAt(i)){
            case 0x20:
                start === end && (start = end = i + 1);
                break;
            case 0x2c:
                start !== end && list.push(str.substring(start, end)), start = end = i + 1;
                break;
            default:
                end = i + 1;
        }
        return start !== end && list.push(str.substring(start, end)), list;
    }
    function getEtag(stat) {
        let mtime = stat.mtime.getTime().toString(16), size = stat.size.toString(16);
        return `W/"${size}-${mtime}"`;
    }
    function createReadStreamOrReadFileSync(filename, outputFileSystem, start, end) {
        let bufferOrStream = outputFileSystem.createReadStream(filename, {
            start,
            end
        });
        return {
            bufferOrStream,
            byteLength: 0 === end ? 0 : end - start + 1
        };
    }
    function getContentType(str) {
        let { lookup } = requireCompiledPackage('mrmime'), mime = lookup(str);
        return !!mime && ((mime.startsWith('text/') || 'application/json' === mime || 'application/manifest+json' === mime) && (mime += '; charset=utf-8'), mime);
    }
    let BYTES_RANGE_REGEXP = /^ *bytes/i;
    function getValueContentRangeHeader(type, size, range) {
        return `${type} ${range ? `${range.start}-${range.end}` : '*'}:${size}`.replace(':', '/');
    }
    function parseHttpDate(date) {
        let timestamp = date && Date.parse(date);
        return 'number' == typeof timestamp ? timestamp : NaN;
    }
    let CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
    function destroyStream(stream, suppress) {
        'function' == typeof stream.destroy && stream.destroy(), 'function' == typeof stream.close && stream.on('open', function onOpenClose(fd) {
            'number' == typeof fd && this.close();
        }), 'function' == typeof stream.addListener && suppress && (stream.removeAllListeners('error'), stream.addListener('error', ()=>{}));
    }
    let parseRangeHeaders = async (value)=>{
        let { default: rangeParser } = await __webpack_require__.e("603").then(__webpack_require__.t.bind(__webpack_require__, "../../node_modules/.pnpm/range-parser@1.2.1/node_modules/range-parser/index.js", 23)), [len, rangeHeader] = value.split('|');
        return rangeParser(Number(len), rangeHeader, {
            combine: !0
        });
    }, acceptedMethods = [
        'GET',
        'HEAD'
    ];
    function sendError(res, code) {
        let message = `${code} ${{
            400: 'Bad Request',
            403: 'Forbidden',
            404: 'Not Found',
            412: 'Precondition Failed',
            416: 'Range Not Satisfiable',
            500: 'Internal Server Error'
        }[code]}`, document1 = Buffer.from(`<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>${message}</title>
  </head>
  <body>
    <h1 style="text-align: center;">${message}</h1>
    <hr>
    <div style="text-align: center;">Rsbuild dev server</div>
  </body>
</html>`, 'utf-8');
        res.statusCode = code, res.setHeader('Content-Type', 'text/html; charset=utf-8'), res.setHeader('X-Content-Type-Options', 'nosniff');
        let byteLength = Buffer.byteLength(document1);
        res.setHeader('Content-Length', byteLength), res.end(document1);
    }
    function createMiddleware(context, ready, outputFileSystem) {
        return async function assetsMiddleware(req, res, next) {
            async function goNext() {
                return new Promise((resolve)=>{
                    ready(()=>{
                        next(), resolve();
                    });
                });
            }
            if (req.method && !acceptedMethods.includes(req.method)) return void await goNext();
            function isConditionalGET() {
                return req.headers['if-match'] || req.headers['if-unmodified-since'] || req.headers['if-none-match'] || req.headers['if-modified-since'];
            }
            function isPreconditionFailure() {
                let ifMatch = req.headers['if-match'];
                if (ifMatch) {
                    let etag = res.getHeader('ETag');
                    return !etag || '*' !== ifMatch && parseTokenList(ifMatch).every((match)=>match !== etag && match !== `W/${etag}` && `W/${match}` !== etag);
                }
                let ifUnmodifiedSince = req.headers['if-unmodified-since'];
                if (ifUnmodifiedSince) {
                    let unmodifiedSince = parseHttpDate(ifUnmodifiedSince);
                    if (!Number.isNaN(unmodifiedSince)) {
                        let lastModified = parseHttpDate(String(res.getHeader('Last-Modified')));
                        return Number.isNaN(lastModified) || lastModified > unmodifiedSince;
                    }
                }
                return !1;
            }
            function isCachable() {
                return res.statusCode >= 200 && res.statusCode < 300 || 304 === res.statusCode;
            }
            function isFresh(resHeaders) {
                let cacheControl = req.headers['cache-control'];
                if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) return !1;
                let noneMatch = req.headers['if-none-match'], modifiedSince = req.headers['if-modified-since'];
                if (!noneMatch && !modifiedSince) return !1;
                if (noneMatch && '*' !== noneMatch) {
                    if (!resHeaders.etag) return !1;
                    let matches = parseTokenList(noneMatch), etagStale = !0;
                    for(let i = 0; i < matches.length; i++){
                        let match = matches[i];
                        if (match === resHeaders.etag || match === `W/${resHeaders.etag}` || `W/${match}` === resHeaders.etag) {
                            etagStale = !1;
                            break;
                        }
                    }
                    if (etagStale) return !1;
                }
                if (noneMatch) return !0;
                if (modifiedSince) {
                    let lastModified = resHeaders['last-modified'];
                    if (!lastModified || !(parseHttpDate(String(lastModified)) <= parseHttpDate(modifiedSince))) return !1;
                }
                return !0;
            }
            function isRangeFresh() {
                let ifRange = req.headers['if-range'];
                if (!ifRange) return !0;
                if (-1 !== ifRange.indexOf('"')) {
                    let etag = res.getHeader('ETag');
                    return !etag || !!(etag && -1 !== ifRange.indexOf(etag));
                }
                let lastModified = res.getHeader('Last-Modified');
                return !lastModified || parseHttpDate(lastModified) <= parseHttpDate(ifRange);
            }
            function getRangeHeader() {
                let { range } = req.headers;
                if (range && BYTES_RANGE_REGEXP.test(range)) return range;
            }
            function getOffsetAndLenFromRange(range) {
                let { start, end } = range;
                return [
                    start,
                    end - start + 1
                ];
            }
            function calcStartAndEnd(start, len) {
                let end = Math.max(start, start + len - 1);
                return [
                    start,
                    end
                ];
            }
            ready(async function processRequest() {
                let bufferOrStream, byteLength;
                if (!req.url) return void await goNext();
                let resolved = await getFileFromUrl(req.url, outputFileSystem, context);
                if (!resolved) return void await goNext();
                if ('errorCode' in resolved) {
                    403 === resolved.errorCode ? logger.error(`[rsbuild:middleware] Malicious path "${req.url}".`) : 400 === resolved.errorCode && logger.error(`[rsbuild:middleware] Invalid pathname "${req.url}".`), sendError(res, resolved.errorCode);
                    return;
                }
                let { fsStats, filename } = resolved, { size } = fsStats, len = size, offset = 0;
                if (!res.getHeader('Content-Type')) {
                    let contentType = getContentType(filename);
                    contentType && res.setHeader('Content-Type', contentType);
                }
                res.getHeader('Accept-Ranges') || res.setHeader('Accept-Ranges', 'bytes');
                let rangeHeader = getRangeHeader();
                if (!res.getHeader('ETag') && fsStats) {
                    let hash = getEtag(fsStats);
                    res.setHeader('ETag', hash);
                }
                if (isConditionalGET()) {
                    if (isPreconditionFailure()) return void sendError(res, 412);
                    if (404 === res.statusCode && (res.statusCode = 200), isCachable() && isFresh({
                        etag: res.getHeader('ETag'),
                        'last-modified': res.getHeader('Last-Modified')
                    })) {
                        res.statusCode = 304, res.removeHeader('Content-Encoding'), res.removeHeader('Content-Language'), res.removeHeader('Content-Length'), res.removeHeader('Content-Range'), res.removeHeader('Content-Type'), res.end();
                        return;
                    }
                }
                if (rangeHeader) {
                    let parsedRanges = await parseRangeHeaders(`${size}|${rangeHeader}`);
                    if (isRangeFresh() || (parsedRanges = []), -1 === parsedRanges) {
                        logger.error("[rsbuild:middleware] Unsatisfiable range for 'Range' header."), res.setHeader('Content-Range', getValueContentRangeHeader('bytes', size)), sendError(res, 416);
                        return;
                    }
                    -2 === parsedRanges ? logger.error("[rsbuild:middleware] A malformed 'Range' header was provided. A regular response will be sent for this request.") : parsedRanges.length > 1 && logger.error("[rsbuild:middleware] A 'Range' header with multiple ranges was provided. Multiple ranges are not supported, so a regular response will be sent for this request."), -2 !== parsedRanges && 1 === parsedRanges.length && (res.statusCode = 206, res.setHeader('Content-Range', getValueContentRangeHeader('bytes', size, parsedRanges[0])), [offset, len] = getOffsetAndLenFromRange(parsedRanges[0]));
                }
                let [start, end] = calcStartAndEnd(offset, len);
                try {
                    ({ bufferOrStream, byteLength } = createReadStreamOrReadFileSync(filename, outputFileSystem, start, end));
                } catch  {
                    await goNext();
                    return;
                }
                if (res.setHeader('Content-Length', byteLength), 'HEAD' === req.method) {
                    404 === res.statusCode && (res.statusCode = 200), res.end();
                    return;
                }
                if ('function' != typeof bufferOrStream.pipe) return void res.end(bufferOrStream);
                let cleanup = ()=>{
                    destroyStream(bufferOrStream, !0);
                };
                bufferOrStream.on('error', (error)=>{
                    switch(cleanup(), error.code){
                        case 'ENAMETOOLONG':
                        case 'ENOENT':
                        case 'ENOTDIR':
                            sendError(res, 404);
                            break;
                        default:
                            sendError(res, 500);
                    }
                }), bufferOrStream.pipe(res), on_finished_default()(res, cleanup);
            });
        };
    }
    function setupOutputFileSystem(writeToDisk, compilers) {
        if (!0 !== writeToDisk) {
            let { createFsFromVolume, Volume } = requireCompiledPackage('memfs'), outputFileSystem = createFsFromVolume(new Volume());
            for (let compiler of compilers)compiler.outputFileSystem = outputFileSystem;
        }
        let compiler = compilers.find((compiler)=>!!compiler.outputFileSystem);
        return compiler?.outputFileSystem ?? external_node_fs_default();
    }
    function setupWriteToDisk(compilers, writeToDisk) {
        for (let compiler of compilers)compiler.hooks.emit.tap('DevMiddleware', ()=>{
            compiler.__hasRsbuildAssetEmittedCallback || (compiler.hooks.assetEmitted.tapAsync('DevMiddleware', (_file, info, callback)=>{
                let { targetPath, content, compilation } = info;
                if (!(!writeToDisk || 'function' != typeof writeToDisk || writeToDisk(targetPath, compilation.name))) return void callback();
                let dir = external_node_path_default().dirname(targetPath), name = compiler.options.name ? `Child "${compiler.options.name}": ` : '';
                external_node_fs_default().mkdir(dir, {
                    recursive: !0
                }, (mkdirError)=>{
                    if (mkdirError) {
                        logger.error(`[rsbuild:middleware] ${name}Unable to write "${dir}" directory to disk:\n${mkdirError.message}`), callback(mkdirError);
                        return;
                    }
                    external_node_fs_default().writeFile(targetPath, content, (writeFileError)=>{
                        if (writeFileError) {
                            logger.error(`[rsbuild:middleware] ${name}Unable to write "${targetPath}" asset to disk:\n${writeFileError.message}`), callback(writeFileError);
                            return;
                        }
                        callback();
                    });
                });
            }), compiler.__hasRsbuildAssetEmittedCallback = !0);
        });
    }
    let noop = ()=>{}, assets_middleware_require = (0, external_node_module_.createRequire)(__rslib_import_meta_url__);
    function getClientPaths(devConfig) {
        let clientPaths = [];
        return (devConfig.hmr || devConfig.liveReload) && (hmrClientPath || (hmrClientPath = assets_middleware_require.resolve('@rsbuild/core/client/hmr')), clientPaths.push(hmrClientPath), devConfig.client?.overlay && (overlayClientPath || (overlayClientPath = assets_middleware_require.resolve('@rsbuild/core/client/overlay')), clientPaths.push(overlayClientPath))), clientPaths;
    }
    let isTsError = (error)=>'message' in error && error.stack?.includes('ts-checker-rspack-plugin');
    function applyHMREntry({ config, compiler, token, resolvedHost, resolvedPort }) {
        if (!((compiler)=>{
            let { target } = compiler.options;
            return !!target && (Array.isArray(target) ? target.includes('web') : 'web' === target);
        })(compiler)) return;
        let clientPaths = getClientPaths(config.dev);
        if (!clientPaths.length) return;
        let clientConfig = {
            ...config.dev.client
        };
        for (let clientPath of ('<port>' === clientConfig.port && (clientConfig.port = resolvedPort), new compiler.webpack.DefinePlugin({
            RSBUILD_WEB_SOCKET_TOKEN: JSON.stringify(token),
            RSBUILD_CLIENT_CONFIG: JSON.stringify(clientConfig),
            RSBUILD_SERVER_HOST: JSON.stringify(resolvedHost),
            RSBUILD_SERVER_PORT: JSON.stringify(resolvedPort),
            RSBUILD_DEV_LIVE_RELOAD: config.dev.liveReload,
            RSBUILD_DEV_BROWSER_LOGS: config.dev.browserLogs
        }).apply(compiler), clientPaths))new compiler.webpack.EntryPlugin(compiler.context, clientPath, {
            name: void 0
        }).apply(compiler);
    }
    let assets_middleware_assetsMiddleware = async ({ config, compiler, context, socketServer, resolvedPort })=>{
        var config1, environments;
        let watching, writeToDiskValues, resolvedHost = await resolveHostname(config.server.host), { environments: environments1, environmentList } = context;
        applyToCompiler(compiler, (compiler, index)=>{
            let environment = environmentList[index];
            if (!environment) return;
            let token = environment.webSocketToken;
            token && (applyHMREntry({
                token,
                config: environment.config,
                compiler,
                resolvedHost,
                resolvedPort
            }), (({ context, compiler, token, socketServer })=>{
                if (((compiler)=>{
                    let { target } = compiler.options;
                    return !!target && (Array.isArray(target) ? target.includes('node') : 'node' === target);
                })(compiler)) return;
                let errorsCount = null;
                compiler.hooks.invalid.tap('rsbuild-dev-server', (fileName)=>{
                    errorsCount = null, 'string' == typeof fileName && fileName.endsWith('.html') && socketServer.sockWrite({
                        type: 'static-changed'
                    }, token);
                }), compiler.hooks.done.tap('rsbuild-dev-server', (stats)=>{
                    let { errors } = stats.compilation;
                    if (errors.length === errorsCount) return;
                    let isRecalled = null !== errorsCount;
                    if (errorsCount = errors.length, isRecalled) {
                        let tsErrors = errors.filter(isTsError);
                        if (!tsErrors.length) return;
                        let { stats: statsJson } = context.buildState, statsErrors = tsErrors.map((item)=>pick(item, [
                                'message',
                                'file'
                            ]));
                        statsJson && (statsJson.errors = statsJson.errors ? [
                            ...statsJson.errors,
                            ...statsErrors
                        ] : statsErrors), socketServer.sendError(statsErrors, token);
                        return;
                    }
                });
            })({
                context,
                compiler,
                socketServer,
                token
            }));
        });
        let compilers = compiler_isMultiCompiler(compiler) ? compiler.compilers : [
            compiler
        ], callbacks = [];
        compiler.hooks.done.tap('rsbuild-dev-middleware', ()=>{
            process.nextTick(()=>{
                'done' === context.buildState.status && (callbacks.forEach((callback)=>{
                    callback();
                }), callbacks.length = 0);
            });
        });
        let writeToDisk = (config1 = config.dev, environments = environments1, 1 === new Set(writeToDiskValues = environmentList.map((env)=>env.config.dev.writeToDisk)).size ? writeToDiskValues[0] : (filePath, name)=>{
            let { writeToDisk } = config1;
            return name && environments[name] && (writeToDisk = environments[name].config.dev.writeToDisk ?? writeToDisk), 'function' == typeof writeToDisk ? writeToDisk(filePath) : writeToDisk;
        });
        writeToDisk && setupWriteToDisk(compilers, writeToDisk);
        let outputFileSystem = setupOutputFileSystem(writeToDisk, compilers), instance = createMiddleware(context, (callback)=>{
            'done' === context.buildState.status ? callback() : callbacks.push(callback);
        }, outputFileSystem);
        return instance.watch = ()=>{
            if (compiler.watching) watching = compiler.watching;
            else {
                let watchOptions = compilers.length > 1 ? compilers.map(({ options })=>options.watchOptions || {}) : compilers[0].options.watchOptions || {};
                watching = compiler.watch(watchOptions, (error)=>{
                    error && (error.message?.includes(' Error:') && (error.message = error.message.replace(' Error:', '').trim()), logger.error(error));
                });
            }
        }, instance.close = (callback = noop)=>{
            watching?.close(callback);
        }, instance;
    };
    var UNKNOWN_FUNCTION = '<unknown>';
    function stack_trace_parser_esm_parse(stackString) {
        return stackString.split('\n').reduce(function(stack, line) {
            var parseResult = parseChrome(line) || parseWinjs(line) || parseGecko(line) || parseNode(line) || parseJSC(line);
            return parseResult && stack.push(parseResult), stack;
        }, []);
    }
    var chromeRe = /^\s*at (.*?) ?\(((?:file|https?|blob|chrome-extension|native|eval|webpack|rsc|<anonymous>|\/|[a-z]:\\|\\\\).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i, chromeEvalRe = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    function parseChrome(line) {
        var parts = chromeRe.exec(line);
        if (!parts) return null;
        var isNative = parts[2] && 0 === parts[2].indexOf('native'), isEval = parts[2] && 0 === parts[2].indexOf('eval'), submatch = chromeEvalRe.exec(parts[2]);
        return isEval && null != submatch && (parts[2] = submatch[1], parts[3] = submatch[2], parts[4] = submatch[3]), {
            file: isNative ? null : parts[2],
            methodName: parts[1] || UNKNOWN_FUNCTION,
            arguments: isNative ? [
                parts[2]
            ] : [],
            lineNumber: parts[3] ? +parts[3] : null,
            column: parts[4] ? +parts[4] : null
        };
    }
    var winjsRe = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|rsc|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function parseWinjs(line) {
        var parts = winjsRe.exec(line);
        return parts ? {
            file: parts[2],
            methodName: parts[1] || UNKNOWN_FUNCTION,
            arguments: [],
            lineNumber: +parts[3],
            column: parts[4] ? +parts[4] : null
        } : null;
    }
    var geckoRe = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|rsc|resource|\[native).*?|[^@]*bundle)(?::(\d+))?(?::(\d+))?\s*$/i, geckoEvalRe = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    function parseGecko(line) {
        var parts = geckoRe.exec(line);
        if (!parts) return null;
        var isEval = parts[3] && parts[3].indexOf(' > eval') > -1, submatch = geckoEvalRe.exec(parts[3]);
        return isEval && null != submatch && (parts[3] = submatch[1], parts[4] = submatch[2], parts[5] = null), {
            file: parts[3],
            methodName: parts[1] || UNKNOWN_FUNCTION,
            arguments: parts[2] ? parts[2].split(',') : [],
            lineNumber: parts[4] ? +parts[4] : null,
            column: parts[5] ? +parts[5] : null
        };
    }
    var javaScriptCoreRe = /^\s*(?:([^@]*)(?:\((.*?)\))?@)?(\S.*?):(\d+)(?::(\d+))?\s*$/i;
    function parseJSC(line) {
        var parts = javaScriptCoreRe.exec(line);
        return parts ? {
            file: parts[3],
            methodName: parts[1] || UNKNOWN_FUNCTION,
            arguments: [],
            lineNumber: +parts[4],
            column: parts[5] ? +parts[5] : null
        } : null;
    }
    var nodeRe = /^\s*at (?:((?:\[object object\])?[^\\/]+(?: \[as \S+\])?) )?\(?(.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    function parseNode(line) {
        var parts = nodeRe.exec(line);
        return parts ? {
            file: parts[2],
            methodName: parts[1] || UNKNOWN_FUNCTION,
            arguments: [],
            lineNumber: +parts[3],
            column: parts[4] ? +parts[4] : null
        } : null;
    }
    let isValidMethodName = (methodName)=>'<unknown>' !== methodName && !/[\\/]/.test(methodName);
    function getOriginalPosition(rawSourceMap, line, column) {
        let { TraceMap, originalPositionFor } = requireCompiledPackage('@jridgewell/trace-mapping');
        return originalPositionFor(new TraceMap(rawSourceMap), {
            line,
            column
        });
    }
    let parseFrame = async (frame, fs, context)=>{
        let { file, column, lineNumber } = frame, sourceMapInfo = await getFileFromUrl(`${file}.map`, fs, context);
        if (!sourceMapInfo || 'errorCode' in sourceMapInfo) return;
        let readFile = (0, external_node_util_.promisify)(fs.readFile);
        try {
            let sourceMap = await readFile(sourceMapInfo.filename);
            if (sourceMap) return {
                sourceMapPath: sourceMapInfo.filename,
                originalPosition: getOriginalPosition(sourceMap.toString(), lineNumber ?? 0, column ?? 0)
            };
        } catch (error) {
            error instanceof Error && logger.debug(`failed to map source map position: ${error.message}`);
        }
    }, resolveOriginalLocation = async (stack, fs, context)=>{
        let parsed = stack_trace_parser_esm_parse(stack);
        if (!parsed.length) return;
        let frame = parsed.find((frame)=>null !== frame.file && null !== frame.column && null !== frame.lineNumber && SCRIPT_REGEX.test(frame.file));
        if (!frame) return;
        let parsedFrame = await parseFrame(frame, fs, context);
        if (!parsedFrame) return;
        let { sourceMapPath, originalPosition } = parsedFrame;
        return {
            frame,
            location: formatOriginalLocation(sourceMapPath, originalPosition, context)
        };
    }, formatOriginalLocation = (sourceMapPath, originalMapping, context)=>{
        var source, sourceMapPath1, context1;
        let absoluteSourcePath, { source: source1, line, column } = originalMapping;
        if (!source1) return;
        let result = (source = source1, sourceMapPath1 = sourceMapPath, context1 = context, absoluteSourcePath = external_node_path_default().isAbsolute(source) ? source : external_node_path_default().join(external_node_path_default().dirname(sourceMapPath1), source), external_node_path_default().relative(context1.rootPath, absoluteSourcePath));
        return null !== line && (result += null === column ? `:${line}` : `:${line}:${column}`), result;
    }, formatFrameLocation = (frame)=>{
        let { file, lineNumber, column } = frame;
        if (file) return null !== lineNumber ? null !== column ? `${file}:${lineNumber}:${column}` : `${file}:${lineNumber}` : file;
    }, formatFullStack = async (stack, context, fs)=>{
        let parsed = stack_trace_parser_esm_parse(stack);
        if (!parsed.length) return;
        let result = '';
        for (let frame of parsed){
            let parsedFrame = await parseFrame(frame, fs, context), { methodName } = frame, parts = [];
            if (isValidMethodName(methodName) && parts.push(methodName), parsedFrame) {
                let { sourceMapPath, originalPosition } = parsedFrame, originalLocation = formatOriginalLocation(sourceMapPath, originalPosition, context);
                if (originalLocation) parts.push(originalLocation);
                else {
                    let frameString = formatFrameLocation(frame);
                    frameString && parts.push(frameString);
                }
            } else {
                let frameString = formatFrameLocation(frame);
                frameString && parts.push(frameString);
            }
            parts[0] && (result += `\n    at ${parts[0]}`), parts[1] && (result += ` (${parts[1]})`);
        }
        return result;
    }, formatBrowserErrorLog = async (message, context, fs, stackTrace)=>{
        var log;
        let log1 = `${color.cyan('[browser]')} ${color.red(message.message)}`;
        if (message.stack) switch(stackTrace){
            case 'summary':
                {
                    let resolved = await resolveOriginalLocation(message.stack, fs, context);
                    if (!resolved) break;
                    let { frame, location } = resolved, { methodName } = frame, suffix = '';
                    isValidMethodName(methodName) && (suffix += ` at ${methodName}`), location && (suffix += ` (${location})`), log1 += suffix ? color.dim(suffix) : '';
                    break;
                }
            case 'full':
                {
                    let fullStack = await formatFullStack(message.stack, context, fs);
                    fullStack && (log1 += fullStack);
                }
        }
        return (log = log1).includes('ReferenceError: process is not defined') ? `${log}\n${color.yellow(`        - \`process\` is a Node.js global and not available in browsers.
        - To access \`process.env.*\`, define them in a \`.env\` file with the \`PUBLIC_\` prefix.
        - Or configure them via \`source.define\`.
        - Alternatively, install \`@rsbuild/plugin-node-polyfill\` to polyfill Node.js globals.`)}` : log;
    }, styles = {
        1: 'font-weight:bold',
        2: 'opacity:0.5',
        3: 'font-style:italic',
        4: 'text-decoration:underline;text-underline-offset:3px',
        8: 'display:none',
        9: 'text-decoration:line-through',
        30: 'color:#000',
        31: 'color:#fb6a6a',
        32: 'color:#6ef790',
        33: 'color:#eff986',
        34: 'color:#6eb2f7',
        35: 'color:#f76ebe',
        36: 'color:#6eecf7',
        37: 'color:#f0f0f0',
        90: 'color:#888'
    };
    for(let i = 91; i <= 97; i++)styles[i] = styles[i - 60];
    let closeCode = [
        0,
        21,
        22,
        23,
        24,
        27,
        28,
        29,
        39,
        49
    ];
    function ansiHTML(text) {
        let ansiCodes = [], ret = text.replace(/\x1B\[([0-9;]+)m/g, (_match, sequences)=>{
            let style = '';
            for (let seq of sequences.split(';'))styles[seq] && (style += `${styles[seq]};`);
            return style ? (ansiCodes.push(sequences), `<span style="${style}">`) : closeCode.includes(Number(sequences)) && ansiCodes.length > 0 ? (ansiCodes.pop(), '</span>') : '';
        });
        return ansiCodes.length > 0 && (ret += Array(ansiCodes.length + 1).join('</span>')), ret;
    }
    function convertLinksInHtml(text, root) {
        let pathRegex = /(?:\.\.?[/\\]|[a-zA-Z]:\\|\/)[^:]*:\d+:\d+/g, urlRegex = /(https?:\/\/(?:[\w-]+\.)+[a-z0-9](?:[\w-.~:/?#[\]@!$&'*+,;=])*)/gi;
        return text.split('\n').map((line)=>{
            let replacedLine = line.replace(pathRegex, (file)=>{
                let hasClosingSpan = file.includes('</span>') && !file.includes('<span'), filePath = hasClosingSpan ? file.replace('</span>', '') : file, isAbsolute = external_node_path_default().isAbsolute(filePath), absolutePath = root && !isAbsolute ? external_node_path_default().join(root, filePath) : filePath, relativePath = root && isAbsolute ? toRelativePath(root, filePath) : filePath;
                return `<a class="file-link" data-file="${absolutePath}">${relativePath}</a>${hasClosingSpan ? '</span>' : ''}`;
            });
            return replacedLine = replacedLine.replace(urlRegex, (url)=>`<a class="url-link" href="${url}" target="_blank" rel="noopener noreferrer">${url}</a>`);
        }).join('\n');
    }
    function genOverlayHTML(errors, root) {
        let htmlItems = errors.map((item)=>convertLinksInHtml(ansiHTML(escapeHtml(item)), root));
        return `
<style>
.root {
  position: fixed;
  z-index: 9999;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  overflow-y: scroll;
  margin: 0;
  background: rgba(0, 0, 0, 0.66);
  cursor: pointer;
}
.container {
  font-family: Menlo, Consolas, monospace;
  line-height: 1.6;
  width: 960px;
  max-width: 85%;
  color: #d8d8d8;
  margin: 32px auto;
  padding: 32px 40px;
  position: relative;
  background: #181818;
  border-radius: 24px;
  box-shadow: 0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22);
  overflow: hidden;
  direction: ltr;
  text-align: left;
  box-sizing: border-box;
  cursor: default;
}
.title {
  margin: 0 0 20px;
  padding-bottom: 12px;
  font-size: 17px;
  font-weight: 600;
  color: #fb6a6a;
  border-bottom: 2px solid rgba(252,94,94,.66);
}
.content {
  margin: 0;
  font-size: 14px;
  font-family: inherit;
  overflow-x: scroll;
  scrollbar-width: none;
}
.content::-webkit-scrollbar {
  display: none;
}
.file-link,
.url-link,
.config-link {
  cursor: pointer;
  text-decoration: underline;
  text-underline-offset: 3px;
  &:hover {
    opacity: 0.8;
  }
  &:active {
    opacity: 0.6;
  }
}
.file-link {
  color: #6eecf7;
}
.url-link {
  color: #eff986;
}
.config-link {
  color: inherit;
  text-decoration: none;
}
.close {
  position: absolute;
  top: 27px;
  right: 32px;
  width: 32px;
  height: 32px;
  cursor: pointer;
}
.close:hover {
  opacity: 0.8;
}
.close:active {
  opacity: 0.6;
}
.close:before,
.close:after {
  position: absolute;
  left: 16px;
  top: 8px;
  content: ' ';
  height: 18px;
  width: 2px;
  border-radius: 4px;
  background-color: #b8b8b8;
}
.close:before {
  transform: rotate(45deg);
}
.close:after {
  transform: rotate(-45deg);
}
.footer {
  font-size: 12px;
  color: #7e6a92;
  margin-top: 20px;
  padding-top: 12px;
  border-top: 2px solid rgba(126,106,146,.6);
}
.footer p {
  margin: 4px 0 0;
}
.footer span {
  color: #a88dc3;
}
</style>

<div class="root">
  <div class="container">
    <div class="close"></div>
    <p class="title">Build failed</p>
    <pre class="content">${htmlItems.join('\n\n').trim()}</pre>
    <footer class="footer">
      <p><span>Fix error</span>, click outside, or press Esc to close the overlay.</p>
      <p>Disable overlay by setting Rsbuild's <span><a class="config-link" target="_blank" rel="noopener noreferrer" href="https://rsbuild.rs/config/dev/client">dev.client.overlay</a></span> config to false.<p>
    </footer>
  </div>
</div>
`;
    }
    function isEqualSet(a, b) {
        return a.size === b.size && [
            ...a
        ].every((value)=>b.has(value));
    }
    let parseQueryString = (req)=>{
        let queryStr = req.url ? req.url.split('?')[1] : '';
        return queryStr ? Object.fromEntries(new URLSearchParams(queryStr)) : {};
    };
    class SocketServer {
        wsServer;
        socketsMap = new Map();
        options;
        context;
        initialChunksMap = new Map();
        heartbeatTimer = null;
        getOutputFileSystem;
        reportedBrowserLogs = new Set();
        currentHash = new Map();
        constructor(context, options, getOutputFileSystem){
            this.context = context, this.options = options, this.getOutputFileSystem = getOutputFileSystem;
        }
        upgrade = (req, socket, head)=>{
            if (!this.wsServer.shouldHandle(req)) return;
            let query = parseQueryString(req);
            this.context.environmentList.map(({ webSocketToken })=>webSocketToken).includes(query.token) ? this.wsServer.handleUpgrade(req, socket, head, (connection)=>{
                this.wsServer.emit('connection', connection, req);
            }) : socket.destroy();
        };
        checkSockets = ()=>{
            for (let socket of this.wsServer.clients)socket.isAlive ? (socket.isAlive = !1, socket.ping(()=>{})) : socket.terminate();
            null !== this.heartbeatTimer && (this.heartbeatTimer = setTimeout(this.checkSockets, 30000).unref());
        };
        clearHeartbeatTimer() {
            this.heartbeatTimer && (clearTimeout(this.heartbeatTimer), this.heartbeatTimer = null);
        }
        prepare() {
            this.clearHeartbeatTimer();
            let ws = requireCompiledPackage('ws');
            this.wsServer = new ws.Server({
                noServer: !0,
                path: this.options.client?.path
            }), this.wsServer.on('error', (err)=>{
                logger.error(err);
            }), this.heartbeatTimer = setTimeout(this.checkSockets, 30000).unref(), this.wsServer.on('connection', (socket, req)=>{
                let query = parseQueryString(req);
                this.onConnect(socket, query.token);
            });
        }
        onBuildDone() {
            if (this.reportedBrowserLogs.clear(), this.socketsMap.size) for (let token of this.socketsMap.keys())this.sendStats({
                token
            });
        }
        sendError(errors, token) {
            let formattedErrors = errors.map((item)=>formatStatsError(item));
            this.sockWrite({
                type: 'errors',
                data: {
                    text: formattedErrors,
                    html: genOverlayHTML(formattedErrors, this.context.rootPath)
                }
            }, token);
        }
        sockWrite(message, token) {
            let messageStr = JSON.stringify(message), sendToSockets = (sockets)=>{
                for (let socket of sockets)this.send(socket, messageStr);
            };
            if (token) {
                let sockets = this.socketsMap.get(token);
                sockets && sendToSockets(sockets);
            } else for (let sockets of this.socketsMap.values())sendToSockets(sockets);
        }
        async close() {
            for (let socket of (this.clearHeartbeatTimer(), this.wsServer.removeAllListeners(), this.wsServer.clients))socket.terminate();
            for (let sockets of this.socketsMap.values())sockets.forEach((socket)=>{
                socket.close();
            });
            return this.socketsMap.clear(), this.initialChunksMap.clear(), this.reportedBrowserLogs.clear(), new Promise((resolve, reject)=>{
                this.wsServer.close((err)=>{
                    err ? reject(err) : resolve();
                });
            });
        }
        onConnect(socket, token) {
            socket.isAlive = !0, socket.on('pong', ()=>{
                socket.isAlive = !0;
            }), socket.on('message', async (data)=>{
                try {
                    let message = JSON.parse('string' == typeof data ? data : data.toString()), { browserLogs } = this.context.normalizedConfig?.dev || {};
                    if ('client-error' === message.type && 'rspack' === this.context.bundlerType && !this.context.buildState.hasErrors && browserLogs) {
                        let stackTrace = isObject(browserLogs) && browserLogs.stackTrace || 'summary', log = await formatBrowserErrorLog(message, this.context, this.getOutputFileSystem(), stackTrace);
                        this.reportedBrowserLogs.has(log) || (this.reportedBrowserLogs.add(log), logger.error(log));
                    }
                } catch  {}
            });
            let sockets = this.socketsMap.get(token);
            sockets || (sockets = new Set(), this.socketsMap.set(token, sockets)), sockets.add(socket), socket.on('close', ()=>{
                let sockets = this.socketsMap.get(token);
                sockets && (sockets.delete(socket), 0 === sockets.size && this.socketsMap.delete(token));
            }), this.sendStats({
                force: !0,
                token
            });
        }
        getStats(token) {
            let { stats } = this.context.buildState, environment = this.context.environmentList.find(({ webSocketToken })=>webSocketToken === token);
            if (!stats || !environment) return;
            let currentStats = stats;
            if (stats.children) {
                let childStats = stats.children[environment.index];
                childStats && (currentStats = childStats);
            }
            return {
                stats: currentStats,
                errors: getStatsErrors(stats),
                warnings: getStatsWarnings(stats)
            };
        }
        sendStats({ force = !1, token }) {
            let result = this.getStats(token);
            if (!result) return null;
            let { stats, errors, warnings } = result, newInitialChunks = new Set();
            if (stats.entrypoints) for (let entrypoint of Object.values(stats.entrypoints)){
                let { chunks } = entrypoint;
                if (Array.isArray(chunks)) for (let chunkName of chunks)chunkName && newInitialChunks.add(String(chunkName));
            }
            let initialChunks = this.initialChunksMap.get(token), shouldReload = stats.entrypoints && initialChunks && !isEqualSet(initialChunks, newInitialChunks);
            if (this.initialChunksMap.set(token, newInitialChunks), shouldReload) return void this.sockWrite({
                type: 'static-changed'
            }, token);
            if (stats.hash) {
                let prevHash = this.currentHash.get(token);
                if (this.currentHash.set(token, stats.hash), !force && 0 === errors.length && 0 === warnings.length && prevHash === stats.hash) return void this.sockWrite({
                    type: 'ok'
                }, token);
                this.sockWrite({
                    type: 'hash',
                    data: stats.hash
                }, token);
            }
            if (errors.length > 0) return void this.sendError(errors, token);
            if (warnings.length > 0) {
                let warningMessages = warnings.map((item)=>formatStatsError(item));
                this.sockWrite({
                    type: 'warnings',
                    data: {
                        text: warningMessages
                    }
                }, token);
                return;
            }
            this.sockWrite({
                type: 'ok'
            }, token);
        }
        send(socket, message) {
            socket.readyState === socket.OPEN && socket.send(message);
        }
    }
    class BuildManager {
        assetsMiddleware;
        outputFileSystem;
        socketServer;
        compiler;
        config;
        resolvedPort;
        context;
        constructor({ config, context, compiler, resolvedPort }){
            this.config = config, this.context = context, this.compiler = compiler, this.resolvedPort = resolvedPort, this.outputFileSystem = external_node_fs_default(), this.socketServer = new SocketServer(context, config.dev, ()=>this.outputFileSystem), this.context.socketServer = this.socketServer;
        }
        async init() {
            await this.setupCompilationMiddleware(), this.socketServer.prepare();
            let { compiler } = this;
            this.outputFileSystem = (compiler_isMultiCompiler(compiler) ? compiler.compilers[0].outputFileSystem : compiler.outputFileSystem) || external_node_fs_default();
        }
        watch() {
            this.assetsMiddleware.watch();
        }
        async close() {
            await this.socketServer.close(), this.assetsMiddleware && await new Promise((resolve)=>{
                this.assetsMiddleware.close(()=>{
                    resolve();
                });
            }), await new Promise((resolve)=>{
                this.compiler.close(()=>{
                    resolve();
                });
            });
        }
        readFileSync = (fileName)=>'readFileSync' in this.outputFileSystem ? this.outputFileSystem.readFileSync(fileName, 'utf-8') : external_node_fs_default().readFileSync(fileName, 'utf-8');
        async setupCompilationMiddleware() {
            let { config, context } = this, middleware = await assets_middleware_assetsMiddleware({
                config,
                context,
                compiler: this.compiler,
                socketServer: this.socketServer,
                resolvedPort: this.resolvedPort
            });
            this.assetsMiddleware = middleware;
        }
    }
    let isCliShortcutsEnabled = (config)=>config.dev.cliShortcuts && isTTY('stdin');
    async function setupCliShortcuts({ help = !0, openPage, closeServer, printUrls, restartServer, customShortcuts }) {
        let shortcuts = [
            {
                key: 'c',
                description: `${color.bold('c + enter')}  ${color.dim('clear console')}`,
                action: ()=>{
                    console.clear();
                }
            },
            {
                key: 'o',
                description: `${color.bold('o + enter')}  ${color.dim('open in browser')}`,
                action: openPage
            },
            {
                key: 'q',
                description: `${color.bold('q + enter')}  ${color.dim('quit process')}`,
                action: async ()=>{
                    try {
                        await closeServer();
                    } finally{
                        process.exit(0);
                    }
                }
            },
            restartServer ? {
                key: 'r',
                description: `${color.bold('r + enter')}  ${color.dim('restart server')}`,
                action: restartServer
            } : null,
            {
                key: 'u',
                description: `${color.bold('u + enter')}  ${color.dim('show urls')}`,
                action: printUrls
            }
        ].filter(Boolean);
        if (customShortcuts && !Array.isArray(shortcuts = customShortcuts(shortcuts))) throw Error(`${color.dim('[rsbuild:config]')} ${color.yellow('dev.cliShortcuts')} option must return an array of shortcuts.`);
        help && logger.log(!0 === help ? `    ${color.dim('press')} ${color.bold('h + enter')} ${color.dim('to show shortcuts')}\n` : `    ${help}\n`);
        let { createInterface } = await import("node:readline"), rl = createInterface({
            input: process.stdin
        });
        return rl.on('line', (input)=>{
            if ('h' === input) {
                let message = `\n  ${color.bold(color.blue('Shortcuts:'))}\n`;
                for (let shortcut of shortcuts)message += `  ${shortcut.description}\n`;
                logger.log(message);
            }
            for (let shortcut of shortcuts)if (input === shortcut.key) return void shortcut.action();
        }), ()=>{
            rl.close();
        };
    }
    let ENCODING_REGEX = /\bgzip\b/, CONTENT_TYPE_REGEX = /text|javascript|\/json|xml/i, gzipMiddleware_gzipMiddleware = ({ filter, level = external_node_zlib_default().constants.Z_BEST_SPEED } = {})=>function gzipMiddleware(req, res, next) {
            let gzip, writeHeadStatus;
            if (filter && !filter(req, res)) return void next();
            let accept = req.headers['accept-encoding'], encoding = 'string' == typeof accept && ENCODING_REGEX.test(accept);
            if ('HEAD' === req.method || !encoding) return void next();
            let started = !1, on = res.on.bind(res), end = res.end.bind(res), write = res.write.bind(res), writeHead = res.writeHead.bind(res), listeners = [], start = ()=>{
                if (!started) {
                    if (started = !0, ((res)=>{
                        if (res.getHeader('Content-Encoding')) return !1;
                        let contentType = String(res.getHeader('Content-Type'));
                        if (contentType && !CONTENT_TYPE_REGEX.test(contentType)) return !1;
                        let size = res.getHeader('Content-Length');
                        return void 0 === size || Number(size) > 1024;
                    })(res)) for (let listener of (res.setHeader('Content-Encoding', 'gzip'), res.removeHeader('Content-Length'), (gzip = external_node_zlib_default().createGzip({
                        level
                    })).on('data', (chunk)=>{
                        write(chunk) || gzip.pause();
                    }), on('drain', ()=>gzip.resume()), gzip.on('end', ()=>{
                        end();
                    }), listeners))gzip.on.apply(gzip, listener);
                    else for (let listener of listeners)on.apply(res, listener);
                    writeHead(writeHeadStatus ?? res.statusCode);
                }
            };
            res.writeHead = (status, reason, headers)=>{
                if (reason) for (let [key, value] of Object.entries(headers || reason))res.setHeader(key, value);
                return writeHeadStatus = status, res;
            }, res.write = (...args)=>(start(), gzip ? gzip.write(...args) : write.apply(res, args)), res.end = (...args)=>(start(), gzip ? gzip.end(...args) : end.apply(res, args)), res.on = (type, listener)=>(started ? gzip && 'drain' === type ? gzip.on(type, listener) : on(type, listener) : listeners.push([
                    type,
                    listener
                ]), res), next();
        };
    function historyApiFallback_historyApiFallbackMiddleware(options = {}) {
        return function historyApiFallbackMiddleware(req, _res, next) {
            let rewriteTarget, { headers } = req;
            if (!req.url) return void next();
            if ('GET' !== req.method && 'HEAD' !== req.method) {
                logger.debug('Not rewriting', req.method, req.url, 'because the method is not GET or HEAD.'), next();
                return;
            }
            if (!headers || 'string' != typeof headers.accept) {
                logger.debug('Not rewriting', req.method, req.url, 'because the client did not send an HTTP accept header.'), next();
                return;
            }
            if (0 === headers.accept.indexOf('application/json')) {
                logger.debug('Not rewriting', req.method, req.url, 'because the client prefers JSON.'), next();
                return;
            }
            let rewrites = options.rewrites || [], htmlAcceptHeaders = options.htmlAcceptHeaders || [
                'text/html',
                '*/*'
            ], { accept } = headers;
            if (!htmlAcceptHeaders.some((item)=>accept.includes(item))) {
                logger.debug('Not rewriting', req.method, req.url, 'because the client does not accept HTML.'), next();
                return;
            }
            let parsedUrl = parseReqUrl(req);
            if (null === parsedUrl) return void next();
            for (let rewrite of rewrites){
                let match = parsedUrl.pathname?.match(rewrite.from);
                if (!match) continue;
                let rule = rewrite.to;
                '/' !== (rewriteTarget = 'string' == typeof rule ? rule : rule({
                    parsedUrl,
                    match,
                    request: req
                })).charAt(0) && logger.debug('We recommend using an absolute path for the rewrite target.', 'Received a non-absolute rewrite target', rewriteTarget, 'for URL', req.url), logger.debug('Rewriting', req.method, req.url, 'to', rewriteTarget), req.url = rewriteTarget, next();
                return;
            }
            let { pathname } = parsedUrl;
            if (pathname && pathname.lastIndexOf('.') > pathname.lastIndexOf('/') && !0 !== options.disableDotRule) {
                logger.debug('Not rewriting', req.method, req.url, 'because the path includes a dot (.) character.'), next();
                return;
            }
            let index = options.index || '/index.html';
            logger.debug('Rewriting', req.method, req.url, 'to', index), req.url = index, next();
        };
    }
    function parseReqUrl(req) {
        let proto = req.headers['x-forwarded-proto'] || 'http', host = req.headers['x-forwarded-host'] || req.headers.host || 'localhost';
        try {
            return new external_node_url_.URL(req.url || '/', `${proto}://${host}`);
        } catch  {
            return null;
        }
    }
    let faviconFallbackMiddleware = (req, res, next)=>{
        '/favicon.ico' === req.url ? (res.statusCode = 204, res.end()) : next();
    }, getRequestLoggerMiddleware = function requestLoggerMiddleware() {
        return (req, res, next)=>{
            let _startAt = process.hrtime();
            on_finished_default()(res, ()=>{
                var status;
                let method = req.method, url = req.originalUrl || req.url, status1 = Number(res.statusCode), statusColor = (status = status1) >= 500 ? color.red : status >= 400 ? color.yellow : status >= 300 ? color.cyan : status >= 200 ? color.green : (res)=>res, endAt = process.hrtime(), totalTime = (endAt[0] - _startAt[0]) * 1e3 + (endAt[1] - _startAt[1]) * 1e-6;
                logger.debug(`${statusColor(status1)} ${method} ${url} ${color.dim(`${totalTime.toFixed(3)} ms`)}`);
            }), next();
        };
    }, notFoundMiddleware = (_req, res, _next)=>{
        res.statusCode = 404, res.end();
    }, optionsFallbackMiddleware = (req, res, next)=>{
        if ('OPTIONS' === req.method) {
            res.statusCode = 204, res.setHeader('Content-Length', '0'), res.end();
            return;
        }
        next();
    }, middlewares_isFileExists = async (filePath, outputFileSystem)=>new Promise((resolve)=>{
            outputFileSystem.stat(filePath, (_error, stats)=>{
                resolve(stats?.isFile());
            });
        }), maybeHTMLRequest = (req)=>{
        if (!req.url || !req.headers || 'GET' !== req.method && 'HEAD' !== req.method) return !1;
        let { accept } = req.headers;
        return 'string' == typeof accept && (accept.includes('text/html') || accept.includes('*/*'));
    }, postfixRE = /[?#].*$/, getBaseUrlMiddleware = ({ base })=>function baseUrlMiddleware(req, res, next) {
            let url = req.url, pathname = url.replace(postfixRE, '');
            if (pathname.startsWith(base)) {
                req.url = stripBase(url, base), next();
                return;
            }
            let redirectPath = addTrailingSlash(url) !== base ? joinUrlSegments(base, url) : base;
            if ('/' === pathname || '/index.html' === pathname) {
                res.writeHead(302, {
                    Location: redirectPath
                }), res.end();
                return;
            }
            if (req.headers.accept?.includes('text/html')) {
                res.writeHead(404, {
                    'Content-Type': 'text/html'
                }), res.end(`The server is configured with a base URL of ${base} - did you mean to visit <a href="${redirectPath}">${redirectPath}</a> instead?`);
                return;
            }
            res.writeHead(404, {
                'Content-Type': 'text/plain'
            }), res.end(`The server is configured with a base URL of ${base} - did you mean to visit ${redirectPath} instead?`);
        };
    function formatProxyOptions(proxyOptions) {
        let ret = [];
        if (Array.isArray(proxyOptions)) ret.push(...proxyOptions);
        else if ('target' in proxyOptions) ret.push(proxyOptions);
        else for (let [context, options] of Object.entries(proxyOptions)){
            let opts = {
                context,
                changeOrigin: !0,
                logLevel: 'warn',
                logProvider: ()=>logger
            };
            'string' == typeof options ? opts.target = options : Object.assign(opts, options), ret.push(opts);
        }
        return ret;
    }
    let createProxyMiddleware = (proxyOptions)=>{
        let formattedOptions = formatProxyOptions(proxyOptions), proxyMiddlewares = [], middlewares = [], { createProxyMiddleware: baseMiddleware } = requireCompiledPackage('http-proxy-middleware');
        for (let opts of formattedOptions){
            let { onProxyRes } = opts;
            opts.onProxyRes = (proxyRes, _req, res)=>{
                onProxyRes && onProxyRes(proxyRes, _req, res), res.on('close', ()=>{
                    res.writableEnded || proxyRes.destroy();
                });
            };
            let proxyMiddleware = baseMiddleware(opts.context, opts), middleware = async (req, res, next)=>{
                let bypassUrl = 'function' == typeof opts.bypass ? await opts.bypass(req, res, opts) : null;
                !1 === bypassUrl ? (res.statusCode = 404, next()) : 'string' == typeof bypassUrl ? (req.url = bypassUrl, next()) : !0 === bypassUrl ? next() : proxyMiddleware(req, res, next);
            };
            middlewares.push(middleware), opts.ws && proxyMiddlewares.push(proxyMiddleware);
        }
        return {
            middlewares,
            upgrade: (req, socket, head)=>{
                for (let middleware of proxyMiddlewares)'function' == typeof middleware.upgrade && middleware.upgrade(req, socket, head);
            }
        };
    }, asModule = async (something, context, unlinked)=>{
        let { Module, SyntheticModule } = await import("node:vm");
        if (something instanceof Module) return something;
        let exports1 = [
            ...new Set([
                'default',
                ...Object.keys(something)
            ])
        ], syntheticModule = new SyntheticModule(exports1, ()=>{
            for (let name of exports1)syntheticModule.setExport(name, 'default' === name ? something : something[name]);
        }, {
            context
        });
        return unlinked || (await syntheticModule.link(()=>{}), await syntheticModule.evaluate()), syntheticModule;
    };
    class BasicRunner {
        _options;
        globalContext = null;
        baseModuleScope = null;
        requirers = new Map();
        constructor(_options){
            this._options = _options;
        }
        run(file) {
            this.globalContext || (this.globalContext = this.createGlobalContext()), this.baseModuleScope = this.createBaseModuleScope(), this.createRunner();
            let res = this.getRequire()(this._options.dist, file.startsWith('./') ? file : `./${file}`);
            return 'object' == typeof res && 'then' in res ? res : Promise.resolve(res);
        }
        getRequire() {
            let entryRequire = this.requirers.get('entry');
            return (currentDirectory, modulePath, context = {})=>entryRequire(currentDirectory, Array.isArray(modulePath) ? modulePath : modulePath.split('?')[0], context);
        }
        getFile(modulePath, currentDirectory) {
            let p;
            if (Array.isArray(modulePath)) return {
                path: external_node_path_default().join(currentDirectory, '.array-require.js'),
                content: `module.exports = (${modulePath.map((arg)=>`require(${JSON.stringify(`./${arg}`)})`).join(', ')});`,
                subPath: ''
            };
            let joinedPath = (p = modulePath, /^\.\.?\//.test(p)) ? external_node_path_default().join(currentDirectory, modulePath) : modulePath;
            return this._options.isBundleOutput(joinedPath) ? {
                path: joinedPath,
                content: this._options.readFileSync(joinedPath),
                subPath: ((p)=>{
                    let lastSlash = p.lastIndexOf('/'), firstSlash = p.indexOf('/');
                    if (-1 !== lastSlash && firstSlash !== lastSlash) {
                        if (-1 !== firstSlash) {
                            let next = p.indexOf('/', firstSlash + 1), dir = p.slice(firstSlash + 1, next);
                            for(; '.' === dir;)firstSlash = next, next = p.indexOf('/', firstSlash + 1), dir = p.slice(firstSlash + 1, next);
                        }
                        return p.slice(firstSlash + 1, lastSlash + 1);
                    }
                    return '';
                })(modulePath)
            } : null;
        }
        preExecute(_code, _file) {}
        postExecute(_m, _file) {}
        createRunner() {
            this.requirers.set('entry', (_currentDirectory, _modulePath, _context = {})=>{
                throw Error(`${color.dim('[rsbuild:runner]')} Not implemented`);
            });
        }
    }
    let cjs_require = (0, external_node_module_.createRequire)(__rslib_import_meta_url__), cjs_define = (...args)=>{
        args.pop()();
    };
    class CommonJsRunner extends BasicRunner {
        createGlobalContext() {
            return {
                console: console,
                setTimeout: (cb, ms, ...args)=>{
                    let timeout = setTimeout(cb, ms, ...args);
                    return timeout.unref(), timeout;
                },
                clearTimeout: clearTimeout,
                queueMicrotask
            };
        }
        createBaseModuleScope() {
            return {
                console: this.globalContext.console,
                setTimeout: this.globalContext.setTimeout,
                clearTimeout: this.globalContext.clearTimeout,
                nsObj: (m)=>(Object.defineProperty(m, Symbol.toStringTag, {
                        value: 'Module'
                    }), m),
                queueMicrotask
            };
        }
        createModuleScope(requireFn, m, file) {
            return {
                ...this.baseModuleScope,
                require: requireFn.bind(null, external_node_path_default().dirname(file.path)),
                module: m,
                exports: m.exports,
                __dirname: external_node_path_default().dirname(file.path),
                __filename: file.path,
                define: cjs_define
            };
        }
        createRunner() {
            this.requirers.set('miss', this.createMissRequirer()), this.requirers.set('entry', this.createCjsRequirer());
        }
        createMissRequirer() {
            return (_currentDirectory, modulePath, _context = {})=>{
                let resolvedPath = cjs_require.resolve(modulePath, {
                    paths: [
                        _currentDirectory
                    ]
                });
                return cjs_require(resolvedPath.startsWith('node:') ? resolvedPath.slice(5) : resolvedPath);
            };
        }
        createCjsRequirer() {
            let requireCache = Object.create(null), vm = cjs_require('node:vm');
            return (currentDirectory, modulePath, context = {})=>{
                let file = context.file || this.getFile(modulePath, currentDirectory);
                if (!file) return this.requirers.get('miss')(currentDirectory, modulePath);
                if (file.path in requireCache) return requireCache[file.path].exports;
                let m = {
                    exports: {}
                };
                requireCache[file.path] = m;
                let currentModuleScope = this.createModuleScope(this.getRequire(), m, file), args = Object.keys(currentModuleScope), argValues = args.map((arg)=>currentModuleScope[arg]), codeDefinition = `(function(${args.join(', ')}) {`, code = `${codeDefinition}${file.content}\n})`;
                this.preExecute(code, file);
                let dynamicImport = Function('specifier', 'return import(specifier)');
                return vm.runInThisContext(code, {
                    filename: file.path,
                    lineOffset: 0,
                    columnOffset: -codeDefinition.length,
                    importModuleDynamically: async (specifier)=>await dynamicImport(specifier)
                }).call(m.exports, ...argValues), this.postExecute(m, file), m.exports;
            };
        }
    }
    let esm_require = (0, external_node_module_.createRequire)(__rslib_import_meta_url__);
    class EsmRunner extends CommonJsRunner {
        createRunner() {
            super.createRunner(), this.requirers.set('cjs', this.getRequire()), this.requirers.set('esm', this.createEsmRequirer());
            let outputModule = this._options.compilerOptions.experiments?.outputModule;
            this.requirers.set('entry', (currentDirectory, modulePath, context)=>{
                let file = this.getFile(modulePath, currentDirectory);
                return file ? outputModule && !file.path.endsWith('.cjs') ? this.requirers.get('esm')(currentDirectory, modulePath, {
                    ...context,
                    file
                }) : this.requirers.get('cjs')(currentDirectory, modulePath, {
                    ...context,
                    file
                }) : this.requirers.get('miss')(currentDirectory, modulePath);
            });
        }
        createEsmRequirer() {
            let esmCache = new Map(), esmIdentifier = this._options.name, vm = esm_require('node:vm');
            return (currentDirectory, modulePath, context = {})=>{
                if (!vm.SourceTextModule) throw Error(`${color.dim('[rsbuild:runner]')} Running ESM bundle needs add Node.js option ${color.yellow('--experimental-vm-modules')}.`);
                let _require = this.getRequire(), file = context.file || this.getFile(modulePath, currentDirectory);
                if (!file) return this.requirers.get('miss')(currentDirectory, modulePath);
                let esm = esmCache.get(file.path);
                return (esm || (esm = new vm.SourceTextModule(file.content, {
                    identifier: `${esmIdentifier}-${file.path}`,
                    url: `${(0, external_node_url_.pathToFileURL)(file.path).href}?${esmIdentifier}`,
                    initializeImportMeta: (meta, _)=>{
                        meta.url = (0, external_node_url_.pathToFileURL)(file.path).href;
                    },
                    importModuleDynamically: async (specifier, module)=>asModule(await _require(external_node_path_default().dirname(file.path), specifier, {
                            esmMode: 1
                        }), module.context)
                }), esmCache.set(file.path, esm)), 2 === context.esmMode) ? esm : (async ()=>{
                    if (await esm.link(async (specifier, referencingModule)=>asModule(await _require(external_node_path_default().dirname(referencingModule.identifier ? referencingModule.identifier.slice(esmIdentifier.length + 1) : (0, external_node_url_.fileURLToPath)(referencingModule.url)), specifier, {
                            esmMode: 2
                        }), referencingModule.context, !0)), await esm.evaluate(), 1 === context.esmMode) return esm;
                    let ns = esm.namespace;
                    return ns.default && ns.default instanceof Promise ? ns.default : ns;
                })();
            };
        }
    }
    class BasicRunnerFactory {
        name;
        constructor(name){
            this.name = name;
        }
        create(options) {
            return this.createRunner(options);
        }
        createRunner(options) {
            let runnerOptions = {
                name: this.name,
                ...options
            }, { compilerOptions } = options;
            if ('web' === compilerOptions.target || 'webworker' === compilerOptions.target) throw Error(`${color.dim('[rsbuild:runner]')} Not support run ${color.yellow(compilerOptions.target)} resource in Rsbuild server`);
            return new EsmRunner(runnerOptions);
        }
    }
    let runner_run = async ({ bundlePath, ...runnerFactoryOptions })=>{
        let runner = new BasicRunnerFactory(bundlePath).create(runnerFactoryOptions);
        return await runner.run(bundlePath);
    }, loadBundle = async (stats, entryName, utils)=>{
        let { chunks, entrypoints, outputPath } = stats.toJson({
            all: !1,
            chunks: !0,
            entrypoints: !0,
            outputPath: !0
        });
        if (!entrypoints?.[entryName]) throw Error(`${color.dim('[rsbuild:loadBundle]')} Can't find entry: ${color.yellow(entryName)}`);
        let { chunks: entryChunks = [] } = entrypoints[entryName], files = entryChunks.reduce((prev, entryChunkName)=>{
            let chunk = chunks?.find((chunk)=>chunk.entry && chunk.names?.includes(String(entryChunkName)));
            return chunk?.files ? prev.concat(chunk.files.filter((file)=>!file.endsWith('.css'))) : prev;
        }, []);
        if (0 === files.length) throw Error(`${color.dim('[rsbuild:loadBundle]')} Failed to get bundle by entryName: ${color.yellow(entryName)}`);
        if (files.length > 1) throw Error(`${color.dim('[rsbuild:loadBundle]')} Only support load single entry chunk, but got ${color.yellow(files.length)}: ${files.join(',')}`);
        let allChunkFiles = chunks?.flatMap((c)=>c.files).map((file)=>(0, external_node_path_.join)(outputPath, file)) || [];
        return await runner_run({
            bundlePath: files[0],
            dist: outputPath,
            compilerOptions: stats.compilation.options,
            readFileSync: utils.readFileSync,
            isBundleOutput: (modulePath)=>allChunkFiles.includes(modulePath)
        });
    }, createCacheableFunction = (getter)=>{
        let cache = new WeakMap();
        return async (stats, entryName, utils)=>{
            let cachedEntries = cache.get(stats);
            if (cachedEntries?.[entryName]) return cachedEntries[entryName];
            let res = await getter(stats, entryName, utils);
            return cache.set(stats, {
                ...cachedEntries || {},
                [entryName]: res
            }), res;
        };
    }, cleanupCallbacks = new Set(), handleTermination = async (exitCode)=>{
        try {
            await Promise.all([
                ...cleanupCallbacks
            ].map((cb)=>cb()));
        } finally{
            process.exitCode ??= exitCode, process.exit();
        }
    }, registerCleanup = (callback)=>{
        cleanupCallbacks.add(callback);
    }, removeCleanup = (callback)=>{
        cleanupCallbacks.delete(callback);
    }, shutdownRefCount = 0, setupGracefulShutdown = ()=>{
        shutdownRefCount++;
        let onSigterm = ()=>{
            handleTermination(external_node_os_.constants.signals.SIGTERM + 128);
        };
        process.once('SIGTERM', onSigterm);
        let isCI = 'true' === process.env.CI, onStdinEnd = ()=>{
            handleTermination(0);
        };
        return isCI || process.stdin.on('end', onStdinEnd), ()=>{
            !(--shutdownRefCount > 0) && (process.removeListener('SIGTERM', onSigterm), isCI || process.stdin.removeListener('end', onStdinEnd));
        };
    }, createHttpServer = async ({ serverConfig, middlewares })=>{
        if (serverConfig.https) {
            if (serverConfig.proxy) {
                let { createServer } = await import("node:https");
                return createServer(serverConfig.https, middlewares);
            }
            let { createSecureServer } = await import("node:http2");
            return createSecureServer({
                allowHTTP1: !0,
                maxSessionMemory: 1024,
                ...serverConfig.https
            }, middlewares);
        }
        let { createServer } = await import("node:http");
        return createServer(middlewares);
    };
    async function setupWatchFiles(options) {
        let { config, root, buildManager } = options, { hmr, liveReload } = config.dev;
        if (!hmr && !liveReload || !buildManager) return;
        let closeDevFilesWatcher = await watchDevFiles(config.dev, buildManager, root), serverFilesWatcher = await watchServerFiles(config.server, buildManager, root);
        return {
            async close () {
                await Promise.all([
                    closeDevFilesWatcher?.(),
                    serverFilesWatcher?.close()
                ]);
            }
        };
    }
    async function watchDevFiles(devConfig, buildManager, root) {
        let { watchFiles } = devConfig;
        if (!watchFiles) return;
        let watchers = [];
        for (let { paths, options, type } of helpers_castArray(watchFiles)){
            let watchOptions = prepareWatchOptions(paths, options, type), watcher = await startWatchFiles(watchOptions, buildManager, root);
            watcher && watchers.push(watcher);
        }
        return async ()=>{
            for (let watcher of watchers)await watcher.close();
        };
    }
    function watchServerFiles({ publicDir }, buildManager, root) {
        if (!publicDir.length) return;
        let watchPaths = publicDir.filter((item)=>item.watch).map((item)=>item.name);
        if (watchPaths.length) return startWatchFiles(prepareWatchOptions(watchPaths), buildManager, root);
    }
    function prepareWatchOptions(paths, options = {}, type) {
        return {
            paths: 'string' == typeof paths ? [
                paths
            ] : paths,
            options,
            type
        };
    }
    let GLOB_REGEX = /[*?{}[\]()!@+|]/;
    async function createChokidar(pathOrGlobs, root, options) {
        let chokidar = requireCompiledPackage('chokidar'), watchFiles = new Set(), globPatterns = pathOrGlobs.filter((pathOrGlob)=>{
            let str;
            return str = pathOrGlob, !!GLOB_REGEX.test(str) || (watchFiles.add(pathOrGlob), !1);
        });
        if (globPatterns.length) {
            let { glob } = requireCompiledPackage('tinyglobby');
            for (let file of (await glob(globPatterns, {
                cwd: root,
                absolute: !0
            })))watchFiles.add(file);
        }
        return chokidar.watch(Array.from(watchFiles), options);
    }
    async function startWatchFiles({ paths, options, type = 'reload-page' }, buildManager, root) {
        if ('reload-page' !== type) return;
        let watcher = await createChokidar(paths, root, options);
        return watcher.on('change', ()=>{
            buildManager.socketServer.sockWrite({
                type: 'static-changed'
            });
        }), watcher;
    }
    async function devServer_createDevServer(options, createCompiler, config, { compiler: customCompiler, getPortSilently, runCompile = !0 } = {}) {
        let lastStats, fileWatcher, devMiddlewares;
        logger.debug('create dev server');
        let { port, host, https, portTip } = await getServerConfig({
            config
        }), { middlewareMode } = config.server, { context } = options, routes = getRoutes(context), root = context.rootPath;
        context.devServer = {
            hostname: host,
            port,
            https
        };
        let waitLastCompileDoneResolve = null, waitLastCompileDone = new Promise((resolve)=>{
            waitLastCompileDoneResolve = resolve;
        });
        context.hooks.onAfterDevCompile.tap(({ stats })=>{
            lastStats = 'stats' in stats ? stats.stats : [
                stats
            ], waitLastCompileDoneResolve && (waitLastCompileDoneResolve(), waitLastCompileDoneResolve = null);
        });
        let startCompile = async ()=>{
            let compiler = customCompiler || await createCompiler();
            if (!compiler) throw Error(`${color.dim('[rsbuild:server]')} Failed to get compiler instance.`);
            let publicPaths = compiler_isMultiCompiler(compiler) ? compiler.compilers.map(getPublicPathFromCompiler) : [
                getPublicPathFromCompiler(compiler)
            ], { base } = config.server;
            context.publicPathnames = publicPaths.map(getPathnameFromUrl).map((prefix)=>base && '/' !== base ? stripBase(prefix, base) : prefix), compiler?.hooks.watchRun.tap('rsbuild:watchRun', ()=>{
                lastStats && (waitLastCompileDoneResolve && (waitLastCompileDoneResolve(), waitLastCompileDoneResolve = null), waitLastCompileDone = new Promise((resolve)=>{
                    waitLastCompileDoneResolve = resolve;
                }));
            });
            let buildManager = new BuildManager({
                context,
                config,
                compiler,
                resolvedPort: port
            });
            return await buildManager.init(), buildManager;
        }, protocol = https ? 'https' : 'http', urls = await getAddressUrls({
            protocol,
            port,
            host
        }), cliShortcutsEnabled = isCliShortcutsEnabled(config), printUrls = ()=>printServerURLs({
                urls,
                port,
                routes,
                protocol,
                printUrls: config.server.printUrls,
                trailingLineBreak: !cliShortcutsEnabled
            }), openPage = async ()=>open_open({
                https,
                port,
                routes,
                config,
                clearCache: !0
            }), cleanupGracefulShutdown = middlewareMode ? null : setupGracefulShutdown(), closingPromise = null, closeServer = async ()=>(closingPromise || (closingPromise = (async ()=>{
                removeCleanup(closeServer), cleanupGracefulShutdown?.(), await context.hooks.onCloseDevServer.callBatch(), await Promise.all([
                    devMiddlewares?.close(),
                    fileWatcher?.close()
                ]);
            })()), closingPromise);
        middlewareMode || registerCleanup(closeServer);
        let beforeCreateCompiler = async ()=>{
            if (printUrls(), cliShortcutsEnabled) {
                let shortcutsOptions = 'boolean' == typeof config.dev.cliShortcuts ? {} : config.dev.cliShortcuts, cleanup = await setupCliShortcuts({
                    openPage,
                    closeServer,
                    printUrls,
                    restartServer: ()=>restartDevServer({
                            clear: !1
                        }),
                    help: shortcutsOptions.help,
                    customShortcuts: shortcutsOptions.custom
                });
                context.hooks.onCloseDevServer.tap(cleanup);
            }
            !getPortSilently && portTip && logger.info(portTip);
        }, cacheableLoadBundle = createCacheableFunction(loadBundle), cacheableTransformedHtml = createCacheableFunction((_stats, entryName, utils)=>((entryName, utils)=>{
                let { htmlPaths, distPath } = utils.environment, htmlPath = htmlPaths[entryName];
                if (!htmlPath) throw Error(`${color.dim('[rsbuild:getTransformedHtml]')} Failed to get HTML file by entryName: ${color.yellow(entryName)}`);
                let fileName = (0, external_node_path_.join)(distPath, htmlPath);
                return utils.readFileSync(fileName);
            })(entryName, utils)), environmentAPI = {}, getErrorMsg = (method)=>`${color.dim('[rsbuild:server]')} Can not call ${color.yellow(method)} when ${color.yellow('runCompile')} is false`;
        context.environmentList.forEach((environment, index)=>{
            environmentAPI[environment.name] = {
                context: environment,
                getStats: async ()=>{
                    if (!buildManager) throw Error(getErrorMsg('getStats'));
                    return await waitLastCompileDone, lastStats[index];
                },
                loadBundle: async (entryName)=>{
                    if (!buildManager) throw Error(getErrorMsg('loadBundle'));
                    return await waitLastCompileDone, cacheableLoadBundle(lastStats[index], entryName, {
                        readFileSync: buildManager.readFileSync,
                        environment
                    });
                },
                getTransformedHtml: async (entryName)=>{
                    if (!buildManager) throw Error(getErrorMsg('getTransformedHtml'));
                    return await waitLastCompileDone, cacheableTransformedHtml(lastStats[index], entryName, {
                        readFileSync: buildManager.readFileSync,
                        environment
                    });
                }
            };
        });
        let middlewares = requireCompiledPackage('connect')(), httpServer = middlewareMode ? null : await createHttpServer({
            serverConfig: config.server,
            middlewares
        }), devServerAPI = {
            port,
            middlewares,
            environments: environmentAPI,
            httpServer,
            sockWrite: (type, data)=>buildManager?.socketServer.sockWrite({
                    type,
                    data
                }),
            listen: async ()=>{
                if (!httpServer) throw Error(`${color.dim('[rsbuild:server]')} Can not listen dev server as ${color.yellow('server.middlewareMode')} is enabled.`);
                let serverTerminator = getServerTerminator(httpServer);
                return logger.debug('listen dev server'), context.hooks.onCloseDevServer.tap(serverTerminator), new Promise((resolve)=>{
                    httpServer.listen({
                        host,
                        port
                    }, async (err)=>{
                        if (err) throw err;
                        middlewares.use(optionsFallbackMiddleware), middlewares.use(notFoundMiddleware), devMiddlewares && httpServer.on('upgrade', devMiddlewares.onUpgrade), logger.debug('listen dev server done'), await devServerAPI.afterListen(), onBeforeRestartServer(devServerAPI.close), resolve({
                            port,
                            urls: urls.map((item)=>item.url),
                            server: {
                                close: devServerAPI.close
                            }
                        });
                    });
                });
            },
            afterListen: async ()=>{
                await context.hooks.onAfterStartDevServer.callBatch({
                    port,
                    routes,
                    environments: context.environments
                });
            },
            connectWebSocket: ({ server })=>{
                devMiddlewares && server.on('upgrade', devMiddlewares.onUpgrade);
            },
            close: closeServer,
            printUrls,
            open: openPage
        }, postCallbacks = (await context.hooks.onBeforeStartDevServer.callBatch({
            server: devServerAPI,
            environments: context.environments
        })).filter((item)=>'function' == typeof item);
        runCompile ? context.hooks.onBeforeCreateCompiler.tap(beforeCreateCompiler) : await beforeCreateCompiler();
        let buildManager = runCompile ? await startCompile() : void 0;
        for (let item of (fileWatcher = await setupWatchFiles({
            config,
            buildManager,
            root
        }), (devMiddlewares = ((options)=>{
            let middlewares = [], { buildManager } = options;
            'verbose' === logger.level && middlewares.push(getRequestLoggerMiddleware());
            let { before, after } = ((config, devServerAPI)=>{
                let setupMiddlewares = config.dev.setupMiddlewares || [], serverOptions = pick(devServerAPI, [
                    'sockWrite',
                    'environments'
                ]), before = [], after = [];
                for (let handler of helpers_castArray(setupMiddlewares))handler({
                    unshift: (...handlers)=>before.unshift(...handlers),
                    push: (...handlers)=>after.push(...handlers)
                }, serverOptions);
                return {
                    before,
                    after
                };
            })(options.config, options.devServerAPI);
            middlewares.push(...before);
            let { onUpgrade } = (({ config, buildManager, context, devServerAPI, middlewares, postCallbacks })=>{
                let upgradeEvents = [], { server } = config;
                if (server.cors) {
                    let corsMiddleware = requireCompiledPackage('cors');
                    middlewares.push(corsMiddleware('boolean' == typeof server.cors ? {} : server.cors));
                }
                let { headers } = server;
                if (headers && middlewares.push((_req, res, next)=>{
                    for (let [key, value] of Object.entries(headers))res.setHeader(key, value);
                    next();
                }), server.proxy) {
                    let { middlewares: proxyMiddlewares, upgrade } = createProxyMiddleware(server.proxy);
                    for (let middleware of (upgradeEvents.push(upgrade), proxyMiddlewares))middlewares.push(middleware);
                }
                let { compress } = server;
                if (compress && middlewares.push(gzipMiddleware_gzipMiddleware('object' == typeof compress ? compress : void 0)), 'dev' === context.action && 'rspack' === context.bundlerType && buildManager) {
                    let { compiler } = buildManager;
                    (compiler_isMultiCompiler(compiler) ? compiler.compilers.some((childCompiler)=>childCompiler.options.experiments?.lazyCompilation || childCompiler.options.lazyCompilation) : compiler.options.experiments?.lazyCompilation || compiler.options.lazyCompilation) && middlewares.push(rspack_rspack.experiments.lazyCompilationMiddleware(compiler));
                }
                server.base && '/' !== server.base && middlewares.push(getBaseUrlMiddleware({
                    base: server.base
                }));
                let launchEditorMiddleware = requireCompiledPackage('launch-editor-middleware');
                for (let { name } of (middlewares.push([
                    '/__open-in-editor',
                    launchEditorMiddleware()
                ]), middlewares.push((({ environments })=>async function viewingServedFilesMiddleware(req, res, next) {
                        if ('/rsbuild-dev-server' !== req.url.replace(postfixRE, '')) return void next();
                        res.writeHead(200, {
                            'Content-Type': 'text/html; charset=utf-8'
                        }), res.write(`<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
      body {
        margin: 0;
        color: #f6f7f9;
        padding: 32px 40px;
        line-height: 1.8;
        min-height: 100vh;
        background-image: linear-gradient(#020917, #101725);
        font-family: ui-sans-serif,system-ui,sans-serif;
      }
      h1, h2 {
        font-weight: 500;
      }
      h1 {
        margin: 0;
        font-size: 36px;
      }
      h2 {
        font-size: 20px;
        margin: 24px 0 16px;
      }
      ul {
        margin: 0;
        padding-left: 16px;
      }
      a {
        color: #58c4dc;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
    </style>
  </head>
  <body>
    <h1>Assets Report</h1>
  </body>
</html>`);
                        try {
                            for(let key in environments){
                                res.write(`<h2>Environment: ${key}</h2>`);
                                let list = [], environment = environments[key], stats = await environment.getStats(), assets = getAssetsFromStats(stats);
                                for (let asset of (res.write('<ul>'), assets))list.push(`<li><a target="_blank" href="${asset.name}">${asset.name}</a></li>`);
                                res.write(list?.join('')), res.write('</ul>');
                            }
                            res.end('</body></html>');
                        } catch (err) {
                            logger.error(err), res.writeHead(500), res.end('Failed to list the files');
                        }
                    })({
                    environments: devServerAPI.environments
                })), buildManager && (middlewares.push(buildManager.assetsMiddleware), upgradeEvents.push(buildManager.socketServer.upgrade), middlewares.push(function hotUpdateJsonFallbackMiddleware(req, res, next) {
                    req.url?.endsWith('.hot-update.json') && 'OPTIONS' !== req.method ? (res.statusCode = 404, res.end()) : next();
                })), buildManager && middlewares.push((({ distPath, buildManager })=>async function htmlCompletionMiddleware(req, res, next) {
                        if (!maybeHTMLRequest(req)) return void next();
                        let pathname = req.url.replace(postfixRE, ''), rewrite = (newUrl)=>{
                            req.url = newUrl, buildManager.assetsMiddleware(req, res, (...args)=>{
                                next(...args);
                            });
                        };
                        if (pathname.endsWith('/')) {
                            let newUrl = `${pathname}index.html`, filePath = external_node_path_default().join(distPath, newUrl);
                            if (await middlewares_isFileExists(filePath, buildManager.outputFileSystem)) return void rewrite(newUrl);
                        } else if (!external_node_path_default().extname(pathname)) {
                            let newUrl = `${pathname}.html`, filePath = external_node_path_default().join(distPath, newUrl);
                            if (await middlewares_isFileExists(filePath, buildManager.outputFileSystem)) return void rewrite(newUrl);
                        }
                        next();
                    })({
                    buildManager,
                    distPath: context.distPath
                })), server.publicDir)){
                    let sirvMiddleware = requireCompiledPackage('sirv')(name, {
                        etag: !0,
                        dev: !0
                    });
                    middlewares.push(function publicDirMiddleware(req, res, next) {
                        sirvMiddleware(req, res, next);
                    });
                }
                for (let callback of postCallbacks)callback();
                return server.historyApiFallback && (middlewares.push(historyApiFallback_historyApiFallbackMiddleware(!0 === server.historyApiFallback ? {} : server.historyApiFallback)), buildManager?.assetsMiddleware && middlewares.push(buildManager.assetsMiddleware)), buildManager && middlewares.push((({ htmlFallback, distPath, buildManager })=>async function htmlFallbackMiddleware(req, res, next) {
                        if (!maybeHTMLRequest(req) || '/favicon.ico' === req.url || 'index' !== htmlFallback) return void next();
                        let filePath = external_node_path_default().join(distPath, 'index.html');
                        if (await middlewares_isFileExists(filePath, buildManager.outputFileSystem)) {
                            let newUrl = '/index.html';
                            'verbose' === logger.level && logger.debug(`    ${req.method} ${req.url} ${color.yellow('fallback to')} ${newUrl}`), req.url = newUrl, buildManager.assetsMiddleware(req, res, (...args)=>{
                                next(...args);
                            });
                            return;
                        }
                        next();
                    })({
                    buildManager,
                    distPath: context.distPath,
                    htmlFallback: server.htmlFallback
                })), middlewares.push(faviconFallbackMiddleware), {
                    onUpgrade: (...args)=>{
                        for (let cb of upgradeEvents)cb(...args);
                    }
                };
            })({
                ...options,
                middlewares
            });
            return middlewares.push(...after), {
                close: async ()=>{
                    await buildManager?.close();
                },
                onUpgrade,
                middlewares
            };
        })({
            buildManager,
            config,
            devServerAPI,
            context,
            postCallbacks
        })).middlewares))Array.isArray(item) ? middlewares.use(...item) : middlewares.use(item);
        return buildManager?.watch(), logger.debug('create dev server done'), devServerAPI;
    }
    let rspackProvider = ({ context, pluginManager, rsbuildOptions })=>{
        let createCompiler = async ()=>(await createCompiler_createCompiler({
                context,
                pluginManager,
                rsbuildOptions
            })).compiler;
        return {
            bundler: 'rspack',
            createCompiler,
            async createDevServer (options) {
                let config = await initRsbuildConfig({
                    context,
                    pluginManager
                });
                return devServer_createDevServer({
                    context,
                    pluginManager,
                    rsbuildOptions
                }, createCompiler, config, options);
            },
            async startDevServer (options) {
                let config = await initRsbuildConfig({
                    context,
                    pluginManager
                });
                return (await devServer_createDevServer({
                    context,
                    pluginManager,
                    rsbuildOptions
                }, createCompiler, config, options)).listen();
            },
            build: async (options)=>build_build({
                    context,
                    pluginManager,
                    rsbuildOptions
                }, options),
            async initConfigs (options) {
                if (context.action && options?.action && context.action !== options.action) throw Error(`\
[rsbuild] initConfigs() can only be called with the same action type.
  - Expected: ${context.action}
  - Actual: ${options?.action}`);
                options?.action && (context.action = options.action);
                let { rspackConfigs } = await initConfigs({
                    context,
                    pluginManager,
                    rsbuildOptions
                });
                return rspackConfigs;
            },
            async inspectConfig (inspectOptions) {
                let bundlerConfigs = (await initConfigs({
                    context,
                    pluginManager,
                    rsbuildOptions
                })).rspackConfigs;
                return inspectConfig_inspectConfig({
                    context,
                    pluginManager,
                    rsbuildOptions,
                    inspectOptions,
                    bundlerConfigs
                });
            }
        };
    };
    class RsbuildProdServer {
        app;
        options;
        middlewares;
        constructor(options, middlewares){
            this.options = options, this.middlewares = middlewares;
        }
        async onInit(app) {
            this.app = app, await this.applyDefaultMiddlewares();
        }
        async applyDefaultMiddlewares() {
            let { headers, proxy, historyApiFallback, compress, base, cors } = this.options.serverConfig;
            if ('verbose' === logger.level && this.middlewares.use(getRequestLoggerMiddleware()), cors) {
                let corsMiddleware = requireCompiledPackage('cors');
                this.middlewares.use(corsMiddleware('boolean' == typeof cors ? {} : cors));
            }
            if (headers && this.middlewares.use((_req, res, next)=>{
                for (let [key, value] of Object.entries(headers))res.setHeader(key, value);
                next();
            }), proxy) {
                let { middlewares, upgrade } = createProxyMiddleware(proxy);
                for (let middleware of middlewares)this.middlewares.use(middleware);
                this.app.on('upgrade', upgrade);
            }
            if (compress) {
                let { constants } = await import("node:zlib");
                this.middlewares.use(gzipMiddleware_gzipMiddleware({
                    level: constants.Z_DEFAULT_COMPRESSION,
                    ...'object' == typeof compress ? compress : void 0
                }));
            }
            base && '/' !== base && this.middlewares.use(getBaseUrlMiddleware({
                base
            })), this.applyStaticAssetMiddleware(), historyApiFallback && (this.middlewares.use(historyApiFallback_historyApiFallbackMiddleware(!0 === historyApiFallback ? {} : historyApiFallback)), this.applyStaticAssetMiddleware()), this.middlewares.use(faviconFallbackMiddleware), this.middlewares.use(optionsFallbackMiddleware), this.middlewares.use(notFoundMiddleware);
        }
        applyStaticAssetMiddleware() {
            let { output: { path, assetPrefixes }, serverConfig: { htmlFallback } } = this.options, assetsMiddleware = requireCompiledPackage('sirv')(path, {
                etag: !0,
                dev: !0,
                ignores: [
                    'favicon.ico'
                ],
                single: 'index' === htmlFallback
            });
            this.middlewares.use(function staticAssetMiddleware(req, res, next) {
                let url = req.url, assetPrefix = url && assetPrefixes.find((prefix)=>url.startsWith(prefix));
                assetPrefix && url?.startsWith(assetPrefix) ? (req.url = url.slice(assetPrefix.length), assetsMiddleware(req, res, (...args)=>{
                    req.url = url, next(...args);
                })) : assetsMiddleware(req, res, next);
            });
        }
        async close() {}
    }
    async function startProdServer(context, config, { getPortSilently } = {}) {
        let { port, host, https, portTip } = await getServerConfig({
            config
        }), middlewares = requireCompiledPackage('connect')(), serverConfig = config.server, server = new RsbuildProdServer({
            pwd: context.rootPath,
            output: {
                path: context.distPath,
                assetPrefixes: context.environmentList.map((e)=>getPathnameFromUrl(e.config.output.assetPrefix))
            },
            serverConfig
        }, middlewares);
        await context.hooks.onBeforeStartProdServer.callBatch();
        let httpServer = await createHttpServer({
            serverConfig,
            middlewares: server.middlewares
        }), serverTerminator = getServerTerminator(httpServer);
        return await server.onInit(httpServer), new Promise((resolve)=>{
            httpServer.listen({
                host,
                port
            }, async ()=>{
                let routes = getRoutes(context);
                await context.hooks.onAfterStartProdServer.callBatch({
                    port,
                    routes,
                    environments: context.environments
                });
                let protocol = https ? 'https' : 'http', urls = await getAddressUrls({
                    protocol,
                    port,
                    host
                }), cliShortcutsEnabled = isCliShortcutsEnabled(config), cleanupGracefulShutdown = setupGracefulShutdown(), closingPromise = null, closeServer = async ()=>(closingPromise || (closingPromise = (async ()=>{
                        removeCleanup(closeServer), cleanupGracefulShutdown(), await Promise.all([
                            server.close(),
                            serverTerminator()
                        ]);
                    })()), closingPromise);
                registerCleanup(closeServer);
                let printUrls = ()=>printServerURLs({
                        urls,
                        port,
                        routes,
                        protocol,
                        printUrls: serverConfig.printUrls,
                        trailingLineBreak: !cliShortcutsEnabled
                    }), openPage = async ()=>open_open({
                        https,
                        port,
                        routes,
                        config,
                        clearCache: !0
                    });
                if (printUrls(), cliShortcutsEnabled) {
                    let shortcutsOptions = 'boolean' == typeof config.dev.cliShortcuts ? {} : config.dev.cliShortcuts;
                    await setupCliShortcuts({
                        openPage,
                        closeServer,
                        printUrls,
                        help: shortcutsOptions.help,
                        customShortcuts: shortcutsOptions.custom
                    });
                }
                !getPortSilently && portTip && logger.info(portTip), resolve({
                    port,
                    urls: urls.map((item)=>item.url),
                    server: {
                        close: closeServer
                    }
                });
            });
        });
    }
    function applyDefaultPlugins(pluginManager, context) {
        let context1, context2;
        pluginManager.addPlugins([
            {
                name: 'rsbuild:basic',
                setup (api) {
                    api.modifyBundlerChain((chain, { isDev, isProd, target, bundler, environment, CHAIN_ID })=>{
                        let { config } = environment;
                        chain.name(environment.name), chain.context(api.context.rootPath), chain.mode(environment.config.mode), chain.infrastructureLogging({
                            level: 'error'
                        }), chain.watchOptions({
                            aggregateTimeout: 0
                        }), chain.performance.hints(!1), chain.module.parser.merge({
                            javascript: {
                                exportsPresence: 'error'
                            }
                        }), isDev && config.dev.hmr && 'web' === target && chain.plugin(CHAIN_ID.PLUGIN.HMR).use(bundler.HotModuleReplacementPlugin), 'rspack' === api.context.bundlerType && (chain.module.parser.merge({
                            javascript: {
                                inlineConst: isProd,
                                typeReexportsPresence: 'tolerant'
                            }
                        }), chain.experiments({
                            ...chain.get('experiments'),
                            inlineEnum: isProd,
                            inlineConst: isProd,
                            typeReexportsPresence: !0,
                            rspackFuture: {
                                bundlerInfo: {
                                    force: !1
                                }
                            }
                        }));
                    });
                }
            },
            {
                name: 'rsbuild:entry',
                setup (api) {
                    api.modifyBundlerChain((chain, { environment, isServer })=>{
                        let { config, entry } = environment, { preEntry } = config.source, injectCoreJsEntry = 'entry' === config.output.polyfill && !isServer;
                        for (let entryName of Object.keys(entry)){
                            let entryPoint = chain.entry(entryName), addEntry = (item)=>{
                                if ('object' == typeof item && 'html' in item) {
                                    let { html: _html, ...rest } = item;
                                    entryPoint.add(rest);
                                } else entryPoint.add(item);
                            };
                            preEntry.forEach(addEntry), injectCoreJsEntry && addEntry(createVirtualModule('import "core-js";')), helpers_castArray(entry[entryName]).forEach(addEntry);
                        }
                    }), api.onBeforeCreateCompiler({
                        order: 'post',
                        handler: ({ bundlerConfigs })=>{
                            if (bundlerConfigs.some((config)=>config.entry)) return;
                            let isModuleFederationPlugin = (plugin)=>isObject(plugin) && 'ModuleFederationPlugin' === plugin.constructor.name;
                            if (bundlerConfigs.some(({ plugins })=>plugins?.some(isModuleFederationPlugin))) return void bundlerConfigs.forEach((config)=>{
                                config.entry = {};
                            });
                            throw Error(`${color.dim('[rsbuild:config]')} Could not find any entry module, please make sure that ${color.yellow('src/index.(ts|js|tsx|jsx|mts|cts|mjs|cjs)')} exists, or customize entry through the ${color.yellow('source.entry')} configuration.`);
                        }
                    });
                }
            },
            {
                name: 'rsbuild:source-map',
                setup (api) {
                    let DEFAULT_SOURCE_MAP_TEMPLATE = '[absolute-resource-path]', enableCssSourceMap = (config)=>{
                        let { sourceMap } = config.output;
                        return 'object' == typeof sourceMap && sourceMap.css;
                    };
                    api.modifyBundlerChain((chain, { bundler, environment, isDev, target })=>{
                        let { config } = environment, devtool = ((config)=>{
                            let { sourceMap } = config.output, isProd = 'production' === config.mode;
                            return !1 !== sourceMap && (!0 === sourceMap ? isProd ? 'source-map' : 'cheap-module-source-map' : void 0 === sourceMap.js ? !isProd && 'cheap-module-source-map' : sourceMap.js);
                        })(config);
                        chain.devtool(devtool), isDev && 'web' === target ? chain.output.devtoolModuleFilenameTemplate((info)=>toPosixPath(info.absoluteResourcePath)) : chain.output.devtoolModuleFilenameTemplate(DEFAULT_SOURCE_MAP_TEMPLATE), !devtool && enableCssSourceMap(config) && chain.plugin('source-map-css').use(bundler.SourceMapDevToolPlugin, [
                            {
                                test: /\.css$/,
                                filename: '[file].map[query]'
                            }
                        ]);
                    }), api.processAssets({
                        stage: 'optimize-transfer'
                    }, ({ assets, compilation, sources, environment })=>{
                        if (!compilation.options.devtool && !enableCssSourceMap(environment.config) || compilation.outputOptions.devtoolModuleFilenameTemplate !== DEFAULT_SOURCE_MAP_TEMPLATE) return;
                        let { distPath } = environment;
                        for (let [filename, asset] of Object.entries(assets)){
                            let map;
                            if (!filename.endsWith('.map')) continue;
                            let rawSource = asset.source();
                            try {
                                map = JSON.parse(Buffer.isBuffer(rawSource) ? rawSource.toString() : rawSource);
                            } catch  {
                                continue;
                            }
                            if (!Array.isArray(map.sources)) continue;
                            let mapDir = external_node_path_default().dirname(external_node_path_default().join(distPath, filename)), isSourcesUpdated = !1;
                            map.sources = map.sources.map((source)=>external_node_path_default().isAbsolute(source) ? (isSourcesUpdated = !0, toPosixPath(external_node_path_default().relative(mapDir, source))) : source), isSourcesUpdated && compilation.updateAsset(filename, new sources.RawSource(JSON.stringify(map)));
                        }
                    });
                }
            },
            {
                name: 'rsbuild:cache',
                setup (api) {
                    let cacheEnabled = !1;
                    api.modifyBundlerChain(async (chain, { environment, env })=>{
                        let { config } = environment, { bundlerType } = api.context, buildCache = config.performance.buildCache ?? 'webpack' === bundlerType;
                        if (!1 === buildCache) return;
                        cacheEnabled = !0;
                        let { context } = api, cacheConfig = 'boolean' == typeof buildCache ? {} : buildCache, cacheDirectory = getCacheDirectory(cacheConfig, context), buildDependencies = await getBuildDependencies(context, config, environment, cacheConfig.buildDependencies);
                        'webpack' === bundlerType && await validateWebpackCache(cacheDirectory, buildDependencies);
                        let cacheVersion = Array.isArray(cacheConfig.cacheDigest) && cacheConfig.cacheDigest.length ? `${environment.name}-${env}-${await helpers_hash(JSON.stringify(cacheConfig.cacheDigest))}` : `${environment.name}-${env}`;
                        'rspack' === bundlerType ? (chain.cache(!0), chain.experiments({
                            ...chain.get('experiments'),
                            cache: {
                                type: 'persistent',
                                version: cacheVersion,
                                storage: {
                                    type: 'filesystem',
                                    directory: cacheDirectory
                                },
                                buildDependencies: Object.values(buildDependencies).flat()
                            }
                        })) : chain.cache({
                            name: cacheVersion,
                            type: 'filesystem',
                            cacheDirectory,
                            buildDependencies
                        });
                    }), api.onAfterCreateCompiler(()=>{
                        cacheEnabled && 'rspack' === api.context.bundlerType && logger.debug('Rspack persistent cache enabled');
                    });
                }
            },
            {
                name: 'rsbuild:target',
                setup (api) {
                    api.modifyBundlerChain({
                        order: 'pre',
                        handler: (chain, { target, environment })=>{
                            if ('node' === target) return void chain.target('node');
                            let { browserslist } = environment, isDefaultBrowserslist = browserslist.join(',') === DEFAULT_WEB_BROWSERSLIST.join(',');
                            if ('web-worker' === target) return void chain.target(isDefaultBrowserslist ? [
                                'webworker',
                                'es2017'
                            ] : [
                                'webworker',
                                'es5'
                            ]);
                            let esQuery = isDefaultBrowserslist ? 'es2017' : `browserslist:${browserslist.join(',')}`;
                            chain.target([
                                'web',
                                esQuery
                            ]);
                        }
                    });
                }
            },
            {
                name: 'rsbuild:output',
                setup (api) {
                    api.modifyBundlerChain((chain, { CHAIN_ID, isDev, isProd, isServer, environment, rspack })=>{
                        var jsPath, isServer1, jsAsync;
                        let { distPath, config } = environment, publicPath = getPublicPath({
                            config,
                            isDev,
                            context: api.context
                        }), jsPath1 = config.output.distPath.js, jsAsyncPath = (jsPath = jsPath1, isServer1 = isServer, void 0 !== (jsAsync = config.output.distPath.jsAsync) ? jsAsync : isServer1 ? jsPath : jsPath ? `${jsPath}/async` : 'async'), jsFilename = getFilename(config, 'js', isProd, isServer), isJsFilenameFn = 'function' == typeof jsFilename;
                        if (chain.output.path(distPath).filename(isJsFilenameFn ? (...args)=>{
                            let name = jsFilename(...args);
                            return external_node_path_.posix.join(jsPath1, name);
                        } : external_node_path_.posix.join(jsPath1, jsFilename)).chunkFilename(isJsFilenameFn ? (...args)=>{
                            let name = jsFilename(...args);
                            return external_node_path_.posix.join(jsAsyncPath, name);
                        } : external_node_path_.posix.join(jsAsyncPath, jsFilename)).publicPath(publicPath).pathinfo(!1).hashFunction('xxhash64'), isServer && chain.output.library({
                            type: 'commonjs2',
                            ...chain.output.get('library') || {}
                        }), config.output.copy && 'rspack' === api.context.bundlerType) {
                            let { copy } = config.output, options = Array.isArray(copy) ? {
                                patterns: copy
                            } : copy;
                            chain.plugin(CHAIN_ID.PLUGIN.COPY).use(rspack.CopyRspackPlugin, [
                                options
                            ]);
                        }
                    });
                }
            },
            {
                name: 'rsbuild:resolve',
                setup (api) {
                    api.modifyBundlerChain({
                        order: 'pre',
                        handler: (chain, { environment, CHAIN_ID })=>{
                            let { config, tsconfigPath } = environment, { extensions, conditionNames, mainFields } = config.resolve;
                            chain.resolve.extensions.merge([
                                ...extensions
                            ]), conditionNames?.length && chain.resolve.conditionNames.merge([
                                ...conditionNames
                            ]), mainFields?.length && chain.resolve.mainFields.merge([
                                ...mainFields
                            ]), tsconfigPath && !tsconfigPath.endsWith('jsconfig.json') && chain.resolve.extensionAlias.set('.js', [
                                '.js',
                                '.ts',
                                '.tsx'
                            ]).set('.jsx', [
                                '.jsx',
                                '.tsx'
                            ]), applyAlias({
                                chain,
                                config,
                                rootPath: api.context.rootPath
                            }), chain.module.rule(CHAIN_ID.RULE.MJS).test(/\.m?js/).resolve.set('fullySpecified', !1), config.source.aliasStrategy && logger.warn(`${color.dim('[rsbuild:config]')} The ${color.yellow('"source.aliasStrategy"')} config is deprecated, use ${color.yellow('"resolve.aliasStrategy"')} instead.`);
                            let aliasStrategy = config.source.aliasStrategy ?? config.resolve.aliasStrategy;
                            tsconfigPath && 'rspack' === api.context.bundlerType && 'prefer-tsconfig' === aliasStrategy && chain.resolve.tsConfig({
                                configFile: tsconfigPath,
                                references: 'auto'
                            });
                        }
                    });
                }
            },
            (context1 = context, {
                name: 'rsbuild:file-size',
                setup (api) {
                    api.onAfterBuild(async ({ stats, environments, isFirstCompile })=>{
                        let { hasErrors } = context1.buildState;
                        if (!stats || hasErrors || !isFirstCompile) return;
                        let logs = [];
                        await Promise.all(Object.values(environments).map(async (environment, index)=>{
                            let { printFileSize } = environment.config.performance;
                            if (!1 === printFileSize) return;
                            let defaultConfig = {
                                total: !0,
                                detail: !0,
                                compressed: 'node' !== environment.config.output.target
                            }, mergedConfig = !0 === printFileSize ? defaultConfig : {
                                ...defaultConfig,
                                ...printFileSize
                            }, statsItem = 'stats' in stats ? stats.stats[index] : stats, statsLogs = await printFileSizes(mergedConfig, statsItem, api.context.rootPath, environment.distPath, environment.name);
                            logs.push(...statsLogs);
                        })).catch((err)=>{
                            logger.warn('Failed to print file size.'), logger.warn(err);
                        }), logger.log(logs.join('\n'));
                    });
                }
            }),
            {
                name: 'rsbuild:clean-output',
                setup (api) {
                    let cleanAll = async (params)=>{
                        for (let pathInfo of [
                            ...Object.values(params.environments).reduce((result, curr)=>(result.find((item)=>item.distPath === curr.distPath) || result.push(curr), result), []).map((environment)=>((environment, isDev)=>{
                                    let { rootPath } = api.context, { config, distPath } = environment, { enable, keep } = normalizeCleanDistPath(config.output.cleanDistPath);
                                    return 'auto' === enable ? isDev && !config.dev.writeToDisk ? void 0 : isStrictSubdir(rootPath, distPath) ? {
                                        path: distPath,
                                        keep
                                    } : (logger.warn('The dist path is not a subdir of root path, Rsbuild will not empty it.'), logger.warn(`Please set ${color.yellow('`output.cleanDistPath`')} config manually.`), logger.warn(`Current root path: ${color.dim(rootPath)}`), void logger.warn(`Current dist path: ${color.dim(distPath)}`)) : !0 === enable ? {
                                        path: distPath,
                                        keep
                                    } : void 0;
                                })(environment, params.isDev)),
                            (()=>{
                                let { rootPath, distPath } = api.context, config = api.getNormalizedConfig(), targetPath = (0, external_node_path_.join)(distPath, RSBUILD_OUTPUTS_PATH), { enable } = normalizeCleanDistPath(config.output.cleanDistPath);
                                if (!0 === enable || 'auto' === enable && isStrictSubdir(rootPath, targetPath)) return {
                                    path: targetPath
                                };
                            })()
                        ].filter((pathInfo)=>!!pathInfo))await emptyDir(pathInfo.path, pathInfo.keep);
                    };
                    api.onBeforeBuild(async ({ isFirstCompile, environments })=>{
                        isFirstCompile && await cleanAll({
                            environments
                        });
                    }), api.onBeforeStartDevServer(async ({ environments })=>{
                        await cleanAll({
                            environments,
                            isDev: !0
                        });
                    });
                }
            },
            {
                name: 'rsbuild:asset',
                setup (api) {
                    api.modifyBundlerChain((chain, { isProd, environment })=>{
                        let { config } = environment, getMergedFilename = (assetType)=>{
                            let distDir = config.output.distPath[assetType], filename = getFilename(config, assetType, isProd);
                            return 'function' == typeof filename ? (...args)=>{
                                let name = filename(...args);
                                return external_node_path_default().posix.join(distDir, name);
                            } : external_node_path_default().posix.join(distDir, filename);
                        }, createAssetRule = (assetType, exts, emit)=>{
                            let regExp = getRegExpForExts(exts), { dataUriLimit } = config.output, maxSize = 'number' == typeof dataUriLimit ? dataUriLimit : dataUriLimit[assetType];
                            chainStaticAssetRule({
                                emit,
                                rule: chain.module.rule(assetType).test(regExp),
                                maxSize,
                                filename: getMergedFilename(assetType),
                                assetType
                            });
                        }, { emitAssets } = config.output;
                        createAssetRule(configChain_CHAIN_ID.RULE.IMAGE, IMAGE_EXTENSIONS, emitAssets), createAssetRule(configChain_CHAIN_ID.RULE.SVG, [
                            'svg'
                        ], emitAssets), createAssetRule(configChain_CHAIN_ID.RULE.MEDIA, [
                            ...VIDEO_EXTENSIONS,
                            ...AUDIO_EXTENSIONS
                        ], emitAssets), createAssetRule(configChain_CHAIN_ID.RULE.FONT, FONT_EXTENSIONS, emitAssets), chain.module.rule(configChain_CHAIN_ID.RULE.JSON).test(/\.json$/i).oneOf('json-asset-raw').type('asset/source').resourceQuery(RAW_QUERY_REGEX);
                        let assetsFilename = getMergedFilename('assets');
                        chain.output.assetModuleFilename(assetsFilename), emitAssets || chain.module.generator.merge({
                            'asset/resource': {
                                emit: !1
                            }
                        });
                        let { assetsInclude } = config.source;
                        if (assetsInclude) {
                            let { dataUriLimit } = config.output;
                            chainStaticAssetRule({
                                emit: emitAssets,
                                rule: chain.module.rule(configChain_CHAIN_ID.RULE.ADDITIONAL_ASSETS).test(assetsInclude),
                                maxSize: 'number' == typeof dataUriLimit ? dataUriLimit : dataUriLimit.assets,
                                filename: assetsFilename,
                                assetType: 'additional-assets'
                            });
                        }
                    });
                }
            },
            (context2 = context, {
                name: 'rsbuild:html',
                setup (api) {
                    let defaultFavicon;
                    api.modifyBundlerChain(async (chain, { HtmlPlugin, CHAIN_ID, environment })=>{
                        let { config, htmlPaths } = environment;
                        if (0 === Object.keys(htmlPaths).length) return;
                        let assetPrefix = getPublicPathFromChain(chain, !1), entries = chain.entryPoints.entries() || {}, entryNames = Object.keys(entries).filter((entryName)=>!!htmlPaths[entryName]), extraDataMap = new Map(), finalOptions = await Promise.all(entryNames.map(async (entryName)=>{
                            let entryValue = entries[entryName].values(), chunks = getChunks(entryName, entryValue), inject = getInject(entryName, config), filename = htmlPaths[entryName], { templatePath, templateContent } = await getTemplate(entryName, config, api.context.rootPath), templateParameters = getTemplateParameters(entryName, config, assetPrefix), pluginOptions = {
                                meta: getMetaTags(entryName, config, templateContent),
                                chunks,
                                inject,
                                filename,
                                entryName,
                                templateParameters,
                                scriptLoading: config.output.module ? 'module' : config.html.scriptLoading
                            };
                            templatePath && (pluginOptions.template = templatePath), chunks.length > 1 && (pluginOptions.chunksSortMode = 'manual');
                            let extraData = {
                                entryName,
                                context: context2,
                                environment,
                                faviconDistPath: config.output.distPath.favicon
                            };
                            extraDataMap.set(entryName, extraData), templateContent && (extraData.templateContent = templateContent);
                            let tagConfig = ((config)=>{
                                let tags = helpers_castArray(config.html.tags).filter(Boolean);
                                if (tags.length) return {
                                    append: !0,
                                    hash: !1,
                                    publicPath: !0,
                                    tags
                                };
                            })(environment.config);
                            tagConfig && (extraData.tagConfig = tagConfig), pluginOptions.title = getTitle(entryName, config);
                            let favicon = getFavicon(entryName, config) || (()=>{
                                if (defaultFavicon) return defaultFavicon;
                                let { publicDir } = api.getNormalizedConfig().server, extensions = [
                                    'ico',
                                    'png',
                                    'svg'
                                ], publicDirs = Array.from(new Set(publicDir.map(({ name })=>name))), faviconPaths = [];
                                for (let publicDir of publicDirs)for (let ext of extensions)faviconPaths.push(external_node_path_default().join(publicDir, `favicon.${ext}`));
                                let faviconPath = findExists(faviconPaths);
                                return faviconPath && (defaultFavicon = faviconPath), defaultFavicon;
                            })();
                            favicon && (extraData.favicon = favicon);
                            let finalOptions = reduceConfigsWithContext({
                                initial: pluginOptions,
                                config: 'boolean' == typeof config.tools.htmlPlugin ? {} : config.tools.htmlPlugin,
                                ctx: {
                                    entryName,
                                    entryValue
                                }
                            });
                            return finalOptions.template || finalOptions.templateContent || (pluginOptions.template = '', pluginOptions.templateContent = templateContent), finalOptions;
                        }));
                        if (entryNames.forEach((entryName, index)=>{
                            chain.plugin(`${CHAIN_ID.PLUGIN.HTML}-${entryName}`).use(HtmlPlugin, [
                                {
                                    ...finalOptions[index],
                                    [entryNameSymbol]: entryName
                                }
                            ]);
                        }), chain.plugin('rsbuild-html-plugin').use(RsbuildHtmlPlugin, [
                            (entryName)=>extraDataMap.get(entryName),
                            ()=>HtmlPlugin
                        ]), config.html) {
                            let { crossorigin } = config.html;
                            crossorigin && chain.output.crossOriginLoading(!0 === crossorigin ? 'anonymous' : crossorigin);
                        }
                    }), api.modifyHTMLTags({
                        order: 'post',
                        handler: ({ headTags, bodyTags }, { environment })=>{
                            let { config } = environment, { crossorigin } = config.html, allTags = [
                                ...headTags,
                                ...bodyTags
                            ];
                            if (crossorigin) {
                                let formattedCrossorigin = !0 === crossorigin ? 'anonymous' : crossorigin;
                                for (let tag of allTags)("script" === tag.tag && tag.attrs?.src || 'link' === tag.tag && tag.attrs?.rel === 'stylesheet') && (tag.attrs.crossorigin ??= formattedCrossorigin);
                            }
                            return {
                                headTags,
                                bodyTags
                            };
                        }
                    });
                }
            }),
            {
                name: 'rsbuild:app-icon',
                setup (api) {
                    let htmlTagsMap = new Map(), iconFormatMap = new Map();
                    api.processAssets({
                        stage: 'additional'
                    }, async ({ compilation, environment, sources })=>{
                        let { config } = environment, { appIcon } = config.html;
                        if (!appIcon) return;
                        let { lookup } = requireCompiledPackage('mrmime'), distDir = config.output.distPath.image, manifestFile = appIcon.filename ?? 'manifest.webmanifest', publicPath = getPublicPathFromCompiler(compilation), icons = appIcon.icons.map((icon)=>((icon, distDir, publicPath, lookup)=>{
                                let { src, size } = icon, cached = iconFormatMap.get(src);
                                if (cached) return cached;
                                let sizes = `${size}x${size}`;
                                if (isURL(src)) {
                                    let formatted = {
                                        ...icon,
                                        src,
                                        sizes,
                                        isURL: !0,
                                        mimeType: lookup(src)
                                    };
                                    return iconFormatMap.set(src, formatted), formatted;
                                }
                                let absolutePath = external_node_path_default().isAbsolute(src) ? src : external_node_path_default().join(api.context.rootPath, src), relativePath = external_node_path_default().posix.join(distDir, external_node_path_default().basename(absolutePath)), formatted = {
                                    ...icon,
                                    sizes,
                                    src: ensureAssetPrefix(relativePath, publicPath),
                                    isURL: !1,
                                    absolutePath,
                                    relativePath,
                                    mimeType: lookup(absolutePath)
                                };
                                return iconFormatMap.set(src, formatted), formatted;
                            })(icon, distDir, publicPath, lookup)), tags = [];
                        for (let icon of icons){
                            if ('web-app-manifest' === icon.target && !appIcon.name) {
                                addCompilationError(compilation, `${color.dim('[rsbuild:app-icon]')} ${color.yellow('"appIcon.name"')} is required when ${color.yellow('"target"')} is ${color.yellow('"web-app-manifest"')}.`);
                                continue;
                            }
                            if (!icon.isURL) {
                                if (!compilation.inputFileSystem) {
                                    addCompilationError(compilation, `${color.dim('[rsbuild:app-icon]')} Failed to read the icon file as ${color.yellow('"compilation.inputFileSystem"')} is not available.`);
                                    continue;
                                }
                                if (!await fileExistsByCompilation(compilation, icon.absolutePath)) {
                                    addCompilationError(compilation, `${color.dim('[rsbuild:app-icon]')} Failed to find the icon file at ${color.yellow(icon.absolutePath)}.`);
                                    continue;
                                }
                                let source = await (0, external_node_util_.promisify)(compilation.inputFileSystem.readFile)(icon.absolutePath);
                                if (!source) {
                                    addCompilationError(compilation, `${color.dim('[rsbuild:app-icon]')} Failed to read the icon file at ${color.yellow(icon.absolutePath)}.`);
                                    continue;
                                }
                                compilation.emitAsset(icon.relativePath, new sources.RawSource(source));
                            }
                            ('apple-touch-icon' === icon.target || !icon.target && icon.size < 200) && tags.push({
                                tag: 'link',
                                attrs: {
                                    rel: 'apple-touch-icon',
                                    sizes: icon.sizes,
                                    href: icon.src
                                }
                            });
                        }
                        if (appIcon.name) {
                            let manifestIcons = icons.filter((icon)=>'web-app-manifest' === icon.target || !icon.target).map((icon)=>{
                                let result = pick(icon, [
                                    'src',
                                    'sizes',
                                    'purpose'
                                ]);
                                return icon.mimeType ? {
                                    ...result,
                                    type: icon.mimeType
                                } : result;
                            }), manifest = {
                                name: appIcon.name,
                                icons: manifestIcons
                            };
                            compilation.emitAsset(manifestFile, new sources.RawSource(JSON.stringify(manifest))), tags.push({
                                tag: 'link',
                                attrs: {
                                    rel: 'manifest',
                                    href: ensureAssetPrefix(manifestFile, publicPath)
                                }
                            });
                        }
                        tags.length && htmlTagsMap.set(environment.name, tags);
                    }), api.modifyHTMLTags(({ headTags, bodyTags }, { environment })=>{
                        let tags = htmlTagsMap.get(environment.name);
                        return tags && headTags.unshift(...tags), {
                            headTags,
                            bodyTags
                        };
                    });
                    let clean = ()=>{
                        htmlTagsMap.clear(), iconFormatMap.clear();
                    };
                    api.onCloseDevServer(clean), api.onCloseBuild(clean);
                }
            },
            {
                name: 'rsbuild:wasm',
                setup (api) {
                    api.modifyBundlerChain((chain, { CHAIN_ID, environment, isProd })=>{
                        let { config } = environment, distPath = config.output.distPath.wasm, filename = external_node_path_.posix.join(distPath, 'webpack' === api.context.bundlerType ? '[hash].module.wasm' : getFilename(config, 'wasm', isProd));
                        chain.experiments({
                            ...chain.get('experiments'),
                            asyncWebAssembly: !0
                        }), chain.output.webassemblyModuleFilename(filename), chain.module.rule(CHAIN_ID.RULE.WASM).test(/\.wasm$/).dependency('url').type('asset/resource').set('generator', {
                            filename
                        });
                    });
                }
            },
            {
                name: 'rsbuild:moment',
                setup (api) {
                    api.modifyBundlerChain((chain, { environment, bundler })=>{
                        let { config } = environment;
                        config.performance.removeMomentLocale && chain.plugin('remove-moment-locale').use(bundler.IgnorePlugin, [
                            {
                                resourceRegExp: /^\.\/locale$/,
                                contextRegExp: /moment$/
                            }
                        ]);
                    });
                }
            },
            {
                name: 'rsbuild:node-addons',
                setup (api) {
                    api.transform({
                        test: /\.node$/,
                        targets: [
                            'node'
                        ],
                        raw: !0
                    }, ({ code, emitFile, resourcePath })=>{
                        let name = ((resourcePath)=>{
                            let basename = '';
                            if (resourcePath) {
                                let parsed = external_node_path_default().parse(resourcePath);
                                parsed.dir && (basename = parsed.name);
                            }
                            return basename ? `${basename}.node` : null;
                        })(resourcePath);
                        if (null === name) throw Error(`${color.dim('[rsbuild:node-addons]')} Failed to load Node.js addon: ${color.yellow(resourcePath)}`);
                        return emitFile(name, code), `
try {
const path = require("path");
process.dlopen(module, path.join(__dirname, "${name}"));
} catch (error) {
throw new Error('Failed to load Node.js addon: "${name}"\\n' + error);
}
`;
                    });
                }
            },
            {
                name: 'rsbuild:define',
                setup (api) {
                    api.modifyBundlerChain((chain, { CHAIN_ID, bundler, environment })=>{
                        let { config } = environment, baseUrl = JSON.stringify(config.server.base), assetPrefix = JSON.stringify(getPublicPathFromChain(chain, !1)), mergedDefine = {
                            ...{
                                'import.meta.env': {
                                    MODE: JSON.stringify(config.mode),
                                    DEV: 'development' === config.mode,
                                    PROD: 'production' === config.mode,
                                    BASE_URL: baseUrl,
                                    ASSET_PREFIX: assetPrefix
                                },
                                'process.env.BASE_URL': baseUrl,
                                'process.env.ASSET_PREFIX': assetPrefix
                            },
                            ...config.source.define
                        };
                        checkProcessEnvSecurity(mergedDefine), chain.plugin(CHAIN_ID.PLUGIN.DEFINE).use(bundler.DefinePlugin, [
                            mergedDefine
                        ]);
                    });
                }
            },
            {
                name: 'rsbuild:css',
                setup (api) {
                    let postcssrcCache = new Map();
                    api.modifyBundlerChain({
                        order: 'pre',
                        handler: async (chain, { target, isProd, CHAIN_ID, environment, environments })=>{
                            let config, isProd1, rule = chain.module.rule(CHAIN_ID.RULE.CSS), inlineRule = chain.module.rule(CHAIN_ID.RULE.CSS_INLINE), { config: config1 } = environment;
                            rule.test(CSS_REGEX).type("javascript/auto").dependency({
                                not: 'url'
                            }).resourceQuery({
                                not: [
                                    RAW_QUERY_REGEX,
                                    INLINE_QUERY_REGEX
                                ]
                            }), inlineRule.test(CSS_REGEX).type("javascript/auto").resourceQuery(INLINE_QUERY_REGEX), chain.module.rule(CHAIN_ID.RULE.CSS_RAW).test(CSS_REGEX).type('asset/source').resourceQuery(RAW_QUERY_REGEX);
                            let emitCss = config1.output.emitCss ?? 'web' === target;
                            if (emitCss) if (config1.output.injectStyles) {
                                let styleLoaderOptions = reduceConfigs({
                                    initial: {},
                                    config: config1.tools.styleLoader
                                });
                                rule.use(CHAIN_ID.USE.STYLE).loader(getCompiledPath('style-loader')).options(styleLoaderOptions);
                            } else rule.use(CHAIN_ID.USE.MINI_CSS_EXTRACT).loader(getCssExtractPlugin().loader).options(config1.tools.cssExtract.loaderOptions);
                            else rule.use(CHAIN_ID.USE.IGNORE_CSS).loader(external_node_path_default().join(LOADER_PATH, 'ignoreCssLoader.mjs'));
                            let importLoaders = {
                                normal: 0,
                                inline: 0
                            }, updateRules = (callback, options = {})=>{
                                options.skipNormal || callback(rule, 'normal'), callback(inlineRule, 'inline');
                            }, cssLoaderPath = getCompiledPath('css-loader');
                            if (updateRules((rule)=>{
                                rule.use(CHAIN_ID.USE.CSS).loader(cssLoaderPath);
                            }), 'rspack' === api.context.bundlerType && !1 !== config1.tools.lightningcssLoader) {
                                emitCss && importLoaders.normal++, importLoaders.inline++;
                                let { minifyCss } = parseMinifyOptions(config1), { browserslist } = environment;
                                if ('node' === target) {
                                    let webEnvironment = Object.values(environments).find((env)=>'web' === env.config.output.target);
                                    webEnvironment?.browserslist && (browserslist = webEnvironment.browserslist);
                                }
                                updateRules((rule, type)=>{
                                    let inlineStyle = 'inline' === type || config1.output.injectStyles, lightningcssOptions = getLightningCSSLoaderOptions(config1, browserslist, inlineStyle && minifyCss);
                                    rule.use(CHAIN_ID.USE.LIGHTNINGCSS).loader('builtin:lightningcss-loader').options(lightningcssOptions);
                                }, {
                                    skipNormal: !emitCss
                                });
                            }
                            let postcssLoaderOptions = await getPostcssLoaderOptions({
                                config: config1,
                                root: api.context.rootPath,
                                postcssrcCache
                            });
                            if ('function' == typeof postcssLoaderOptions.postcssOptions || postcssLoaderOptions.postcssOptions?.plugins?.length) {
                                emitCss && importLoaders.normal++, importLoaders.inline++;
                                let postcssLoaderPath = getCompiledPath('postcss-loader');
                                updateRules((rule)=>{
                                    rule.use(CHAIN_ID.USE.POSTCSS).loader(postcssLoaderPath).options(postcssLoaderOptions);
                                }, {
                                    skipNormal: !emitCss
                                });
                            }
                            let localIdentName = (config = config1, isProd1 = isProd, config.output.cssModules.localIdentName || (isProd1 ? '[local]-[hash:base64:6]' : '[path][name]__[local]-[hash:base64:6]')), cssLoaderOptions = (({ config, localIdentName, emitCss })=>{
                                let { cssModules } = config.output;
                                return ((options, exportOnlyLocals)=>{
                                    if (options.modules && exportOnlyLocals) {
                                        let { modules } = options;
                                        return modules = !0 === modules ? {
                                            exportOnlyLocals: !0
                                        } : 'string' == typeof modules ? {
                                            mode: modules,
                                            exportOnlyLocals: !0
                                        } : {
                                            ...modules,
                                            exportOnlyLocals: !0
                                        }, {
                                            ...options,
                                            modules
                                        };
                                    }
                                    return options;
                                })(reduceConfigs({
                                    initial: {
                                        modules: {
                                            ...cssModules,
                                            localIdentName
                                        },
                                        sourceMap: getCSSSourceMap(config)
                                    },
                                    config: config.tools.cssLoader,
                                    mergeFn: cjs_default()
                                }), !emitCss);
                            })({
                                config: config1,
                                localIdentName,
                                emitCss
                            });
                            updateRules((rule, type)=>{
                                let finalOptions = cssLoaderOptions;
                                finalOptions = 'inline' === type ? {
                                    ...cssLoaderOptions,
                                    exportType: 'string',
                                    modules: !1,
                                    importLoaders: importLoaders.inline
                                } : {
                                    ...cssLoaderOptions,
                                    importLoaders: importLoaders.normal
                                }, rule.use(CHAIN_ID.USE.CSS).options(finalOptions), rule.sideEffects(!0), rule.resolve.preferRelative(!0);
                            });
                            let isStringExport = 'string' === cssLoaderOptions.exportType;
                            if (isStringExport && rule.uses.has(CHAIN_ID.USE.MINI_CSS_EXTRACT) && rule.uses.delete(CHAIN_ID.USE.MINI_CSS_EXTRACT), emitCss && !config1.output.injectStyles && !isStringExport) {
                                let extractPluginOptions = config1.tools.cssExtract.pluginOptions, cssPath = config1.output.distPath.css, cssFilename = getFilename(config1, 'css', isProd), isCssFilenameFn = 'function' == typeof cssFilename, cssAsyncPath = config1.output.distPath.cssAsync ?? (cssPath ? `${cssPath}/async` : 'async');
                                chain.plugin(CHAIN_ID.PLUGIN.MINI_CSS_EXTRACT).use(getCssExtractPlugin(), [
                                    {
                                        filename: isCssFilenameFn ? (...args)=>{
                                            let name = cssFilename(...args);
                                            return external_node_path_.posix.join(cssPath, name);
                                        } : external_node_path_.posix.join(cssPath, cssFilename),
                                        chunkFilename: isCssFilenameFn ? (...args)=>{
                                            let name = cssFilename(...args);
                                            return external_node_path_.posix.join(cssAsyncPath, name);
                                        } : external_node_path_.posix.join(cssAsyncPath, cssFilename),
                                        ...extractPluginOptions
                                    }
                                ]);
                            }
                        }
                    });
                }
            },
            {
                name: 'rsbuild:minimize',
                setup (api) {
                    let isRspack = 'rspack' === api.context.bundlerType;
                    api.modifyBundlerChain((chain, { environment, CHAIN_ID, rspack })=>{
                        let { config } = environment, { minifyJs, minifyCss, jsOptions, cssOptions } = parseMinifyOptions(config);
                        if (chain.optimization.minimize(minifyJs || minifyCss), minifyJs && isRspack && chain.optimization.minimizer(CHAIN_ID.MINIMIZER.JS).use(rspack.SwcJsMinimizerRspackPlugin, [
                            ((config, jsOptions)=>{
                                let options = {};
                                options.minimizerOptions ||= {}, options.minimizerOptions.format ||= {};
                                let { removeConsole } = config.performance;
                                if (!0 === removeConsole) options.minimizerOptions.compress = {
                                    drop_console: !0
                                };
                                else if (Array.isArray(removeConsole)) {
                                    let pureFuncs = removeConsole.map((method)=>`console.${method}`);
                                    options.minimizerOptions.compress = {
                                        pure_funcs: pureFuncs
                                    };
                                }
                                if (config.output.legalComments) switch(config.output.legalComments){
                                    case 'inline':
                                        options.minimizerOptions.format.comments = 'some', options.extractComments = !1;
                                        break;
                                    case 'linked':
                                        options.extractComments = !0;
                                        break;
                                    case 'none':
                                        options.minimizerOptions.format.comments = !1, options.extractComments = !1;
                                }
                                return (options.minimizerOptions.format.asciiOnly = 'ascii' === config.output.charset, jsOptions) ? cjs_default()(options, jsOptions) : options;
                            })(config, jsOptions)
                        ]).end(), minifyCss && isRspack) {
                            let loaderOptions = getLightningCSSLoaderOptions(config, environment.browserslist, !0), defaultOptions = {
                                minimizerOptions: {
                                    targets: isPlainObject(loaderOptions.targets) ? environment.browserslist : loaderOptions.targets,
                                    ...pick(loaderOptions, [
                                        'draft',
                                        'include',
                                        'exclude',
                                        'nonStandard',
                                        'pseudoClasses',
                                        'unusedSymbols',
                                        'errorRecovery'
                                    ])
                                }
                            }, mergedOptions = cssOptions ? cjs_default()(defaultOptions, cssOptions) : defaultOptions;
                            chain.optimization.minimizer(CHAIN_ID.MINIMIZER.CSS).use(rspack.LightningCssMinimizerRspackPlugin, [
                                mergedOptions
                            ]).end();
                        }
                    });
                }
            },
            {
                name: 'rsbuild:progress',
                setup (api) {
                    'webpack' !== api.context.bundlerType && api.modifyBundlerChain((chain, { CHAIN_ID, environment, rspack })=>{
                        let { config } = environment, options = config.dev.progressBar;
                        if (!options) return;
                        let prefix = !0 !== options && void 0 !== options.id ? options.id : environment.name;
                        chain.plugin(CHAIN_ID.PLUGIN.PROGRESS).use(rspack.ProgressPlugin, [
                            {
                                prefix,
                                ...!0 === options ? {} : options
                            }
                        ]);
                    });
                }
            },
            {
                name: PLUGIN_SWC_NAME,
                setup (api) {
                    api.modifyBundlerChain({
                        order: 'pre',
                        handler: (chain, { CHAIN_ID, isDev, isProd, target, environment })=>{
                            let { config, browserslist } = environment, cacheRoot = external_node_path_default().join(api.context.cachePath, '.swc'), rule = chain.module.rule(CHAIN_ID.RULE.JS).test(SCRIPT_REGEX).type("javascript/auto").dependency({
                                not: 'url'
                            }).resourceQuery({
                                not: RAW_QUERY_REGEX
                            });
                            chain.module.rule(CHAIN_ID.RULE.JS_RAW).test(SCRIPT_REGEX).type('asset/source').resourceQuery(RAW_QUERY_REGEX);
                            let dataUriRule = chain.module.rule(CHAIN_ID.RULE.JS_DATA_URI).mimetype({
                                or: [
                                    "text/javascript",
                                    "application/javascript"
                                ]
                            });
                            if (applyScriptCondition({
                                rule,
                                isDev,
                                config,
                                rsbuildTarget: target
                            }), 'webpack' === api.context.bundlerType) return;
                            let swcConfig = getDefaultSwcConfig({
                                browserslist,
                                cacheRoot,
                                config,
                                isProd
                            });
                            if (applyTransformImport(swcConfig, config.source.transformImport), applySwcDecoratorConfig(swcConfig, config), isWebTarget(target)) {
                                let polyfillMode = config.output.polyfill;
                                if ('off' === polyfillMode) swcConfig.env.mode = void 0;
                                else {
                                    swcConfig.env.mode = polyfillMode;
                                    let coreJsDir = applyCoreJs(swcConfig, polyfillMode);
                                    for (let item of [
                                        rule,
                                        dataUriRule
                                    ])item.resolve.alias.set('core-js', coreJsDir);
                                }
                            }
                            let mergedSwcConfig = reduceConfigs({
                                initial: swcConfig,
                                config: config.tools.swc,
                                mergeFn: cjs_default()
                            });
                            rule.use(CHAIN_ID.USE.SWC).loader(builtinSwcLoaderName).options(mergedSwcConfig), dataUriRule.resolve.set('fullySpecified', !1).end().use(CHAIN_ID.USE.SWC).loader(builtinSwcLoaderName).options(cloneDeep(mergedSwcConfig));
                        }
                    });
                }
            },
            {
                name: 'rsbuild:esm',
                setup (api) {
                    api.modifyBundlerChain((chain, { environment, target })=>{
                        let { config } = environment;
                        if (config.output.module) {
                            if ('node' === target && chain.output.library({
                                ...chain.output.get('library'),
                                type: 'module'
                            }), 'web-worker' === target) throw Error('[rsbuild:config] `output.module` is not supported for web-worker target.');
                            chain.output.module(!0).chunkFormat('module').chunkLoading('import').workerChunkLoading('import'), chain.experiments({
                                ...chain.get('experiments'),
                                outputModule: !0
                            });
                        }
                    });
                }
            },
            pluginExternals(),
            {
                name: 'rsbuild:split-chunks',
                setup (api) {
                    api.modifyBundlerChain(async (chain, { environment, isServer, isWebWorker })=>{
                        if (isServer || isWebWorker) {
                            chain.optimization.splitChunks(!1), isWebWorker && chain.module.parser.merge({
                                javascript: {
                                    dynamicImportMode: 'eager'
                                }
                            });
                            return;
                        }
                        let { config } = environment, defaultConfig = {
                            chunks: config.moduleFederation?.options?.exposes ? 'async' : 'all',
                            cacheGroups: {}
                        };
                        'webpack' === api.context.bundlerType && (defaultConfig.enforceSizeThreshold = 50000);
                        let { chunkSplit } = config.performance, forceSplittingGroups = {};
                        chunkSplit.forceSplitting && (forceSplittingGroups = getForceSplittingGroups(chunkSplit.forceSplitting, chunkSplit.strategy));
                        let override = 'custom' === chunkSplit.strategy ? chunkSplit.splitChunks ?? chunkSplit.override : chunkSplit.override, splitChunksOptions = await SPLIT_STRATEGY_DISPATCHER[chunkSplit.strategy || 'split-by-experience']({
                            defaultConfig,
                            override: override || {},
                            forceSplittingGroups,
                            userConfig: chunkSplit,
                            rootPath: api.context.rootPath,
                            polyfill: config.output.polyfill
                        });
                        chain.optimization.splitChunks(splitChunksOptions);
                    });
                }
            },
            {
                name: 'rsbuild:inline-chunk',
                setup (api) {
                    let inlinedAssets = new Set();
                    api.processAssets({
                        stage: 'summarize'
                    }, ({ compiler, compilation })=>{
                        if (0 === inlinedAssets.size) return;
                        let { devtool } = compiler.options;
                        for (let name of inlinedAssets)'hidden-source-map' === devtool || !1 === devtool ? compilation.deleteAsset(name) : delete compilation.assets[name];
                        inlinedAssets.clear();
                    }), api.modifyHTMLTags(({ headTags, bodyTags }, { compiler, compilation, environment })=>{
                        let { htmlPaths, config } = environment;
                        if (0 === Object.keys(htmlPaths).length) return {
                            headTags,
                            bodyTags
                        };
                        let { scriptTests, styleTests } = getInlineTests(config);
                        if (!scriptTests.length && !styleTests.length) return {
                            headTags,
                            bodyTags
                        };
                        let publicPath = getPublicPathFromCompiler(compiler), updateTag = (tag)=>{
                            var publicPath1, tag1, compilation1, scriptTests1, styleTests1, config;
                            return publicPath1 = publicPath, tag1 = tag, compilation1 = compilation, scriptTests1 = scriptTests, styleTests1 = styleTests, config = environment.config, "script" === tag1.tag ? ((publicPath, tag, compilation, scriptTests, config)=>{
                                let { assets } = compilation;
                                if (!(tag.attrs?.src && 'string' == typeof tag.attrs.src)) return tag;
                                let { src, ...otherAttrs } = tag.attrs, scriptName = publicPath ? src.replace(publicPath, '') : src, asset = assets[scriptName];
                                if (null == asset || !matchTests(scriptName, asset, scriptTests)) return tag;
                                let ret = {
                                    tag: "script",
                                    children: updateSourceMappingURL({
                                        source: asset.source().toString(),
                                        compilation,
                                        publicPath,
                                        type: 'js',
                                        config
                                    }),
                                    attrs: {
                                        ...otherAttrs
                                    }
                                };
                                return inlinedAssets.add(scriptName), ret;
                            })(publicPath1, tag1, compilation1, scriptTests1, config) : 'link' === tag1.tag && tag1.attrs && 'stylesheet' === tag1.attrs.rel ? ((publicPath, tag, compilation, styleTests, config)=>{
                                let { assets } = compilation;
                                if (!(tag.attrs?.href && 'string' == typeof tag.attrs.href)) return tag;
                                let linkName = publicPath ? tag.attrs.href.replace(publicPath, '') : tag.attrs.href, asset = assets[linkName];
                                if (null == asset || !matchTests(linkName, asset, styleTests)) return tag;
                                let ret = {
                                    tag: 'style',
                                    children: updateSourceMappingURL({
                                        source: asset.source().toString(),
                                        compilation,
                                        publicPath,
                                        type: 'css',
                                        config
                                    })
                                };
                                return inlinedAssets.add(linkName), ret;
                            })(publicPath1, tag1, compilation1, styleTests1, config) : tag1;
                        };
                        return {
                            headTags: headTags.map(updateTag),
                            bodyTags: bodyTags.map(updateTag)
                        };
                    });
                }
            },
            {
                name: 'rsbuild:rsdoctor',
                setup (api) {
                    api.onBeforeCreateCompiler(async ({ bundlerConfigs })=>{
                        let packagePath, module;
                        if ('true' !== process.env.RSDOCTOR) return;
                        let isRspack = 'rspack' === api.context.bundlerType, pluginName = isRspack ? 'RsdoctorRspackPlugin' : 'RsdoctorWebpackPlugin', isRsdoctorPlugin = (plugin)=>plugin?.isRsdoctorPlugin === !0 || plugin?.constructor?.name === pluginName;
                        for (let config of bundlerConfigs)if (config.plugins?.some((plugin)=>isRsdoctorPlugin(plugin))) return;
                        let packageName = isRspack ? '@rsdoctor/rspack-plugin' : '@rsdoctor/webpack-plugin';
                        try {
                            packagePath = rsdoctor_require.resolve(packageName, {
                                paths: [
                                    api.context.rootPath
                                ]
                            });
                        } catch  {
                            logger.warn(`\`process.env.RSDOCTOR\` enabled, please install ${color.bold(color.yellow(packageName))} package.`);
                            return;
                        }
                        try {
                            let moduleURL = isWindows ? (0, external_node_url_.pathToFileURL)(packagePath).href : packagePath;
                            module = await import(moduleURL);
                        } catch  {
                            logger.error(`\`process.env.RSDOCTOR\` enabled, but failed to load ${color.bold(color.yellow(packageName))} module.`);
                            return;
                        }
                        if (module && module[pluginName]) {
                            for (let config of bundlerConfigs)config.plugins ||= [], config.plugins.push(new module[pluginName]());
                            logger.info(`${color.bold(color.yellow(packageName))} enabled.`);
                        }
                    });
                }
            },
            {
                name: 'rsbuild:resource-hints',
                setup (api) {
                    api.modifyHTMLTags(({ headTags, bodyTags }, { environment })=>{
                        let { config } = environment, { dnsPrefetch, preconnect } = config.performance;
                        if (dnsPrefetch) {
                            let attrs = dnsPrefetch.map((option)=>({
                                    href: option
                                }));
                            attrs.length && headTags.unshift(...resourceHints_generateLinks(attrs, 'dns-prefetch'));
                        }
                        if (preconnect) {
                            let attrs = preconnect.map((option)=>'string' == typeof option ? {
                                    href: option
                                } : option);
                            attrs.length && headTags.unshift(...resourceHints_generateLinks(attrs, 'preconnect'));
                        }
                        return {
                            headTags,
                            bodyTags
                        };
                    }), api.modifyBundlerChain((chain, { CHAIN_ID, environment, isDev })=>{
                        let { config, htmlPaths } = environment;
                        if (0 === Object.keys(htmlPaths).length) return;
                        let { performance: { preload, prefetch } } = config, HTMLCount = chain.entryPoints.values().length, excludes = ((config)=>{
                            let { scriptTests, styleTests } = getInlineTests(config);
                            return [
                                ...scriptTests,
                                ...styleTests
                            ].filter((item)=>(0, types_namespaceObject.isRegExp)(item));
                        })(config);
                        if (prefetch) {
                            let options = !0 === prefetch ? {} : prefetch;
                            excludes.length && (options.exclude = options.exclude ? [
                                ...helpers_castArray(options.exclude),
                                ...excludes
                            ] : excludes), chain.plugin(CHAIN_ID.PLUGIN.HTML_PREFETCH).use(HtmlResourceHintsPlugin, [
                                options,
                                'prefetch',
                                HTMLCount,
                                isDev,
                                ()=>pluginHelper_getHTMLPlugin(config)
                            ]);
                        }
                        if (preload) {
                            let options = !0 === preload ? {} : preload;
                            excludes.length && (options.exclude = options.exclude ? [
                                ...helpers_castArray(options.exclude),
                                ...excludes
                            ] : excludes), chain.plugin(CHAIN_ID.PLUGIN.HTML_PRELOAD).use(HtmlResourceHintsPlugin, [
                                options,
                                'preload',
                                HTMLCount,
                                isDev,
                                ()=>pluginHelper_getHTMLPlugin(config)
                            ]);
                        }
                    });
                }
            },
            {
                name: 'rsbuild:performance',
                setup (api) {
                    api.modifyRsbuildConfig({
                        order: 'post',
                        handler: (rsbuildConfig)=>{
                            let applyBundleAnalyzeConfig = (config)=>{
                                config.performance?.bundleAnalyze ? config.performance.bundleAnalyze = {
                                    generateStatsFile: !0,
                                    ...config.performance.bundleAnalyze || {}
                                } : (config.performance ??= {}, config.performance.bundleAnalyze = {
                                    analyzerMode: 'disabled',
                                    generateStatsFile: !0
                                });
                            };
                            if (rsbuildConfig.performance?.profile) applyBundleAnalyzeConfig(rsbuildConfig);
                            else if (rsbuildConfig.environments) for (let config of Object.values(rsbuildConfig.environments))config.performance?.profile && applyBundleAnalyzeConfig(config);
                        }
                    }), api.modifyBundlerChain((chain, { environment })=>{
                        let { config } = environment, { profile } = config.performance;
                        profile && chain.profile(profile);
                    });
                }
            },
            pluginBundleAnalyzer(),
            {
                name: 'rsbuild:server',
                setup (api) {
                    let onStartServer = ({ port, routes })=>{
                        let config = api.getNormalizedConfig();
                        config.server.open && open_open({
                            https: api.context.devServer?.https,
                            port,
                            routes,
                            config
                        });
                    };
                    api.onAfterStartDevServer(onStartServer), api.onAfterStartProdServer(onStartServer), api.onBeforeBuild(async ({ isFirstCompile, environments })=>{
                        if (isFirstCompile) for (let { name: publicDir, copyOnBuild } of api.getNormalizedConfig().server.publicDir){
                            if (!1 === copyOnBuild || !external_node_fs_default().existsSync(publicDir)) continue;
                            let distPaths = dedupeNestedPaths(Object.values(environments).filter(({ config })=>!0 === copyOnBuild || 'auto' === copyOnBuild && 'node' !== config.output.target).map(({ distPath })=>distPath));
                            try {
                                await Promise.all(distPaths.map(async (distPath)=>{
                                    isDeno && external_node_fs_default().existsSync(distPath) && await external_node_fs_default().promises.rm(distPath, {
                                        recursive: !0,
                                        force: !0
                                    }), await external_node_fs_default().promises.cp(publicDir, distPath, {
                                        recursive: !0,
                                        dereference: !0,
                                        mode: external_node_fs_default().constants.COPYFILE_FICLONE
                                    });
                                }));
                            } catch (err) {
                                throw err instanceof Error && (err.message = `Failed to copy public directory '${color.yellow(publicDir)}' to output directory. To disable public directory copying, set \`${color.cyan('server.publicDir: false')}\` in your config.\n${err.message}`), err;
                            }
                        }
                    });
                }
            },
            {
                name: 'rsbuild:manifest',
                setup (api) {
                    let manifestFilenames = new Map();
                    api.modifyBundlerChain((chain, { CHAIN_ID, environment, isDev })=>{
                        let htmlPaths, manifestOptions, environment1, { output: { manifest }, dev: { writeToDisk } } = environment.config;
                        if (!1 === manifest) return;
                        let manifestOptions1 = normalizeManifestObjectConfig(manifest), { RspackManifestPlugin } = requireCompiledPackage('rspack-manifest-plugin'), { htmlPaths: htmlPaths1 } = environment, filter = manifestOptions1.filter ?? ((file)=>!file.name.endsWith('.LICENSE.txt'));
                        manifestFilenames.set(environment.name, manifestOptions1.filename), chain.plugin(CHAIN_ID.PLUGIN.MANIFEST).use(RspackManifestPlugin, [
                            {
                                fileName: manifestOptions1.filename,
                                filter,
                                writeToFileEmit: isDev && !0 !== writeToDisk,
                                generate: (htmlPaths = htmlPaths1, manifestOptions = manifestOptions1, environment1 = environment, (_seed, files, entries, { compilation })=>{
                                    let chunkEntries = new Map(), licenseMap = new Map(), publicPath = getPublicPathFromCompiler(compilation), allFiles = files.map((file)=>{
                                        if (file.chunk) for (let entryName of recursiveChunkEntryNames(file.chunk))chunkEntries.set(entryName, [
                                            file,
                                            ...chunkEntries.get(entryName) || []
                                        ]);
                                        if (file.path.endsWith('.LICENSE.txt')) {
                                            let sourceFilePath = file.path.split('.LICENSE.txt')[0];
                                            licenseMap.set(sourceFilePath, file.path);
                                        }
                                        return file.path;
                                    }), manifestEntries = {};
                                    for (let [entryName, chunkFiles] of chunkEntries){
                                        let assets = new Set(), initialJS = [], initialCSS = [], asyncJS = [], asyncCSS = [];
                                        if (entries[entryName]) for (let filePath of entries[entryName]){
                                            let fileURL = ensureAssetPrefix(filePath, publicPath);
                                            isCSSPath(filePath) ? initialCSS.push(fileURL) : initialJS.push(fileURL);
                                        }
                                        for (let file of chunkFiles){
                                            file.isInitial || (isCSSPath(file.path) ? asyncCSS.push(file.path) : asyncJS.push(file.path));
                                            let relatedLICENSE = licenseMap.get(file.path);
                                            if (relatedLICENSE && assets.add(relatedLICENSE), file.chunk) for (let auxiliaryFile of file.chunk.auxiliaryFiles)assets.add(auxiliaryFile);
                                        }
                                        let entryManifest = {};
                                        assets.size && (entryManifest.assets = Array.from(assets));
                                        let htmlPath = files.find((f)=>f.name === htmlPaths[entryName])?.path;
                                        htmlPath && (entryManifest.html = [
                                            htmlPath
                                        ]), initialJS.length && (entryManifest.initial = {
                                            js: initialJS
                                        }), initialCSS.length && (entryManifest.initial = {
                                            ...entryManifest.initial || {},
                                            css: initialCSS
                                        }), asyncJS.length && (entryManifest.async = {
                                            js: asyncJS
                                        }), asyncCSS.length && (entryManifest.async = {
                                            ...entryManifest.async || {},
                                            css: asyncCSS
                                        }), manifestEntries[entryName] = entryManifest;
                                    }
                                    let manifestData = {
                                        allFiles,
                                        entries: manifestEntries
                                    };
                                    if (manifestOptions.generate) {
                                        let generatedManifest = manifestOptions.generate({
                                            files,
                                            manifestData
                                        });
                                        if (isObject(generatedManifest)) return environment1.manifest = generatedManifest, generatedManifest;
                                        throw Error(`${color.dim('[rsbuild:manifest]')} \`manifest.generate\` function must return a valid manifest object.`);
                                    }
                                    return environment1.manifest = manifestData, manifestData;
                                })
                            }
                        ]);
                    }), api.onAfterCreateCompiler(()=>{
                        if (manifestFilenames.size <= 1) return void manifestFilenames.clear();
                        let environmentNames = Array.from(manifestFilenames.keys()), filenames = Array.from(manifestFilenames.values());
                        new Set(filenames).size !== filenames.length && logger.warn(`${color.dim('[rsbuild:manifest]')} The ${color.yellow('"manifest.filename"')} option must be unique when there are multiple environments (${environmentNames.join(', ')}), otherwise the manifest file will be overwritten.`), manifestFilenames.clear();
                    });
                }
            },
            pluginModuleFederation(),
            {
                name: 'rsbuild:rspack-profile',
                setup (api) {
                    let traceOutput;
                    if ('webpack' === api.context.bundlerType) return;
                    let { RSPACK_PROFILE } = process.env;
                    if (!RSPACK_PROFILE) return;
                    let onStart = async ()=>{
                        traceOutput = await applyProfile(api.context.rootPath, RSPACK_PROFILE, process.env.RSPACK_TRACE_LAYER, process.env.RSPACK_TRACE_OUTPUT);
                    };
                    api.onBeforeBuild(async ({ isFirstCompile })=>{
                        isFirstCompile && await onStart();
                    }), api.onBeforeStartDevServer(onStart), api.onExit(()=>{
                        traceOutput && (rspack_rspack.experiments.globalTrace.cleanup(), logger.info(`profile file saved to ${color.cyan(traceOutput)}`));
                    });
                }
            },
            {
                name: 'rsbuild:lazy-compilation',
                apply: 'serve',
                setup (api) {
                    api.modifyBundlerChain((chain, { environment, target })=>{
                        if ('web' !== target || 'webpack' === api.context.bundlerType) return;
                        let { config } = environment, options = config.dev?.lazyCompilation;
                        if (options) {
                            if (!0 === options && Object.keys(chain.entryPoints.entries() || {}).length <= 1) return void chain.lazyCompilation({
                                entries: !1,
                                imports: !0
                            });
                            if ('object' == typeof options && 'string' == typeof options.serverUrl && api.context.devServer) return void chain.lazyCompilation({
                                ...options,
                                serverUrl: replacePortPlaceholder(options.serverUrl, api.context.devServer.port)
                            });
                            chain.lazyCompilation(options);
                        }
                    });
                }
            },
            {
                name: 'rsbuild:sri',
                setup (api) {
                    api.modifyBundlerChain((chain, { environment, CHAIN_ID, rspack })=>{
                        if ('webpack' === api.context.bundlerType) return;
                        let { config, htmlPaths } = environment;
                        if (0 === Object.keys(htmlPaths).length) return;
                        let { sri } = config.security;
                        if (!('auto' === sri.enable ? 'production' === config.mode : sri.enable)) return;
                        let crossorigin = chain.output.get('crossOriginLoading');
                        (!1 === crossorigin || void 0 === crossorigin) && chain.output.crossOriginLoading('anonymous');
                        let { algorithm = 'sha384' } = sri;
                        chain.plugin(CHAIN_ID.PLUGIN.SUBRESOURCE_INTEGRITY).use(rspack.experiments.SubresourceIntegrityPlugin, [
                            {
                                enabled: !0,
                                hashFuncNames: [
                                    algorithm
                                ],
                                htmlPlugin: external_node_path_default().join(COMPILED_PATH, 'html-rspack-plugin/index.js')
                            }
                        ]);
                    });
                }
            },
            {
                name: 'rsbuild:nonce',
                setup (api) {
                    api.onAfterCreateCompiler(({ compiler, environments })=>{
                        let environmentList = Object.values(environments), nonces = Object.values(environments).map((environment)=>environment.config.security.nonce);
                        nonces.some((nonce)=>!!nonce) && applyToCompiler(compiler, (compiler, index)=>{
                            let nonce = nonces[index], environment = environmentList.find((item)=>item.index === index);
                            if (!Object.keys(environment?.htmlPaths ?? {}).length || !nonce) return;
                            let injectCode = createVirtualModule(`__webpack_nonce__ = "${nonce}";`);
                            new compiler.webpack.EntryPlugin(compiler.context, injectCode, {
                                name: void 0
                            }).apply(compiler);
                        });
                    }), api.modifyHTMLTags({
                        order: 'post',
                        handler: ({ headTags, bodyTags }, { environment })=>{
                            let { config } = environment, { nonce } = config.security, allTags = [
                                ...headTags,
                                ...bodyTags
                            ];
                            if (nonce) for (let tag of allTags)("script" === tag.tag || 'style' === tag.tag || 'link' === tag.tag && tag.attrs?.rel === 'preload' && tag.attrs?.as === "script") && (tag.attrs ??= {}, tag.attrs.nonce = nonce);
                            return {
                                headTags,
                                bodyTags
                            };
                        }
                    });
                }
            }
        ]);
    }
    function applyEnvsToConfig(config, envs) {
        if (null !== envs && (config.source ||= {}, config.source.define = {
            ...envs.publicVars,
            ...config.source.define
        }, 0 !== envs.filePaths.length && (config.dev ||= {}, config.dev.watchFiles = [
            ...config.dev.watchFiles ? helpers_castArray(config.dev.watchFiles) : [],
            {
                paths: envs.filePaths,
                type: 'reload-server'
            }
        ], config.performance?.buildCache))) {
            let { buildCache } = config.performance;
            !0 === buildCache ? config.performance.buildCache = {
                buildDependencies: envs.filePaths
            } : (buildCache.buildDependencies ||= [], buildCache.buildDependencies.push(...envs.filePaths));
        }
    }
    async function createRsbuild(options = {}) {
        let envs = options.loadEnv ? loadEnv({
            cwd: options.cwd,
            ...'boolean' == typeof options.loadEnv ? {} : options.loadEnv
        }) : null, configOrFactory = options.config ?? options.rsbuildConfig, config = isFunction(configOrFactory) ? await configOrFactory() : configOrFactory || {};
        config.logLevel && !isDebug() && (logger.level = config.logLevel), applyEnvsToConfig(config, envs);
        let resolvedOptions = {
            cwd: process.cwd(),
            callerName: 'rsbuild',
            ...options,
            rsbuildConfig: config
        }, pluginManager = createPluginManager(), context = await createContext(resolvedOptions, config), getPluginAPI = initPluginAPI({
            context,
            pluginManager
        });
        context.getPluginAPI = getPluginAPI;
        let globalPluginAPI = getPluginAPI();
        logger.debug('registering default plugins'), applyDefaultPlugins(pluginManager, context), logger.debug('default plugins registered');
        let provider = config.provider || rspackProvider, providerInstance = await provider({
            context,
            pluginManager,
            rsbuildOptions: resolvedOptions,
            helpers: provider_helpers_namespaceObject
        }), preview = async (options = {})=>{
            context.action = 'preview', process.env.NODE_ENV || setNodeEnv('production');
            let config = await initRsbuildConfig({
                context,
                pluginManager
            }), { distPath } = context, { checkDistDir = !0 } = options;
            if (checkDistDir) {
                if (!(0, external_node_fs_.existsSync)(distPath)) throw Error(`${color.dim('[rsbuild:preview]')} The output directory ${color.yellow(distPath)} does not exist, please build the project before previewing.`);
                if (isEmptyDir(distPath)) throw Error(`${color.dim('[rsbuild:preview]')} The output directory ${color.yellow(distPath)} is empty, please build the project before previewing.`);
            }
            return startProdServer(context, config, options);
        }, build = async (...args)=>{
            context.action = 'build', process.env.NODE_ENV || setNodeEnv('production');
            let buildInstance = await providerInstance.build(...args);
            return {
                ...buildInstance,
                close: async ()=>{
                    await context.hooks.onCloseBuild.callBatch(), await buildInstance.close();
                }
            };
        }, initAction = ()=>{
            context.action || (context.action = 'development' === config.mode ? 'dev' : 'build');
        }, rsbuild = {
            build,
            preview,
            startDevServer: (...args)=>(context.action = 'dev', process.env.NODE_ENV || setNodeEnv('development'), providerInstance.startDevServer(...args)),
            createCompiler: (...args)=>(initAction(), providerInstance.createCompiler(...args)),
            createDevServer: (...args)=>(context.action = 'dev', process.env.NODE_ENV || setNodeEnv('development'), providerInstance.createDevServer(...args)),
            inspectConfig: async (...args)=>(initAction(), providerInstance.inspectConfig(...args)),
            ...pick(pluginManager, [
                'addPlugins',
                'getPlugins',
                'removePlugins',
                'isPluginExists'
            ]),
            ...pick(globalPluginAPI, [
                'context',
                'expose',
                'getRsbuildConfig',
                'getNormalizedConfig',
                'modifyEnvironmentConfig',
                'modifyRsbuildConfig',
                'onAfterBuild',
                'onAfterCreateCompiler',
                'onAfterDevCompile',
                'onAfterEnvironmentCompile',
                'onAfterStartDevServer',
                'onAfterStartProdServer',
                'onBeforeBuild',
                'onBeforeCreateCompiler',
                'onBeforeDevCompile',
                'onBeforeEnvironmentCompile',
                'onBeforeStartDevServer',
                'onBeforeStartProdServer',
                'onCloseBuild',
                'onCloseDevServer',
                'onDevCompileDone',
                'onExit'
            ]),
            ...pick(providerInstance, [
                'initConfigs'
            ])
        };
        envs && (rsbuild.onCloseBuild(envs.cleanup), rsbuild.onCloseDevServer(envs.cleanup));
        let getFlattenedPlugins = async (pluginOptions)=>{
            let plugins = pluginOptions;
            do plugins = (await Promise.all(plugins)).flat(1 / 0);
            while (plugins.some((v)=>(0, types_namespaceObject.isPromise)(v)));
            return plugins;
        };
        if (config.plugins) {
            let plugins = await getFlattenedPlugins(config.plugins);
            rsbuild.addPlugins(plugins);
        }
        return config.environments && await Promise.all(Object.entries(config.environments).map(async ([name, environmentConfig])=>{
            if (!environmentConfig.plugins || context.specifiedEnvironments && !context.specifiedEnvironments.includes(name)) return;
            let plugins = await getFlattenedPlugins(environmentConfig.plugins);
            rsbuild.addPlugins(plugins, {
                environment: name
            });
        })), rsbuild;
    }
    function defineConfig(config) {
        return config;
    }
    async function loadConfig_loadConfig({ cwd = process.cwd(), path, envMode, meta, loader = 'jiti' } = {}) {
        let configExport, configFilePath = ((root, customConfig)=>{
            if (customConfig) {
                let customConfigPath = (0, external_node_path_.isAbsolute)(customConfig) ? customConfig : (0, external_node_path_.join)(root, customConfig);
                if (external_node_fs_default().existsSync(customConfigPath)) return customConfigPath;
                logger.warn(`Cannot find config file: ${color.dim(customConfigPath)}\n`);
            }
            for (let file of [
                'rsbuild.config.mjs',
                'rsbuild.config.ts',
                'rsbuild.config.js',
                'rsbuild.config.cjs',
                'rsbuild.config.mts',
                'rsbuild.config.cts'
            ]){
                let configFile = (0, external_node_path_.join)(root, file);
                if (external_node_fs_default().existsSync(configFile)) return configFile;
            }
            return null;
        })(cwd, path);
        if (!configFilePath) return logger.debug('no config file found.'), {
            content: {},
            filePath: configFilePath
        };
        let applyMetaInfo = (config)=>(config._privateMeta = {
                configFilePath
            }, config);
        if ('native' === loader || 'auto' === loader && (process.features.typescript || process.versions.bun || process.versions.deno) || /\.(?:js|mjs|cjs)$/.test(configFilePath)) try {
            let configFileURL = (0, external_node_url_.pathToFileURL)(configFilePath).href, exportModule = await import(`${configFileURL}?t=${Date.now()}`);
            configExport = exportModule.default ? exportModule.default : exportModule;
        } catch (err) {
            let errorMessage = `Failed to load file with native loader: ${color.dim(configFilePath)}`;
            if ('native' === loader) throw logger.error(errorMessage), err;
            logger.debug(`${errorMessage}, fallback to jiti.`), logger.debug(err);
        }
        if (void 0 === configExport) try {
            let { createJiti } = await import("jiti"), jiti = createJiti(constants_filename, {
                moduleCache: !1,
                interopDefault: !0,
                nativeModules: [
                    '@rspack/core',
                    "typescript"
                ]
            });
            configExport = await jiti.import(configFilePath, {
                default: !0
            });
        } catch (err) {
            throw logger.error(`Failed to load file with jiti: ${color.dim(configFilePath)}`), err;
        }
        if ('function' == typeof configExport) {
            let command = process.argv[2], nodeEnv = process.env.NODE_ENV || '', result = await configExport({
                env: nodeEnv,
                command,
                envMode: envMode || nodeEnv,
                meta
            });
            if (void 0 === result) throw Error(`${color.dim('[rsbuild:loadConfig]')} The config function must return a config object.`);
            return {
                content: applyMetaInfo(result),
                filePath: configFilePath
            };
        }
        if (!isObject(configExport)) throw Error(`${color.dim('[rsbuild:loadConfig]')} The config must be an object or a function that returns an object, get ${color.yellow(configExport)}`);
        return logger.debug('configuration loaded from:', configFilePath), {
            content: applyMetaInfo(configExport),
            filePath: configFilePath
        };
    }
    let commonOpts = {}, init_loadConfig = async (root)=>{
        let { content: config, filePath } = await loadConfig_loadConfig({
            cwd: root,
            path: commonOpts.config,
            envMode: commonOpts.envMode,
            loader: commonOpts.configLoader
        });
        return config.dev ||= {}, config.source ||= {}, config.server ||= {}, commonOpts.base && (config.server.base = commonOpts.base), commonOpts.root && (config.root = root), commonOpts.mode && (config.mode = commonOpts.mode), commonOpts.logLevel && (config.logLevel = commonOpts.logLevel), commonOpts.open && !config.server?.open && (config.server.open = commonOpts.open), commonOpts.host && (config.server.host = commonOpts.host), commonOpts.port && (config.server.port = commonOpts.port), void 0 === config.dev.cliShortcuts && (config.dev.cliShortcuts = !0), filePath && (config.dev.watchFiles = [
            ...config.dev.watchFiles ? helpers_castArray(config.dev.watchFiles) : [],
            {
                paths: filePath,
                type: 'reload-server'
            }
        ]), config;
    };
    async function init_init({ cliOptions, isRestart, isBuildWatch = !1 }) {
        cliOptions && (commonOpts = cliOptions), commonOpts.environment = commonOpts.environment?.flatMap((env)=>env.split(','));
        try {
            var cwd, envDir;
            let cwd1 = process.cwd(), root = commonOpts.root ? ensureAbsolutePath(cwd1, commonOpts.root) : cwd1, rsbuild = await createRsbuild({
                cwd: root,
                config: ()=>init_loadConfig(root),
                environment: commonOpts.environment,
                loadEnv: !1 !== commonOpts.env && {
                    cwd: (cwd = root, (envDir = commonOpts.envDir) ? external_node_path_default().isAbsolute(envDir) ? envDir : external_node_path_default().join(cwd, envDir) : cwd),
                    mode: commonOpts.envMode
                }
            });
            return rsbuild.onBeforeCreateCompiler(()=>{
                if ('dev' !== rsbuild.context.action && !isBuildWatch) return;
                let files = [], config = rsbuild.getNormalizedConfig();
                if (config.dev.watchFiles) for (let watchConfig of config.dev.watchFiles){
                    if ('reload-server' !== watchConfig.type) continue;
                    let paths = helpers_castArray(watchConfig.paths);
                    watchConfig.options ? watchFilesForRestart({
                        files: paths,
                        rsbuild,
                        isBuildWatch,
                        watchOptions: watchConfig.options
                    }) : files.push(...paths);
                }
                watchFilesForRestart({
                    files,
                    rsbuild,
                    isBuildWatch
                });
            }), rsbuild;
        } catch (err) {
            if (isRestart) logger.error(err);
            else throw err;
        }
    }
    let cleaners = [], onBeforeRestartServer = (cleaner)=>{
        cleaners.push(cleaner);
    }, beforeRestart = async ({ filePath, clear = !0, id })=>{
        if (clear && isTTY() && !process.env.DEBUG && process.stdout.write('\x1B[H\x1B[2J'), filePath) {
            let filename = external_node_path_default().basename(filePath);
            logger.info(`restarting ${id} as ${color.yellow(filename)} changed\n`);
        } else logger.info(`restarting ${id}...\n`);
        for (let cleaner of cleaners)await cleaner();
        cleaners = [];
    }, restartDevServer = async ({ filePath, clear = !0 } = {})=>{
        await beforeRestart({
            filePath,
            clear,
            id: 'server'
        });
        let rsbuild = await init_init({
            isRestart: !0
        });
        return !!rsbuild && (await rsbuild.startDevServer(), !0);
    }, restartBuild = async ({ filePath, clear = !0 } = {})=>{
        await beforeRestart({
            filePath,
            clear,
            id: 'build'
        });
        let rsbuild = await init_init({
            isRestart: !0,
            isBuildWatch: !0
        });
        return !!rsbuild && (onBeforeRestartServer((await rsbuild.build({
            watch: !0
        })).close), !0);
    };
    async function watchFilesForRestart({ files, rsbuild, isBuildWatch, watchOptions }) {
        if (!files.length) return;
        let root = rsbuild.context.rootPath, watcher = await createChokidar(files, root, {
            ignoreInitial: !0,
            ignorePermissionErrors: !0,
            ...watchOptions
        }), restarting = !1, onChange = async (filePath)=>{
            restarting || (restarting = !0, (isBuildWatch ? await restartBuild({
                filePath
            }) : await restartDevServer({
                filePath
            })) ? await watcher.close() : logger.error(isBuildWatch ? 'Restart build failed.' : 'Restart server failed.'), restarting = !1);
        };
        watcher.on('add', onChange), watcher.on('change', onChange), watcher.on('unlink', onChange);
    }
    let applyServerOptions = (command)=>{
        command.option('-o, --open [url]', 'Open the page in browser on startup').option('--port <port>', 'Set the port number for the server').option('--host <host>', 'Set the host that the server listens to');
    };
    function setupCommands() {
        let cli = ((name = "")=>new CAC(name))('rsbuild');
        cli.version("1.6.7"), cli.option('--base <base>', 'Set the base path of the server').option('-c, --config <config>', 'Set the configuration file (relative or absolute path)').option('--config-loader <loader>', 'Set the config file loader (auto | jiti | native)', {
            default: 'auto'
        }).option('--env-dir <dir>', 'Set the directory for loading `.env` files').option('--env-mode <mode>', 'Set the env mode to load the `.env.[mode]` file').option('--environment <name>', 'Set the environment name(s) to build', {
            type: [
                String
            ],
            default: []
        }).option('--log-level <level>', 'Set the log level (info | warn | error | silent)').option('-m, --mode <mode>', 'Set the build mode (development | production | none)').option('-r, --root <root>', 'Set the project root directory (absolute path or relative to cwd)').option('--no-env', 'Disable loading of `.env` files');
        let devDescription = `Start the dev server ${color.dim('(default if no command is given)')}`, devCommand = cli.command('', devDescription).alias('dev'), buildCommand = cli.command('build', 'Build the app for production'), previewCommand = cli.command('preview', 'Preview the production build locally'), inspectCommand = cli.command('inspect', 'Inspect the Rspack and Rsbuild configs');
        applyServerOptions(devCommand), applyServerOptions(previewCommand), devCommand.action(async (options)=>{
            try {
                let rsbuild = await init_init({
                    cliOptions: options
                });
                await rsbuild?.startDevServer();
            } catch (err) {
                logger.error('Failed to start dev server.'), logger.error(err), process.exit(1);
            }
        }), buildCommand.option('-w, --watch', 'Enable watch mode to automatically rebuild on file changes').action(async (options)=>{
            try {
                options.watch || (process.env.RSPACK_UNSAFE_FAST_DROP = 'true');
                let rsbuild = await init_init({
                    cliOptions: options,
                    isBuildWatch: options.watch
                }), buildInstance = await rsbuild?.build({
                    watch: options.watch
                });
                buildInstance && (options.watch ? onBeforeRestartServer(buildInstance.close) : await buildInstance.close());
            } catch (err) {
                err instanceof Error && err.message === RSPACK_BUILD_ERROR || logger.error('Failed to build.'), logger.error(err), process.exit(1);
            }
        }), previewCommand.action(async (options)=>{
            try {
                let rsbuild = await init_init({
                    cliOptions: options
                });
                await rsbuild?.preview();
            } catch (err) {
                logger.error('Failed to start preview server.'), logger.error(err), process.exit(1);
            }
        }), inspectCommand.option('--output <output>', 'Set the output path for inspection results').option('--verbose', 'Show complete function definitions in output').action(async (options)=>{
            try {
                let rsbuild = await init_init({
                    cliOptions: options
                });
                await rsbuild?.inspectConfig({
                    verbose: options.verbose,
                    outputPath: options.output,
                    writeToDisk: !0
                });
            } catch (err) {
                logger.error('Failed to inspect config.'), logger.error(err), process.exit(1);
            }
        }), cli.help((sections)=>{
            for (let section of (sections.shift(), sections))'Usage' === section.title && (section.body = section.body.replace('$ rsbuild', color.yellow("$ rsbuild [command] [options]"))), 'Commands' === section.title && (section.body = section.body.replace(`         ${devDescription}`, `dev      ${devDescription}`)), section.title?.startsWith('For more info') ? (section.title = color.dim('  For details on a sub-command, run'), section.body = color.dim('  $ rsbuild <command> -h')) : section.title = color.cyan(section.title);
        }), cli.parse();
    }
    let { argv: cli_argv } = process;
    function initNodeEnv() {
        if (!process.env.NODE_ENV) {
            let command = cli_argv[2];
            process.env.NODE_ENV = [
                'build',
                'preview'
            ].includes(command) ? 'production' : 'development';
        }
    }
    function showGreeting() {
        let { npm_execpath, npm_lifecycle_event, NODE_RUN_SCRIPT_NAME } = process.env, isBun = npm_execpath?.includes('.bun');
        logger.greet(`${'npx' === npm_lifecycle_event || isBun || NODE_RUN_SCRIPT_NAME ? '\n' : ''}Rsbuild v1.6.7\n`);
    }
    function setupLogLevel() {
        let logLevelIndex = process.argv.findIndex((item)=>'--log-level' === item || '--logLevel' === item);
        if (-1 !== logLevelIndex) {
            let level = process.argv[logLevelIndex + 1];
            level && [
                'warn',
                'error',
                'silent'
            ].includes(level) && !isDebug() && (logger.level = level);
        }
    }
    function runCLI() {
        process.title = 'rsbuild-node', initNodeEnv(), setupLogLevel(), showGreeting();
        try {
            setupCommands();
        } catch (err) {
            logger.error('Failed to start Rsbuild CLI.'), logger.error(err);
        }
    }
    let src_version = "1.6.7";
})(), exports.PLUGIN_CSS_NAME = __webpack_exports__.PLUGIN_CSS_NAME, exports.PLUGIN_SWC_NAME = __webpack_exports__.PLUGIN_SWC_NAME, exports.createRsbuild = __webpack_exports__.createRsbuild, exports.defaultAllowedOrigins = __webpack_exports__.defaultAllowedOrigins, exports.defineConfig = __webpack_exports__.defineConfig, exports.ensureAssetPrefix = __webpack_exports__.ensureAssetPrefix, exports.loadConfig = __webpack_exports__.loadConfig, exports.loadEnv = __webpack_exports__.loadEnv, exports.logger = __webpack_exports__.logger, exports.mergeRsbuildConfig = __webpack_exports__.mergeRsbuildConfig, exports.rspack = __webpack_exports__.rspack, exports.runCLI = __webpack_exports__.runCLI, exports.version = __webpack_exports__.version, __webpack_exports__)-1 === [
    "PLUGIN_CSS_NAME",
    "PLUGIN_SWC_NAME",
    "createRsbuild",
    "defaultAllowedOrigins",
    "defineConfig",
    "ensureAssetPrefix",
    "loadConfig",
    "loadEnv",
    "logger",
    "mergeRsbuildConfig",
    "rspack",
    "runCLI",
    "version"
].indexOf(__webpack_i__) && (exports[__webpack_i__] = __webpack_exports__[__webpack_i__]);
Object.defineProperty(exports, '__esModule', {
    value: !0
});
